// This file is auto-generated by vulkano autogen from vk.xml header version 191.
// It should not be edited manually. Changes should be made by editing autogen.

#[doc = r" Represents all the features that are available on a physical device or enabled on"]
#[doc = r" a logical device."]
#[doc = r""]
#[doc = r" Note that the `robust_buffer_access` is guaranteed to be supported by all Vulkan"]
#[doc = r" implementations."]
#[doc = r""]
#[doc = r" # Example"]
#[doc = r""]
#[doc = r" ```"]
#[doc = r" use vulkano::device::Features;"]
#[doc = r" # let physical_device: vulkano::device::physical::PhysicalDevice = return;"]
#[doc = r" let minimal_features = Features {"]
#[doc = r"     geometry_shader: true,"]
#[doc = r"     .. Features::none()"]
#[doc = r" };"]
#[doc = r""]
#[doc = r" let optimal_features = vulkano::device::Features {"]
#[doc = r"     geometry_shader: true,"]
#[doc = r"     tessellation_shader: true,"]
#[doc = r"     .. Features::none()"]
#[doc = r" };"]
#[doc = r""]
#[doc = r" if !physical_device.supported_features().is_superset_of(&minimal_features) {"]
#[doc = r#"     panic!("The physical device is not good enough for this application.");"#]
#[doc = r" }"]
#[doc = r""]
#[doc = r" assert!(optimal_features.is_superset_of(&minimal_features));"]
#[doc = r" let features_to_request = optimal_features.intersection(physical_device.supported_features());"]
#[doc = r" ```"]
#[doc = r""]
#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]
pub struct Features {
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-acceleration_structure)"]
    pub acceleration_structure: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-acceleration_structure_capture_replay)"]
    pub acceleration_structure_capture_replay: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-acceleration_structure_host_commands)"]
    pub acceleration_structure_host_commands: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-acceleration_structure_indirect_build)"]
    pub acceleration_structure_indirect_build: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT.html#features-advanced_blend_coherent_operations)"]
    pub advanced_blend_coherent_operations: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-alpha_to_one)"]
    pub alpha_to_one: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html#features-attachment_fragment_shading_rate)\n- Conflicts with features: [`shading_rate_image`](crate::device::Features::shading_rate_image), [`fragment_density_map`](crate::device::Features::fragment_density_map)"]
    pub attachment_fragment_shading_rate: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesEXT.html#features-bresenham_lines)"]
    pub bresenham_lines: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-buffer_device_address)"]
    pub buffer_device_address: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-buffer_device_address_capture_replay)"]
    pub buffer_device_address_capture_replay: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-buffer_device_address_multi_device)"]
    pub buffer_device_address_multi_device: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceColorWriteEnableFeaturesEXT.html#features-color_write_enable)"]
    pub color_write_enable: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.html#features-compute_derivative_group_linear)"]
    pub compute_derivative_group_linear: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceComputeShaderDerivativesFeaturesNV.html#features-compute_derivative_group_quads)"]
    pub compute_derivative_group_quads: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.html#features-compute_full_subgroups)"]
    pub compute_full_subgroups: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceConditionalRenderingFeaturesEXT.html#features-conditional_rendering)"]
    pub conditional_rendering: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-constant_alpha_color_blend_factors)"]
    pub constant_alpha_color_blend_factors: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesNV.html#features-cooperative_matrix)"]
    pub cooperative_matrix: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceCooperativeMatrixFeaturesNV.html#features-cooperative_matrix_robust_buffer_access)"]
    pub cooperative_matrix_robust_buffer_access: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceCornerSampledImageFeaturesNV.html#features-corner_sampled_image)"]
    pub corner_sampled_image: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceCoverageReductionModeFeaturesNV.html#features-coverage_reduction_mode)"]
    pub coverage_reduction_mode: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceCustomBorderColorFeaturesEXT.html#features-custom_border_color_without_format)"]
    pub custom_border_color_without_format: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceCustomBorderColorFeaturesEXT.html#features-custom_border_colors)"]
    pub custom_border_colors: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceASTCDecodeFeaturesEXT.html#features-decode_mode_shared_exponent)"]
    pub decode_mode_shared_exponent: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV.html#features-dedicated_allocation_image_aliasing)"]
    pub dedicated_allocation_image_aliasing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-depth_bias_clamp)"]
    pub depth_bias_clamp: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-depth_bounds)"]
    pub depth_bounds: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-depth_clamp)"]
    pub depth_clamp: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDepthClipEnableFeaturesEXT.html#features-depth_clip_enable)"]
    pub depth_clip_enable: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceAccelerationStructureFeaturesKHR.html#features-descriptor_binding_acceleration_structure_update_after_bind)"]
    pub descriptor_binding_acceleration_structure_update_after_bind: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.html#features-descriptor_binding_inline_uniform_block_update_after_bind)"]
    pub descriptor_binding_inline_uniform_block_update_after_bind: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_binding_partially_bound)"]
    pub descriptor_binding_partially_bound: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_binding_sampled_image_update_after_bind)"]
    pub descriptor_binding_sampled_image_update_after_bind: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_binding_storage_buffer_update_after_bind)"]
    pub descriptor_binding_storage_buffer_update_after_bind: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_binding_storage_image_update_after_bind)"]
    pub descriptor_binding_storage_image_update_after_bind: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_binding_storage_texel_buffer_update_after_bind)"]
    pub descriptor_binding_storage_texel_buffer_update_after_bind: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_binding_uniform_buffer_update_after_bind)"]
    pub descriptor_binding_uniform_buffer_update_after_bind: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_binding_uniform_texel_buffer_update_after_bind)"]
    pub descriptor_binding_uniform_texel_buffer_update_after_bind: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_binding_update_unused_while_pending)"]
    pub descriptor_binding_update_unused_while_pending: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_binding_variable_descriptor_count)"]
    pub descriptor_binding_variable_descriptor_count: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-descriptor_indexing)\n- Required by device extension: [`ext_descriptor_indexing`](crate::device::DeviceExtensions::ext_descriptor_indexing)"]
    pub descriptor_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceCoherentMemoryFeaturesAMD.html#features-device_coherent_memory)"]
    pub device_coherent_memory: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV.html#features-device_generated_commands)"]
    pub device_generated_commands: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDeviceMemoryReportFeaturesEXT.html#features-device_memory_report)"]
    pub device_memory_report: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceDiagnosticsConfigFeaturesNV.html#features-diagnostics_config)"]
    pub diagnostics_config: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-draw_indirect_count)\n- Required by device extension: [`khr_draw_indirect_count`](crate::device::DeviceExtensions::khr_draw_indirect_count)"]
    pub draw_indirect_count: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-draw_indirect_first_instance)"]
    pub draw_indirect_first_instance: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-dual_src_blend)"]
    pub dual_src_blend: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-events)"]
    pub events: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExclusiveScissorFeaturesNV.html#features-exclusive_scissor)"]
    pub exclusive_scissor: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExtendedDynamicStateFeaturesEXT.html#features-extended_dynamic_state)"]
    pub extended_dynamic_state: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html#features-extended_dynamic_state2)"]
    pub extended_dynamic_state2: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html#features-extended_dynamic_state2_logic_op)"]
    pub extended_dynamic_state2_logic_op: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExtendedDynamicState2FeaturesEXT.html#features-extended_dynamic_state2_patch_control_points)"]
    pub extended_dynamic_state2_patch_control_points: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceExternalMemoryRDMAFeaturesNV.html#features-external_memory_rdma)"]
    pub external_memory_rdma: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-fill_mode_non_solid)"]
    pub fill_mode_non_solid: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevice4444FormatsFeaturesEXT.html#features-format_a4b4g4r4)"]
    pub format_a4b4g4r4: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevice4444FormatsFeaturesEXT.html#features-format_a4r4g4b4)"]
    pub format_a4r4g4b4: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html#features-fragment_density_map)\n- Conflicts with features: [`pipeline_fragment_shading_rate`](crate::device::Features::pipeline_fragment_shading_rate), [`primitive_fragment_shading_rate`](crate::device::Features::primitive_fragment_shading_rate), [`attachment_fragment_shading_rate`](crate::device::Features::attachment_fragment_shading_rate)"]
    pub fragment_density_map: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentDensityMap2FeaturesEXT.html#features-fragment_density_map_deferred)"]
    pub fragment_density_map_deferred: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html#features-fragment_density_map_dynamic)"]
    pub fragment_density_map_dynamic: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentDensityMapFeaturesEXT.html#features-fragment_density_map_non_subsampled_images)"]
    pub fragment_density_map_non_subsampled_images: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV.html#features-fragment_shader_barycentric)"]
    pub fragment_shader_barycentric: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html#features-fragment_shader_pixel_interlock)"]
    pub fragment_shader_pixel_interlock: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html#features-fragment_shader_sample_interlock)"]
    pub fragment_shader_sample_interlock: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT.html#features-fragment_shader_shading_rate_interlock)"]
    pub fragment_shader_shading_rate_interlock: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html#features-fragment_shading_rate_enums)"]
    pub fragment_shading_rate_enums: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-fragment_stores_and_atomics)"]
    pub fragment_stores_and_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-full_draw_index_uint32)"]
    pub full_draw_index_uint32: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-geometry_shader)"]
    pub geometry_shader: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceTransformFeedbackFeaturesEXT.html#features-geometry_streams)"]
    pub geometry_streams: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT.html#features-global_priority_query)"]
    pub global_priority_query: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-host_query_reset)"]
    pub host_query_reset: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-image_cube_array)"]
    pub image_cube_array: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderImageFootprintFeaturesNV.html#features-image_footprint)"]
    pub image_footprint: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-image_view2_d_on3_d_image)"]
    pub image_view2_d_on3_d_image: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-image_view_format_reinterpretation)"]
    pub image_view_format_reinterpretation: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-image_view_format_swizzle)"]
    pub image_view_format_swizzle: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-imageless_framebuffer)"]
    pub imageless_framebuffer: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-independent_blend)"]
    pub independent_blend: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceIndexTypeUint8FeaturesEXT.html#features-index_type_uint8)"]
    pub index_type_uint8: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceConditionalRenderingFeaturesEXT.html#features-inherited_conditional_rendering)"]
    pub inherited_conditional_rendering: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-inherited_queries)"]
    pub inherited_queries: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceInheritedViewportScissorFeaturesNV.html#features-inherited_viewport_scissor2_d)"]
    pub inherited_viewport_scissor2_d: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceInlineUniformBlockFeaturesEXT.html#features-inline_uniform_block)"]
    pub inline_uniform_block: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceInvocationMaskFeaturesHUAWEI.html#features-invocation_mask)"]
    pub invocation_mask: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-large_points)"]
    pub large_points: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-logic_op)"]
    pub logic_op: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMemoryPriorityFeaturesEXT.html#features-memory_priority)"]
    pub memory_priority: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesNV.html#features-mesh_shader)"]
    pub mesh_shader: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMultiDrawFeaturesEXT.html#features-multi_draw)"]
    pub multi_draw: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-multi_draw_indirect)"]
    pub multi_draw_indirect: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-multi_viewport)"]
    pub multi_viewport: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-multisample_array_image)"]
    pub multisample_array_image: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-multiview)"]
    pub multiview: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-multiview_geometry_shader)"]
    pub multiview_geometry_shader: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-multiview_tessellation_shader)"]
    pub multiview_tessellation_shader: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-mutable_comparison_samplers)"]
    pub mutable_comparison_samplers: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMutableDescriptorTypeFeaturesVALVE.html#features-mutable_descriptor_type)"]
    pub mutable_descriptor_type: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html#features-no_invocation_fragment_shading_rates)"]
    pub no_invocation_fragment_shading_rates: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html#features-null_descriptor)"]
    pub null_descriptor: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-occlusion_query_precise)"]
    pub occlusion_query_precise: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT.html#features-pageable_device_local_memory)"]
    pub pageable_device_local_memory: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePerformanceQueryFeaturesKHR.html#features-performance_counter_multiple_query_pools)"]
    pub performance_counter_multiple_query_pools: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePerformanceQueryFeaturesKHR.html#features-performance_counter_query_pools)"]
    pub performance_counter_query_pools: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT.html#features-pipeline_creation_cache_control)"]
    pub pipeline_creation_cache_control: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR.html#features-pipeline_executable_info)"]
    pub pipeline_executable_info: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html#features-pipeline_fragment_shading_rate)\n- Conflicts with features: [`shading_rate_image`](crate::device::Features::shading_rate_image), [`fragment_density_map`](crate::device::Features::fragment_density_map)"]
    pub pipeline_fragment_shading_rate: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-pipeline_statistics_query)"]
    pub pipeline_statistics_query: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-point_polygons)"]
    pub point_polygons: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePresentIdFeaturesKHR.html#features-present_id)"]
    pub present_id: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePresentWaitFeaturesKHR.html#features-present_wait)"]
    pub present_wait: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShadingRateFeaturesKHR.html#features-primitive_fragment_shading_rate)\n- Conflicts with features: [`shading_rate_image`](crate::device::Features::shading_rate_image), [`fragment_density_map`](crate::device::Features::fragment_density_map)"]
    pub primitive_fragment_shading_rate: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.html#features-primitive_topology_list_restart)"]
    pub primitive_topology_list_restart: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT.html#features-primitive_topology_patch_list_restart)"]
    pub primitive_topology_patch_list_restart: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePrivateDataFeaturesEXT.html#features-private_data)"]
    pub private_data: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-protected_memory)"]
    pub protected_memory: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceProvokingVertexFeaturesEXT.html#features-provoking_vertex_last)"]
    pub provoking_vertex_last: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayQueryFeaturesKHR.html#features-ray_query)"]
    pub ray_query: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.html#features-ray_tracing_motion_blur)"]
    pub ray_tracing_motion_blur: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingMotionBlurFeaturesNV.html#features-ray_tracing_motion_blur_pipeline_trace_rays_indirect)"]
    pub ray_tracing_motion_blur_pipeline_trace_rays_indirect: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-ray_tracing_pipeline)"]
    pub ray_tracing_pipeline: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-ray_tracing_pipeline_shader_group_handle_capture_replay)"]
    pub ray_tracing_pipeline_shader_group_handle_capture_replay: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-ray_tracing_pipeline_shader_group_handle_capture_replay_mixed)"]
    pub ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-ray_tracing_pipeline_trace_rays_indirect)"]
    pub ray_tracing_pipeline_trace_rays_indirect: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRayTracingPipelineFeaturesKHR.html#features-ray_traversal_primitive_culling)"]
    pub ray_traversal_primitive_culling: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesEXT.html#features-rectangular_lines)"]
    pub rectangular_lines: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV.html#features-representative_fragment_test)"]
    pub representative_fragment_test: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-robust_buffer_access)"]
    pub robust_buffer_access: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html#features-robust_buffer_access2)"]
    pub robust_buffer_access2: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceImageRobustnessFeaturesEXT.html#features-robust_image_access)"]
    pub robust_image_access: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceRobustness2FeaturesEXT.html#features-robust_image_access2)"]
    pub robust_image_access2: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-runtime_descriptor_array)"]
    pub runtime_descriptor_array: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sample_rate_shading)"]
    pub sample_rate_shading: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sampler_anisotropy)"]
    pub sampler_anisotropy: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-sampler_filter_minmax)\n- Required by device extension: [`ext_sampler_filter_minmax`](crate::device::DeviceExtensions::ext_sampler_filter_minmax)"]
    pub sampler_filter_minmax: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-sampler_mip_lod_bias)"]
    pub sampler_mip_lod_bias: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-sampler_mirror_clamp_to_edge)\n- Required by device extension: [`khr_sampler_mirror_clamp_to_edge`](crate::device::DeviceExtensions::khr_sampler_mirror_clamp_to_edge)"]
    pub sampler_mirror_clamp_to_edge: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-sampler_ycbcr_conversion)"]
    pub sampler_ycbcr_conversion: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-scalar_block_layout)"]
    pub scalar_block_layout: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-separate_depth_stencil_layouts)"]
    pub separate_depth_stencil_layouts: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-separate_stencil_mask_ref)"]
    pub separate_stencil_mask_ref: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_buffer_float16_atomic_add)"]
    pub shader_buffer_float16_atomic_add: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_buffer_float16_atomic_min_max)"]
    pub shader_buffer_float16_atomic_min_max: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_buffer_float16_atomics)"]
    pub shader_buffer_float16_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_buffer_float32_atomic_add)"]
    pub shader_buffer_float32_atomic_add: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_buffer_float32_atomic_min_max)"]
    pub shader_buffer_float32_atomic_min_max: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_buffer_float32_atomics)"]
    pub shader_buffer_float32_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_buffer_float64_atomic_add)"]
    pub shader_buffer_float64_atomic_add: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_buffer_float64_atomic_min_max)"]
    pub shader_buffer_float64_atomic_min_max: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_buffer_float64_atomics)"]
    pub shader_buffer_float64_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_buffer_int64_atomics)"]
    pub shader_buffer_int64_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_clip_distance)"]
    pub shader_clip_distance: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_cull_distance)"]
    pub shader_cull_distance: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT.html#features-shader_demote_to_helper_invocation)"]
    pub shader_demote_to_helper_invocation: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderClockFeaturesKHR.html#features-shader_device_clock)"]
    pub shader_device_clock: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-shader_draw_parameters)\n- Required by device extension: [`khr_shader_draw_parameters`](crate::device::DeviceExtensions::khr_shader_draw_parameters)"]
    pub shader_draw_parameters: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_float16)"]
    pub shader_float16: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_float64)"]
    pub shader_float64: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_image_float32_atomic_add)"]
    pub shader_image_float32_atomic_add: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_image_float32_atomic_min_max)"]
    pub shader_image_float32_atomic_min_max: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_image_float32_atomics)"]
    pub shader_image_float32_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_image_gather_extended)"]
    pub shader_image_gather_extended: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.html#features-shader_image_int64_atomics)"]
    pub shader_image_int64_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_input_attachment_array_dynamic_indexing)"]
    pub shader_input_attachment_array_dynamic_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_input_attachment_array_non_uniform_indexing)"]
    pub shader_input_attachment_array_non_uniform_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_int16)"]
    pub shader_int16: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_int64)"]
    pub shader_int64: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_int8)"]
    pub shader_int8: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderIntegerDotProductFeaturesKHR.html#features-shader_integer_dot_product)"]
    pub shader_integer_dot_product: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL.html#features-shader_integer_functions2)"]
    pub shader_integer_functions2: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_output_layer)\n- Required by device extension: [`ext_shader_viewport_index_layer`](crate::device::DeviceExtensions::ext_shader_viewport_index_layer)"]
    pub shader_output_layer: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_output_viewport_index)\n- Required by device extension: [`ext_shader_viewport_index_layer`](crate::device::DeviceExtensions::ext_shader_viewport_index_layer)"]
    pub shader_output_viewport_index: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_resource_min_lod)"]
    pub shader_resource_min_lod: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_resource_residency)"]
    pub shader_resource_residency: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-shader_sample_rate_interpolation_functions)"]
    pub shader_sample_rate_interpolation_functions: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_sampled_image_array_dynamic_indexing)"]
    pub shader_sampled_image_array_dynamic_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_sampled_image_array_non_uniform_indexing)"]
    pub shader_sampled_image_array_non_uniform_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_shared_float16_atomic_add)"]
    pub shader_shared_float16_atomic_add: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_shared_float16_atomic_min_max)"]
    pub shader_shared_float16_atomic_min_max: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_shared_float16_atomics)"]
    pub shader_shared_float16_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_shared_float32_atomic_add)"]
    pub shader_shared_float32_atomic_add: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_shared_float32_atomic_min_max)"]
    pub shader_shared_float32_atomic_min_max: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_shared_float32_atomics)"]
    pub shader_shared_float32_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_shared_float64_atomic_add)"]
    pub shader_shared_float64_atomic_add: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-shader_shared_float64_atomic_min_max)"]
    pub shader_shared_float64_atomic_min_max: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-shader_shared_float64_atomics)"]
    pub shader_shared_float64_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_shared_int64_atomics)"]
    pub shader_shared_int64_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderSMBuiltinsFeaturesNV.html#features-shader_sm_builtins)"]
    pub shader_sm_builtins: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_storage_buffer_array_dynamic_indexing)"]
    pub shader_storage_buffer_array_dynamic_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_storage_buffer_array_non_uniform_indexing)"]
    pub shader_storage_buffer_array_non_uniform_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_storage_image_array_dynamic_indexing)"]
    pub shader_storage_image_array_dynamic_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_storage_image_array_non_uniform_indexing)"]
    pub shader_storage_image_array_non_uniform_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_storage_image_extended_formats)"]
    pub shader_storage_image_extended_formats: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_storage_image_multisample)"]
    pub shader_storage_image_multisample: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_storage_image_read_without_format)"]
    pub shader_storage_image_read_without_format: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_storage_image_write_without_format)"]
    pub shader_storage_image_write_without_format: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_storage_texel_buffer_array_dynamic_indexing)"]
    pub shader_storage_texel_buffer_array_dynamic_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_storage_texel_buffer_array_non_uniform_indexing)"]
    pub shader_storage_texel_buffer_array_non_uniform_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderClockFeaturesKHR.html#features-shader_subgroup_clock)"]
    pub shader_subgroup_clock: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_subgroup_extended_types)"]
    pub shader_subgroup_extended_types: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR.html#features-shader_subgroup_uniform_control_flow)"]
    pub shader_subgroup_uniform_control_flow: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR.html#features-shader_terminate_invocation)"]
    pub shader_terminate_invocation: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_tessellation_and_geometry_point_size)"]
    pub shader_tessellation_and_geometry_point_size: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-shader_uniform_buffer_array_dynamic_indexing)"]
    pub shader_uniform_buffer_array_dynamic_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_uniform_buffer_array_non_uniform_indexing)"]
    pub shader_uniform_buffer_array_non_uniform_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_uniform_texel_buffer_array_dynamic_indexing)"]
    pub shader_uniform_texel_buffer_array_dynamic_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-shader_uniform_texel_buffer_array_non_uniform_indexing)"]
    pub shader_uniform_texel_buffer_array_non_uniform_indexing: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR.html#features-shader_zero_initialize_workgroup_memory)"]
    pub shader_zero_initialize_workgroup_memory: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShadingRateImageFeaturesNV.html#features-shading_rate_coarse_sample_order)"]
    pub shading_rate_coarse_sample_order: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShadingRateImageFeaturesNV.html#features-shading_rate_image)\n- Conflicts with features: [`pipeline_fragment_shading_rate`](crate::device::Features::pipeline_fragment_shading_rate), [`primitive_fragment_shading_rate`](crate::device::Features::primitive_fragment_shading_rate), [`attachment_fragment_shading_rate`](crate::device::Features::attachment_fragment_shading_rate)"]
    pub shading_rate_image: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesEXT.html#features-smooth_lines)"]
    pub smooth_lines: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparse_binding)"]
    pub sparse_binding: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-sparse_image_float32_atomic_add)\n- Requires feature: [`shader_image_float32_atomic_add`](crate::device::Features::shader_image_float32_atomic_add)"]
    pub sparse_image_float32_atomic_add: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT.html#features-sparse_image_float32_atomic_min_max)"]
    pub sparse_image_float32_atomic_min_max: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html#features-sparse_image_float32_atomics)\n- Requires feature: [`shader_image_float32_atomics`](crate::device::Features::shader_image_float32_atomics)"]
    pub sparse_image_float32_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT.html#features-sparse_image_int64_atomics)\n- Requires feature: [`shader_image_int64_atomics`](crate::device::Features::shader_image_int64_atomics)"]
    pub sparse_image_int64_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparse_residency16_samples)"]
    pub sparse_residency16_samples: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparse_residency2_samples)"]
    pub sparse_residency2_samples: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparse_residency4_samples)"]
    pub sparse_residency4_samples: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparse_residency8_samples)"]
    pub sparse_residency8_samples: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparse_residency_aliased)"]
    pub sparse_residency_aliased: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparse_residency_buffer)"]
    pub sparse_residency_buffer: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparse_residency_image2_d)"]
    pub sparse_residency_image2_d: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-sparse_residency_image3_d)"]
    pub sparse_residency_image3_d: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesEXT.html#features-stippled_bresenham_lines)"]
    pub stippled_bresenham_lines: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesEXT.html#features-stippled_rectangular_lines)"]
    pub stippled_rectangular_lines: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceLineRasterizationFeaturesEXT.html#features-stippled_smooth_lines)"]
    pub stippled_smooth_lines: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-storage_buffer16_bit_access)"]
    pub storage_buffer16_bit_access: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-storage_buffer8_bit_access)"]
    pub storage_buffer8_bit_access: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-storage_input_output16)"]
    pub storage_input_output16: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-storage_push_constant16)"]
    pub storage_push_constant16: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-storage_push_constant8)"]
    pub storage_push_constant8: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-subgroup_broadcast_dynamic_id)"]
    pub subgroup_broadcast_dynamic_id: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSubgroupSizeControlFeaturesEXT.html#features-subgroup_size_control)"]
    pub subgroup_size_control: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSubpassShadingFeaturesHUAWEI.html#features-subpass_shading)"]
    pub subpass_shading: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV.html#features-supersample_fragment_shading_rates)"]
    pub supersample_fragment_shading_rates: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceSynchronization2FeaturesKHR.html#features-synchronization2)"]
    pub synchronization2: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceMeshShaderFeaturesNV.html#features-task_shader)"]
    pub task_shader: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-tessellation_isolines)"]
    pub tessellation_isolines: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-tessellation_point_mode)"]
    pub tessellation_point_mode: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-tessellation_shader)"]
    pub tessellation_shader: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT.html#features-texel_buffer_alignment)"]
    pub texel_buffer_alignment: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT.html#features-texture_compression_astc_hdr)"]
    pub texture_compression_astc_hdr: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-texture_compression_astc_ldr)"]
    pub texture_compression_astc_ldr: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-texture_compression_bc)"]
    pub texture_compression_bc: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-texture_compression_etc2)"]
    pub texture_compression_etc2: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-timeline_semaphore)"]
    pub timeline_semaphore: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceTransformFeedbackFeaturesEXT.html#features-transform_feedback)"]
    pub transform_feedback: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceProvokingVertexFeaturesEXT.html#features-transform_feedback_preserves_provoking_vertex)"]
    pub transform_feedback_preserves_provoking_vertex: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-triangle_fans)"]
    pub triangle_fans: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-uniform_and_storage_buffer16_bit_access)"]
    pub uniform_and_storage_buffer16_bit_access: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-uniform_and_storage_buffer8_bit_access)"]
    pub uniform_and_storage_buffer8_bit_access: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-uniform_buffer_standard_layout)"]
    pub uniform_buffer_standard_layout: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-variable_multisample_rate)"]
    pub variable_multisample_rate: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-variable_pointers)"]
    pub variable_pointers: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan11Features.html#features-variable_pointers_storage_buffer)"]
    pub variable_pointers_storage_buffer: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDevicePortabilitySubsetFeaturesKHR.html#features-vertex_attribute_access_beyond_stride)"]
    pub vertex_attribute_access_beyond_stride: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.html#features-vertex_attribute_instance_rate_divisor)"]
    pub vertex_attribute_instance_rate_divisor: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT.html#features-vertex_attribute_instance_rate_zero_divisor)"]
    pub vertex_attribute_instance_rate_zero_divisor: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT.html#features-vertex_input_dynamic_state)"]
    pub vertex_input_dynamic_state: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-vertex_pipeline_stores_and_atomics)"]
    pub vertex_pipeline_stores_and_atomics: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-vulkan_memory_model)"]
    pub vulkan_memory_model: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-vulkan_memory_model_availability_visibility_chains)"]
    pub vulkan_memory_model_availability_visibility_chains: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceVulkan12Features.html#features-vulkan_memory_model_device_scope)"]
    pub vulkan_memory_model_device_scope: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceFeatures.html#features-wide_lines)"]
    pub wide_lines: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html#features-workgroup_memory_explicit_layout)"]
    pub workgroup_memory_explicit_layout: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html#features-workgroup_memory_explicit_layout16_bit_access)"]
    pub workgroup_memory_explicit_layout16_bit_access: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html#features-workgroup_memory_explicit_layout8_bit_access)"]
    pub workgroup_memory_explicit_layout8_bit_access: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR.html#features-workgroup_memory_explicit_layout_scalar_block_layout)"]
    pub workgroup_memory_explicit_layout_scalar_block_layout: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT.html#features-ycbcr2plane444_formats)"]
    pub ycbcr2plane444_formats: bool,
    #[doc = "- [Vulkan documentation](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkPhysicalDeviceYcbcrImageArraysFeaturesEXT.html#features-ycbcr_image_arrays)"]
    pub ycbcr_image_arrays: bool,
}
impl Features {
    #[doc = r" Checks enabled features against the device version, device extensions and each other."]
    pub(super) fn check_requirements(
        &self,
        supported: &Features,
        api_version: Version,
        extensions: &DeviceExtensions,
    ) -> Result<(), FeatureRestrictionError> {
        if self.acceleration_structure {
            if !supported.acceleration_structure {
                return Err(FeatureRestrictionError {
                    feature: "acceleration_structure",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.acceleration_structure_capture_replay {
            if !supported.acceleration_structure_capture_replay {
                return Err(FeatureRestrictionError {
                    feature: "acceleration_structure_capture_replay",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.acceleration_structure_host_commands {
            if !supported.acceleration_structure_host_commands {
                return Err(FeatureRestrictionError {
                    feature: "acceleration_structure_host_commands",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.acceleration_structure_indirect_build {
            if !supported.acceleration_structure_indirect_build {
                return Err(FeatureRestrictionError {
                    feature: "acceleration_structure_indirect_build",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.advanced_blend_coherent_operations {
            if !supported.advanced_blend_coherent_operations {
                return Err(FeatureRestrictionError {
                    feature: "advanced_blend_coherent_operations",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.alpha_to_one {
            if !supported.alpha_to_one {
                return Err(FeatureRestrictionError {
                    feature: "alpha_to_one",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.attachment_fragment_shading_rate {
            if !supported.attachment_fragment_shading_rate {
                return Err(FeatureRestrictionError {
                    feature: "attachment_fragment_shading_rate",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
            if self.shading_rate_image {
                return Err(FeatureRestrictionError {
                    feature: "attachment_fragment_shading_rate",
                    restriction: FeatureRestriction::ConflictsFeature("shading_rate_image"),
                });
            }
            if self.fragment_density_map {
                return Err(FeatureRestrictionError {
                    feature: "attachment_fragment_shading_rate",
                    restriction: FeatureRestriction::ConflictsFeature("fragment_density_map"),
                });
            }
        } else {
        }
        if self.bresenham_lines {
            if !supported.bresenham_lines {
                return Err(FeatureRestrictionError {
                    feature: "bresenham_lines",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.buffer_device_address {
            if !supported.buffer_device_address {
                return Err(FeatureRestrictionError {
                    feature: "buffer_device_address",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.buffer_device_address_capture_replay {
            if !supported.buffer_device_address_capture_replay {
                return Err(FeatureRestrictionError {
                    feature: "buffer_device_address_capture_replay",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.buffer_device_address_multi_device {
            if !supported.buffer_device_address_multi_device {
                return Err(FeatureRestrictionError {
                    feature: "buffer_device_address_multi_device",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.color_write_enable {
            if !supported.color_write_enable {
                return Err(FeatureRestrictionError {
                    feature: "color_write_enable",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.compute_derivative_group_linear {
            if !supported.compute_derivative_group_linear {
                return Err(FeatureRestrictionError {
                    feature: "compute_derivative_group_linear",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.compute_derivative_group_quads {
            if !supported.compute_derivative_group_quads {
                return Err(FeatureRestrictionError {
                    feature: "compute_derivative_group_quads",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.compute_full_subgroups {
            if !supported.compute_full_subgroups {
                return Err(FeatureRestrictionError {
                    feature: "compute_full_subgroups",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.conditional_rendering {
            if !supported.conditional_rendering {
                return Err(FeatureRestrictionError {
                    feature: "conditional_rendering",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.constant_alpha_color_blend_factors {
            if !supported.constant_alpha_color_blend_factors {
                return Err(FeatureRestrictionError {
                    feature: "constant_alpha_color_blend_factors",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.cooperative_matrix {
            if !supported.cooperative_matrix {
                return Err(FeatureRestrictionError {
                    feature: "cooperative_matrix",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.cooperative_matrix_robust_buffer_access {
            if !supported.cooperative_matrix_robust_buffer_access {
                return Err(FeatureRestrictionError {
                    feature: "cooperative_matrix_robust_buffer_access",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.corner_sampled_image {
            if !supported.corner_sampled_image {
                return Err(FeatureRestrictionError {
                    feature: "corner_sampled_image",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.coverage_reduction_mode {
            if !supported.coverage_reduction_mode {
                return Err(FeatureRestrictionError {
                    feature: "coverage_reduction_mode",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.custom_border_color_without_format {
            if !supported.custom_border_color_without_format {
                return Err(FeatureRestrictionError {
                    feature: "custom_border_color_without_format",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.custom_border_colors {
            if !supported.custom_border_colors {
                return Err(FeatureRestrictionError {
                    feature: "custom_border_colors",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.decode_mode_shared_exponent {
            if !supported.decode_mode_shared_exponent {
                return Err(FeatureRestrictionError {
                    feature: "decode_mode_shared_exponent",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.dedicated_allocation_image_aliasing {
            if !supported.dedicated_allocation_image_aliasing {
                return Err(FeatureRestrictionError {
                    feature: "dedicated_allocation_image_aliasing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.depth_bias_clamp {
            if !supported.depth_bias_clamp {
                return Err(FeatureRestrictionError {
                    feature: "depth_bias_clamp",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.depth_bounds {
            if !supported.depth_bounds {
                return Err(FeatureRestrictionError {
                    feature: "depth_bounds",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.depth_clamp {
            if !supported.depth_clamp {
                return Err(FeatureRestrictionError {
                    feature: "depth_clamp",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.depth_clip_enable {
            if !supported.depth_clip_enable {
                return Err(FeatureRestrictionError {
                    feature: "depth_clip_enable",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_acceleration_structure_update_after_bind {
            if !supported.descriptor_binding_acceleration_structure_update_after_bind {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_acceleration_structure_update_after_bind",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_inline_uniform_block_update_after_bind {
            if !supported.descriptor_binding_inline_uniform_block_update_after_bind {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_inline_uniform_block_update_after_bind",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_partially_bound {
            if !supported.descriptor_binding_partially_bound {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_partially_bound",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_sampled_image_update_after_bind {
            if !supported.descriptor_binding_sampled_image_update_after_bind {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_sampled_image_update_after_bind",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_storage_buffer_update_after_bind {
            if !supported.descriptor_binding_storage_buffer_update_after_bind {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_storage_buffer_update_after_bind",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_storage_image_update_after_bind {
            if !supported.descriptor_binding_storage_image_update_after_bind {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_storage_image_update_after_bind",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_storage_texel_buffer_update_after_bind {
            if !supported.descriptor_binding_storage_texel_buffer_update_after_bind {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_storage_texel_buffer_update_after_bind",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_uniform_buffer_update_after_bind {
            if !supported.descriptor_binding_uniform_buffer_update_after_bind {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_uniform_buffer_update_after_bind",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_uniform_texel_buffer_update_after_bind {
            if !supported.descriptor_binding_uniform_texel_buffer_update_after_bind {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_uniform_texel_buffer_update_after_bind",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_update_unused_while_pending {
            if !supported.descriptor_binding_update_unused_while_pending {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_update_unused_while_pending",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_binding_variable_descriptor_count {
            if !supported.descriptor_binding_variable_descriptor_count {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_binding_variable_descriptor_count",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.descriptor_indexing {
            if !supported.descriptor_indexing {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
            if extensions.ext_descriptor_indexing && api_version >= Version::V1_2 {
                return Err(FeatureRestrictionError {
                    feature: "descriptor_indexing",
                    restriction: FeatureRestriction::RequiredByExtension("ext_descriptor_indexing"),
                });
            }
        }
        if self.device_coherent_memory {
            if !supported.device_coherent_memory {
                return Err(FeatureRestrictionError {
                    feature: "device_coherent_memory",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.device_generated_commands {
            if !supported.device_generated_commands {
                return Err(FeatureRestrictionError {
                    feature: "device_generated_commands",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.device_memory_report {
            if !supported.device_memory_report {
                return Err(FeatureRestrictionError {
                    feature: "device_memory_report",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.diagnostics_config {
            if !supported.diagnostics_config {
                return Err(FeatureRestrictionError {
                    feature: "diagnostics_config",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.draw_indirect_count {
            if !supported.draw_indirect_count {
                return Err(FeatureRestrictionError {
                    feature: "draw_indirect_count",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
            if extensions.khr_draw_indirect_count && api_version >= Version::V1_2 {
                return Err(FeatureRestrictionError {
                    feature: "draw_indirect_count",
                    restriction: FeatureRestriction::RequiredByExtension("khr_draw_indirect_count"),
                });
            }
        }
        if self.draw_indirect_first_instance {
            if !supported.draw_indirect_first_instance {
                return Err(FeatureRestrictionError {
                    feature: "draw_indirect_first_instance",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.dual_src_blend {
            if !supported.dual_src_blend {
                return Err(FeatureRestrictionError {
                    feature: "dual_src_blend",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.events {
            if !supported.events {
                return Err(FeatureRestrictionError {
                    feature: "events",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.exclusive_scissor {
            if !supported.exclusive_scissor {
                return Err(FeatureRestrictionError {
                    feature: "exclusive_scissor",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.extended_dynamic_state {
            if !supported.extended_dynamic_state {
                return Err(FeatureRestrictionError {
                    feature: "extended_dynamic_state",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.extended_dynamic_state2 {
            if !supported.extended_dynamic_state2 {
                return Err(FeatureRestrictionError {
                    feature: "extended_dynamic_state2",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.extended_dynamic_state2_logic_op {
            if !supported.extended_dynamic_state2_logic_op {
                return Err(FeatureRestrictionError {
                    feature: "extended_dynamic_state2_logic_op",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.extended_dynamic_state2_patch_control_points {
            if !supported.extended_dynamic_state2_patch_control_points {
                return Err(FeatureRestrictionError {
                    feature: "extended_dynamic_state2_patch_control_points",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.external_memory_rdma {
            if !supported.external_memory_rdma {
                return Err(FeatureRestrictionError {
                    feature: "external_memory_rdma",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fill_mode_non_solid {
            if !supported.fill_mode_non_solid {
                return Err(FeatureRestrictionError {
                    feature: "fill_mode_non_solid",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.format_a4b4g4r4 {
            if !supported.format_a4b4g4r4 {
                return Err(FeatureRestrictionError {
                    feature: "format_a4b4g4r4",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.format_a4r4g4b4 {
            if !supported.format_a4r4g4b4 {
                return Err(FeatureRestrictionError {
                    feature: "format_a4r4g4b4",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fragment_density_map {
            if !supported.fragment_density_map {
                return Err(FeatureRestrictionError {
                    feature: "fragment_density_map",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
            if self.pipeline_fragment_shading_rate {
                return Err(FeatureRestrictionError {
                    feature: "fragment_density_map",
                    restriction: FeatureRestriction::ConflictsFeature(
                        "pipeline_fragment_shading_rate",
                    ),
                });
            }
            if self.primitive_fragment_shading_rate {
                return Err(FeatureRestrictionError {
                    feature: "fragment_density_map",
                    restriction: FeatureRestriction::ConflictsFeature(
                        "primitive_fragment_shading_rate",
                    ),
                });
            }
            if self.attachment_fragment_shading_rate {
                return Err(FeatureRestrictionError {
                    feature: "fragment_density_map",
                    restriction: FeatureRestriction::ConflictsFeature(
                        "attachment_fragment_shading_rate",
                    ),
                });
            }
        } else {
        }
        if self.fragment_density_map_deferred {
            if !supported.fragment_density_map_deferred {
                return Err(FeatureRestrictionError {
                    feature: "fragment_density_map_deferred",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fragment_density_map_dynamic {
            if !supported.fragment_density_map_dynamic {
                return Err(FeatureRestrictionError {
                    feature: "fragment_density_map_dynamic",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fragment_density_map_non_subsampled_images {
            if !supported.fragment_density_map_non_subsampled_images {
                return Err(FeatureRestrictionError {
                    feature: "fragment_density_map_non_subsampled_images",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fragment_shader_barycentric {
            if !supported.fragment_shader_barycentric {
                return Err(FeatureRestrictionError {
                    feature: "fragment_shader_barycentric",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fragment_shader_pixel_interlock {
            if !supported.fragment_shader_pixel_interlock {
                return Err(FeatureRestrictionError {
                    feature: "fragment_shader_pixel_interlock",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fragment_shader_sample_interlock {
            if !supported.fragment_shader_sample_interlock {
                return Err(FeatureRestrictionError {
                    feature: "fragment_shader_sample_interlock",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fragment_shader_shading_rate_interlock {
            if !supported.fragment_shader_shading_rate_interlock {
                return Err(FeatureRestrictionError {
                    feature: "fragment_shader_shading_rate_interlock",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fragment_shading_rate_enums {
            if !supported.fragment_shading_rate_enums {
                return Err(FeatureRestrictionError {
                    feature: "fragment_shading_rate_enums",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.fragment_stores_and_atomics {
            if !supported.fragment_stores_and_atomics {
                return Err(FeatureRestrictionError {
                    feature: "fragment_stores_and_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.full_draw_index_uint32 {
            if !supported.full_draw_index_uint32 {
                return Err(FeatureRestrictionError {
                    feature: "full_draw_index_uint32",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.geometry_shader {
            if !supported.geometry_shader {
                return Err(FeatureRestrictionError {
                    feature: "geometry_shader",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.geometry_streams {
            if !supported.geometry_streams {
                return Err(FeatureRestrictionError {
                    feature: "geometry_streams",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.global_priority_query {
            if !supported.global_priority_query {
                return Err(FeatureRestrictionError {
                    feature: "global_priority_query",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.host_query_reset {
            if !supported.host_query_reset {
                return Err(FeatureRestrictionError {
                    feature: "host_query_reset",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.image_cube_array {
            if !supported.image_cube_array {
                return Err(FeatureRestrictionError {
                    feature: "image_cube_array",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.image_footprint {
            if !supported.image_footprint {
                return Err(FeatureRestrictionError {
                    feature: "image_footprint",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.image_view2_d_on3_d_image {
            if !supported.image_view2_d_on3_d_image {
                return Err(FeatureRestrictionError {
                    feature: "image_view2_d_on3_d_image",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.image_view_format_reinterpretation {
            if !supported.image_view_format_reinterpretation {
                return Err(FeatureRestrictionError {
                    feature: "image_view_format_reinterpretation",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.image_view_format_swizzle {
            if !supported.image_view_format_swizzle {
                return Err(FeatureRestrictionError {
                    feature: "image_view_format_swizzle",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.imageless_framebuffer {
            if !supported.imageless_framebuffer {
                return Err(FeatureRestrictionError {
                    feature: "imageless_framebuffer",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.independent_blend {
            if !supported.independent_blend {
                return Err(FeatureRestrictionError {
                    feature: "independent_blend",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.index_type_uint8 {
            if !supported.index_type_uint8 {
                return Err(FeatureRestrictionError {
                    feature: "index_type_uint8",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.inherited_conditional_rendering {
            if !supported.inherited_conditional_rendering {
                return Err(FeatureRestrictionError {
                    feature: "inherited_conditional_rendering",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.inherited_queries {
            if !supported.inherited_queries {
                return Err(FeatureRestrictionError {
                    feature: "inherited_queries",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.inherited_viewport_scissor2_d {
            if !supported.inherited_viewport_scissor2_d {
                return Err(FeatureRestrictionError {
                    feature: "inherited_viewport_scissor2_d",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.inline_uniform_block {
            if !supported.inline_uniform_block {
                return Err(FeatureRestrictionError {
                    feature: "inline_uniform_block",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.invocation_mask {
            if !supported.invocation_mask {
                return Err(FeatureRestrictionError {
                    feature: "invocation_mask",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.large_points {
            if !supported.large_points {
                return Err(FeatureRestrictionError {
                    feature: "large_points",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.logic_op {
            if !supported.logic_op {
                return Err(FeatureRestrictionError {
                    feature: "logic_op",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.memory_priority {
            if !supported.memory_priority {
                return Err(FeatureRestrictionError {
                    feature: "memory_priority",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.mesh_shader {
            if !supported.mesh_shader {
                return Err(FeatureRestrictionError {
                    feature: "mesh_shader",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.multi_draw {
            if !supported.multi_draw {
                return Err(FeatureRestrictionError {
                    feature: "multi_draw",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.multi_draw_indirect {
            if !supported.multi_draw_indirect {
                return Err(FeatureRestrictionError {
                    feature: "multi_draw_indirect",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.multi_viewport {
            if !supported.multi_viewport {
                return Err(FeatureRestrictionError {
                    feature: "multi_viewport",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.multisample_array_image {
            if !supported.multisample_array_image {
                return Err(FeatureRestrictionError {
                    feature: "multisample_array_image",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.multiview {
            if !supported.multiview {
                return Err(FeatureRestrictionError {
                    feature: "multiview",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.multiview_geometry_shader {
            if !supported.multiview_geometry_shader {
                return Err(FeatureRestrictionError {
                    feature: "multiview_geometry_shader",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.multiview_tessellation_shader {
            if !supported.multiview_tessellation_shader {
                return Err(FeatureRestrictionError {
                    feature: "multiview_tessellation_shader",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.mutable_comparison_samplers {
            if !supported.mutable_comparison_samplers {
                return Err(FeatureRestrictionError {
                    feature: "mutable_comparison_samplers",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.mutable_descriptor_type {
            if !supported.mutable_descriptor_type {
                return Err(FeatureRestrictionError {
                    feature: "mutable_descriptor_type",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.no_invocation_fragment_shading_rates {
            if !supported.no_invocation_fragment_shading_rates {
                return Err(FeatureRestrictionError {
                    feature: "no_invocation_fragment_shading_rates",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.null_descriptor {
            if !supported.null_descriptor {
                return Err(FeatureRestrictionError {
                    feature: "null_descriptor",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.occlusion_query_precise {
            if !supported.occlusion_query_precise {
                return Err(FeatureRestrictionError {
                    feature: "occlusion_query_precise",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.pageable_device_local_memory {
            if !supported.pageable_device_local_memory {
                return Err(FeatureRestrictionError {
                    feature: "pageable_device_local_memory",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.performance_counter_multiple_query_pools {
            if !supported.performance_counter_multiple_query_pools {
                return Err(FeatureRestrictionError {
                    feature: "performance_counter_multiple_query_pools",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.performance_counter_query_pools {
            if !supported.performance_counter_query_pools {
                return Err(FeatureRestrictionError {
                    feature: "performance_counter_query_pools",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.pipeline_creation_cache_control {
            if !supported.pipeline_creation_cache_control {
                return Err(FeatureRestrictionError {
                    feature: "pipeline_creation_cache_control",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.pipeline_executable_info {
            if !supported.pipeline_executable_info {
                return Err(FeatureRestrictionError {
                    feature: "pipeline_executable_info",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.pipeline_fragment_shading_rate {
            if !supported.pipeline_fragment_shading_rate {
                return Err(FeatureRestrictionError {
                    feature: "pipeline_fragment_shading_rate",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
            if self.shading_rate_image {
                return Err(FeatureRestrictionError {
                    feature: "pipeline_fragment_shading_rate",
                    restriction: FeatureRestriction::ConflictsFeature("shading_rate_image"),
                });
            }
            if self.fragment_density_map {
                return Err(FeatureRestrictionError {
                    feature: "pipeline_fragment_shading_rate",
                    restriction: FeatureRestriction::ConflictsFeature("fragment_density_map"),
                });
            }
        } else {
        }
        if self.pipeline_statistics_query {
            if !supported.pipeline_statistics_query {
                return Err(FeatureRestrictionError {
                    feature: "pipeline_statistics_query",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.point_polygons {
            if !supported.point_polygons {
                return Err(FeatureRestrictionError {
                    feature: "point_polygons",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.present_id {
            if !supported.present_id {
                return Err(FeatureRestrictionError {
                    feature: "present_id",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.present_wait {
            if !supported.present_wait {
                return Err(FeatureRestrictionError {
                    feature: "present_wait",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.primitive_fragment_shading_rate {
            if !supported.primitive_fragment_shading_rate {
                return Err(FeatureRestrictionError {
                    feature: "primitive_fragment_shading_rate",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
            if self.shading_rate_image {
                return Err(FeatureRestrictionError {
                    feature: "primitive_fragment_shading_rate",
                    restriction: FeatureRestriction::ConflictsFeature("shading_rate_image"),
                });
            }
            if self.fragment_density_map {
                return Err(FeatureRestrictionError {
                    feature: "primitive_fragment_shading_rate",
                    restriction: FeatureRestriction::ConflictsFeature("fragment_density_map"),
                });
            }
        } else {
        }
        if self.primitive_topology_list_restart {
            if !supported.primitive_topology_list_restart {
                return Err(FeatureRestrictionError {
                    feature: "primitive_topology_list_restart",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.primitive_topology_patch_list_restart {
            if !supported.primitive_topology_patch_list_restart {
                return Err(FeatureRestrictionError {
                    feature: "primitive_topology_patch_list_restart",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.private_data {
            if !supported.private_data {
                return Err(FeatureRestrictionError {
                    feature: "private_data",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.protected_memory {
            if !supported.protected_memory {
                return Err(FeatureRestrictionError {
                    feature: "protected_memory",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.provoking_vertex_last {
            if !supported.provoking_vertex_last {
                return Err(FeatureRestrictionError {
                    feature: "provoking_vertex_last",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ray_query {
            if !supported.ray_query {
                return Err(FeatureRestrictionError {
                    feature: "ray_query",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ray_tracing_motion_blur {
            if !supported.ray_tracing_motion_blur {
                return Err(FeatureRestrictionError {
                    feature: "ray_tracing_motion_blur",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ray_tracing_motion_blur_pipeline_trace_rays_indirect {
            if !supported.ray_tracing_motion_blur_pipeline_trace_rays_indirect {
                return Err(FeatureRestrictionError {
                    feature: "ray_tracing_motion_blur_pipeline_trace_rays_indirect",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ray_tracing_pipeline {
            if !supported.ray_tracing_pipeline {
                return Err(FeatureRestrictionError {
                    feature: "ray_tracing_pipeline",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ray_tracing_pipeline_shader_group_handle_capture_replay {
            if !supported.ray_tracing_pipeline_shader_group_handle_capture_replay {
                return Err(FeatureRestrictionError {
                    feature: "ray_tracing_pipeline_shader_group_handle_capture_replay",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed {
            if !supported.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed {
                return Err(FeatureRestrictionError {
                    feature: "ray_tracing_pipeline_shader_group_handle_capture_replay_mixed",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ray_tracing_pipeline_trace_rays_indirect {
            if !supported.ray_tracing_pipeline_trace_rays_indirect {
                return Err(FeatureRestrictionError {
                    feature: "ray_tracing_pipeline_trace_rays_indirect",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ray_traversal_primitive_culling {
            if !supported.ray_traversal_primitive_culling {
                return Err(FeatureRestrictionError {
                    feature: "ray_traversal_primitive_culling",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.rectangular_lines {
            if !supported.rectangular_lines {
                return Err(FeatureRestrictionError {
                    feature: "rectangular_lines",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.representative_fragment_test {
            if !supported.representative_fragment_test {
                return Err(FeatureRestrictionError {
                    feature: "representative_fragment_test",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.robust_buffer_access {
            if !supported.robust_buffer_access {
                return Err(FeatureRestrictionError {
                    feature: "robust_buffer_access",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.robust_buffer_access2 {
            if !supported.robust_buffer_access2 {
                return Err(FeatureRestrictionError {
                    feature: "robust_buffer_access2",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.robust_image_access {
            if !supported.robust_image_access {
                return Err(FeatureRestrictionError {
                    feature: "robust_image_access",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.robust_image_access2 {
            if !supported.robust_image_access2 {
                return Err(FeatureRestrictionError {
                    feature: "robust_image_access2",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.runtime_descriptor_array {
            if !supported.runtime_descriptor_array {
                return Err(FeatureRestrictionError {
                    feature: "runtime_descriptor_array",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sample_rate_shading {
            if !supported.sample_rate_shading {
                return Err(FeatureRestrictionError {
                    feature: "sample_rate_shading",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sampler_anisotropy {
            if !supported.sampler_anisotropy {
                return Err(FeatureRestrictionError {
                    feature: "sampler_anisotropy",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sampler_filter_minmax {
            if !supported.sampler_filter_minmax {
                return Err(FeatureRestrictionError {
                    feature: "sampler_filter_minmax",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
            if extensions.ext_sampler_filter_minmax && api_version >= Version::V1_2 {
                return Err(FeatureRestrictionError {
                    feature: "sampler_filter_minmax",
                    restriction: FeatureRestriction::RequiredByExtension(
                        "ext_sampler_filter_minmax",
                    ),
                });
            }
        }
        if self.sampler_mip_lod_bias {
            if !supported.sampler_mip_lod_bias {
                return Err(FeatureRestrictionError {
                    feature: "sampler_mip_lod_bias",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sampler_mirror_clamp_to_edge {
            if !supported.sampler_mirror_clamp_to_edge {
                return Err(FeatureRestrictionError {
                    feature: "sampler_mirror_clamp_to_edge",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
            if extensions.khr_sampler_mirror_clamp_to_edge && api_version >= Version::V1_2 {
                return Err(FeatureRestrictionError {
                    feature: "sampler_mirror_clamp_to_edge",
                    restriction: FeatureRestriction::RequiredByExtension(
                        "khr_sampler_mirror_clamp_to_edge",
                    ),
                });
            }
        }
        if self.sampler_ycbcr_conversion {
            if !supported.sampler_ycbcr_conversion {
                return Err(FeatureRestrictionError {
                    feature: "sampler_ycbcr_conversion",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.scalar_block_layout {
            if !supported.scalar_block_layout {
                return Err(FeatureRestrictionError {
                    feature: "scalar_block_layout",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.separate_depth_stencil_layouts {
            if !supported.separate_depth_stencil_layouts {
                return Err(FeatureRestrictionError {
                    feature: "separate_depth_stencil_layouts",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.separate_stencil_mask_ref {
            if !supported.separate_stencil_mask_ref {
                return Err(FeatureRestrictionError {
                    feature: "separate_stencil_mask_ref",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_float16_atomic_add {
            if !supported.shader_buffer_float16_atomic_add {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_float16_atomic_add",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_float16_atomic_min_max {
            if !supported.shader_buffer_float16_atomic_min_max {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_float16_atomic_min_max",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_float16_atomics {
            if !supported.shader_buffer_float16_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_float16_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_float32_atomic_add {
            if !supported.shader_buffer_float32_atomic_add {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_float32_atomic_add",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_float32_atomic_min_max {
            if !supported.shader_buffer_float32_atomic_min_max {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_float32_atomic_min_max",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_float32_atomics {
            if !supported.shader_buffer_float32_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_float32_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_float64_atomic_add {
            if !supported.shader_buffer_float64_atomic_add {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_float64_atomic_add",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_float64_atomic_min_max {
            if !supported.shader_buffer_float64_atomic_min_max {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_float64_atomic_min_max",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_float64_atomics {
            if !supported.shader_buffer_float64_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_float64_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_buffer_int64_atomics {
            if !supported.shader_buffer_int64_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_buffer_int64_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_clip_distance {
            if !supported.shader_clip_distance {
                return Err(FeatureRestrictionError {
                    feature: "shader_clip_distance",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_cull_distance {
            if !supported.shader_cull_distance {
                return Err(FeatureRestrictionError {
                    feature: "shader_cull_distance",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_demote_to_helper_invocation {
            if !supported.shader_demote_to_helper_invocation {
                return Err(FeatureRestrictionError {
                    feature: "shader_demote_to_helper_invocation",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_device_clock {
            if !supported.shader_device_clock {
                return Err(FeatureRestrictionError {
                    feature: "shader_device_clock",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_draw_parameters {
            if !supported.shader_draw_parameters {
                return Err(FeatureRestrictionError {
                    feature: "shader_draw_parameters",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
            if extensions.khr_shader_draw_parameters && api_version >= Version::V1_2 {
                return Err(FeatureRestrictionError {
                    feature: "shader_draw_parameters",
                    restriction: FeatureRestriction::RequiredByExtension(
                        "khr_shader_draw_parameters",
                    ),
                });
            }
        }
        if self.shader_float16 {
            if !supported.shader_float16 {
                return Err(FeatureRestrictionError {
                    feature: "shader_float16",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_float64 {
            if !supported.shader_float64 {
                return Err(FeatureRestrictionError {
                    feature: "shader_float64",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_image_float32_atomic_add {
            if !supported.shader_image_float32_atomic_add {
                return Err(FeatureRestrictionError {
                    feature: "shader_image_float32_atomic_add",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_image_float32_atomic_min_max {
            if !supported.shader_image_float32_atomic_min_max {
                return Err(FeatureRestrictionError {
                    feature: "shader_image_float32_atomic_min_max",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_image_float32_atomics {
            if !supported.shader_image_float32_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_image_float32_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_image_gather_extended {
            if !supported.shader_image_gather_extended {
                return Err(FeatureRestrictionError {
                    feature: "shader_image_gather_extended",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_image_int64_atomics {
            if !supported.shader_image_int64_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_image_int64_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_input_attachment_array_dynamic_indexing {
            if !supported.shader_input_attachment_array_dynamic_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_input_attachment_array_dynamic_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_input_attachment_array_non_uniform_indexing {
            if !supported.shader_input_attachment_array_non_uniform_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_input_attachment_array_non_uniform_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_int16 {
            if !supported.shader_int16 {
                return Err(FeatureRestrictionError {
                    feature: "shader_int16",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_int64 {
            if !supported.shader_int64 {
                return Err(FeatureRestrictionError {
                    feature: "shader_int64",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_int8 {
            if !supported.shader_int8 {
                return Err(FeatureRestrictionError {
                    feature: "shader_int8",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_integer_dot_product {
            if !supported.shader_integer_dot_product {
                return Err(FeatureRestrictionError {
                    feature: "shader_integer_dot_product",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_integer_functions2 {
            if !supported.shader_integer_functions2 {
                return Err(FeatureRestrictionError {
                    feature: "shader_integer_functions2",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_output_layer {
            if !supported.shader_output_layer {
                return Err(FeatureRestrictionError {
                    feature: "shader_output_layer",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
            if extensions.ext_shader_viewport_index_layer && api_version >= Version::V1_2 {
                return Err(FeatureRestrictionError {
                    feature: "shader_output_layer",
                    restriction: FeatureRestriction::RequiredByExtension(
                        "ext_shader_viewport_index_layer",
                    ),
                });
            }
        }
        if self.shader_output_viewport_index {
            if !supported.shader_output_viewport_index {
                return Err(FeatureRestrictionError {
                    feature: "shader_output_viewport_index",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
            if extensions.ext_shader_viewport_index_layer && api_version >= Version::V1_2 {
                return Err(FeatureRestrictionError {
                    feature: "shader_output_viewport_index",
                    restriction: FeatureRestriction::RequiredByExtension(
                        "ext_shader_viewport_index_layer",
                    ),
                });
            }
        }
        if self.shader_resource_min_lod {
            if !supported.shader_resource_min_lod {
                return Err(FeatureRestrictionError {
                    feature: "shader_resource_min_lod",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_resource_residency {
            if !supported.shader_resource_residency {
                return Err(FeatureRestrictionError {
                    feature: "shader_resource_residency",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_sample_rate_interpolation_functions {
            if !supported.shader_sample_rate_interpolation_functions {
                return Err(FeatureRestrictionError {
                    feature: "shader_sample_rate_interpolation_functions",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_sampled_image_array_dynamic_indexing {
            if !supported.shader_sampled_image_array_dynamic_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_sampled_image_array_dynamic_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_sampled_image_array_non_uniform_indexing {
            if !supported.shader_sampled_image_array_non_uniform_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_sampled_image_array_non_uniform_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_float16_atomic_add {
            if !supported.shader_shared_float16_atomic_add {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_float16_atomic_add",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_float16_atomic_min_max {
            if !supported.shader_shared_float16_atomic_min_max {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_float16_atomic_min_max",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_float16_atomics {
            if !supported.shader_shared_float16_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_float16_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_float32_atomic_add {
            if !supported.shader_shared_float32_atomic_add {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_float32_atomic_add",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_float32_atomic_min_max {
            if !supported.shader_shared_float32_atomic_min_max {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_float32_atomic_min_max",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_float32_atomics {
            if !supported.shader_shared_float32_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_float32_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_float64_atomic_add {
            if !supported.shader_shared_float64_atomic_add {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_float64_atomic_add",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_float64_atomic_min_max {
            if !supported.shader_shared_float64_atomic_min_max {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_float64_atomic_min_max",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_float64_atomics {
            if !supported.shader_shared_float64_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_float64_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_shared_int64_atomics {
            if !supported.shader_shared_int64_atomics {
                return Err(FeatureRestrictionError {
                    feature: "shader_shared_int64_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_sm_builtins {
            if !supported.shader_sm_builtins {
                return Err(FeatureRestrictionError {
                    feature: "shader_sm_builtins",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_buffer_array_dynamic_indexing {
            if !supported.shader_storage_buffer_array_dynamic_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_buffer_array_dynamic_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_buffer_array_non_uniform_indexing {
            if !supported.shader_storage_buffer_array_non_uniform_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_buffer_array_non_uniform_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_image_array_dynamic_indexing {
            if !supported.shader_storage_image_array_dynamic_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_image_array_dynamic_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_image_array_non_uniform_indexing {
            if !supported.shader_storage_image_array_non_uniform_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_image_array_non_uniform_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_image_extended_formats {
            if !supported.shader_storage_image_extended_formats {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_image_extended_formats",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_image_multisample {
            if !supported.shader_storage_image_multisample {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_image_multisample",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_image_read_without_format {
            if !supported.shader_storage_image_read_without_format {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_image_read_without_format",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_image_write_without_format {
            if !supported.shader_storage_image_write_without_format {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_image_write_without_format",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_texel_buffer_array_dynamic_indexing {
            if !supported.shader_storage_texel_buffer_array_dynamic_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_texel_buffer_array_dynamic_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_storage_texel_buffer_array_non_uniform_indexing {
            if !supported.shader_storage_texel_buffer_array_non_uniform_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_storage_texel_buffer_array_non_uniform_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_subgroup_clock {
            if !supported.shader_subgroup_clock {
                return Err(FeatureRestrictionError {
                    feature: "shader_subgroup_clock",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_subgroup_extended_types {
            if !supported.shader_subgroup_extended_types {
                return Err(FeatureRestrictionError {
                    feature: "shader_subgroup_extended_types",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_subgroup_uniform_control_flow {
            if !supported.shader_subgroup_uniform_control_flow {
                return Err(FeatureRestrictionError {
                    feature: "shader_subgroup_uniform_control_flow",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_terminate_invocation {
            if !supported.shader_terminate_invocation {
                return Err(FeatureRestrictionError {
                    feature: "shader_terminate_invocation",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_tessellation_and_geometry_point_size {
            if !supported.shader_tessellation_and_geometry_point_size {
                return Err(FeatureRestrictionError {
                    feature: "shader_tessellation_and_geometry_point_size",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_uniform_buffer_array_dynamic_indexing {
            if !supported.shader_uniform_buffer_array_dynamic_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_uniform_buffer_array_dynamic_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_uniform_buffer_array_non_uniform_indexing {
            if !supported.shader_uniform_buffer_array_non_uniform_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_uniform_buffer_array_non_uniform_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_uniform_texel_buffer_array_dynamic_indexing {
            if !supported.shader_uniform_texel_buffer_array_dynamic_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_uniform_texel_buffer_array_dynamic_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_uniform_texel_buffer_array_non_uniform_indexing {
            if !supported.shader_uniform_texel_buffer_array_non_uniform_indexing {
                return Err(FeatureRestrictionError {
                    feature: "shader_uniform_texel_buffer_array_non_uniform_indexing",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shader_zero_initialize_workgroup_memory {
            if !supported.shader_zero_initialize_workgroup_memory {
                return Err(FeatureRestrictionError {
                    feature: "shader_zero_initialize_workgroup_memory",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shading_rate_coarse_sample_order {
            if !supported.shading_rate_coarse_sample_order {
                return Err(FeatureRestrictionError {
                    feature: "shading_rate_coarse_sample_order",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.shading_rate_image {
            if !supported.shading_rate_image {
                return Err(FeatureRestrictionError {
                    feature: "shading_rate_image",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
            if self.pipeline_fragment_shading_rate {
                return Err(FeatureRestrictionError {
                    feature: "shading_rate_image",
                    restriction: FeatureRestriction::ConflictsFeature(
                        "pipeline_fragment_shading_rate",
                    ),
                });
            }
            if self.primitive_fragment_shading_rate {
                return Err(FeatureRestrictionError {
                    feature: "shading_rate_image",
                    restriction: FeatureRestriction::ConflictsFeature(
                        "primitive_fragment_shading_rate",
                    ),
                });
            }
            if self.attachment_fragment_shading_rate {
                return Err(FeatureRestrictionError {
                    feature: "shading_rate_image",
                    restriction: FeatureRestriction::ConflictsFeature(
                        "attachment_fragment_shading_rate",
                    ),
                });
            }
        } else {
        }
        if self.smooth_lines {
            if !supported.smooth_lines {
                return Err(FeatureRestrictionError {
                    feature: "smooth_lines",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_binding {
            if !supported.sparse_binding {
                return Err(FeatureRestrictionError {
                    feature: "sparse_binding",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_image_float32_atomic_add {
            if !supported.sparse_image_float32_atomic_add {
                return Err(FeatureRestrictionError {
                    feature: "sparse_image_float32_atomic_add",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
            if !self.shader_image_float32_atomic_add {
                return Err(FeatureRestrictionError {
                    feature: "sparse_image_float32_atomic_add",
                    restriction: FeatureRestriction::RequiresFeature(
                        "shader_image_float32_atomic_add",
                    ),
                });
            }
        } else {
        }
        if self.sparse_image_float32_atomic_min_max {
            if !supported.sparse_image_float32_atomic_min_max {
                return Err(FeatureRestrictionError {
                    feature: "sparse_image_float32_atomic_min_max",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_image_float32_atomics {
            if !supported.sparse_image_float32_atomics {
                return Err(FeatureRestrictionError {
                    feature: "sparse_image_float32_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
            if !self.shader_image_float32_atomics {
                return Err(FeatureRestrictionError {
                    feature: "sparse_image_float32_atomics",
                    restriction: FeatureRestriction::RequiresFeature(
                        "shader_image_float32_atomics",
                    ),
                });
            }
        } else {
        }
        if self.sparse_image_int64_atomics {
            if !supported.sparse_image_int64_atomics {
                return Err(FeatureRestrictionError {
                    feature: "sparse_image_int64_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
            if !self.shader_image_int64_atomics {
                return Err(FeatureRestrictionError {
                    feature: "sparse_image_int64_atomics",
                    restriction: FeatureRestriction::RequiresFeature("shader_image_int64_atomics"),
                });
            }
        } else {
        }
        if self.sparse_residency16_samples {
            if !supported.sparse_residency16_samples {
                return Err(FeatureRestrictionError {
                    feature: "sparse_residency16_samples",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_residency2_samples {
            if !supported.sparse_residency2_samples {
                return Err(FeatureRestrictionError {
                    feature: "sparse_residency2_samples",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_residency4_samples {
            if !supported.sparse_residency4_samples {
                return Err(FeatureRestrictionError {
                    feature: "sparse_residency4_samples",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_residency8_samples {
            if !supported.sparse_residency8_samples {
                return Err(FeatureRestrictionError {
                    feature: "sparse_residency8_samples",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_residency_aliased {
            if !supported.sparse_residency_aliased {
                return Err(FeatureRestrictionError {
                    feature: "sparse_residency_aliased",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_residency_buffer {
            if !supported.sparse_residency_buffer {
                return Err(FeatureRestrictionError {
                    feature: "sparse_residency_buffer",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_residency_image2_d {
            if !supported.sparse_residency_image2_d {
                return Err(FeatureRestrictionError {
                    feature: "sparse_residency_image2_d",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.sparse_residency_image3_d {
            if !supported.sparse_residency_image3_d {
                return Err(FeatureRestrictionError {
                    feature: "sparse_residency_image3_d",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.stippled_bresenham_lines {
            if !supported.stippled_bresenham_lines {
                return Err(FeatureRestrictionError {
                    feature: "stippled_bresenham_lines",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.stippled_rectangular_lines {
            if !supported.stippled_rectangular_lines {
                return Err(FeatureRestrictionError {
                    feature: "stippled_rectangular_lines",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.stippled_smooth_lines {
            if !supported.stippled_smooth_lines {
                return Err(FeatureRestrictionError {
                    feature: "stippled_smooth_lines",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.storage_buffer16_bit_access {
            if !supported.storage_buffer16_bit_access {
                return Err(FeatureRestrictionError {
                    feature: "storage_buffer16_bit_access",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.storage_buffer8_bit_access {
            if !supported.storage_buffer8_bit_access {
                return Err(FeatureRestrictionError {
                    feature: "storage_buffer8_bit_access",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.storage_input_output16 {
            if !supported.storage_input_output16 {
                return Err(FeatureRestrictionError {
                    feature: "storage_input_output16",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.storage_push_constant16 {
            if !supported.storage_push_constant16 {
                return Err(FeatureRestrictionError {
                    feature: "storage_push_constant16",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.storage_push_constant8 {
            if !supported.storage_push_constant8 {
                return Err(FeatureRestrictionError {
                    feature: "storage_push_constant8",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.subgroup_broadcast_dynamic_id {
            if !supported.subgroup_broadcast_dynamic_id {
                return Err(FeatureRestrictionError {
                    feature: "subgroup_broadcast_dynamic_id",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.subgroup_size_control {
            if !supported.subgroup_size_control {
                return Err(FeatureRestrictionError {
                    feature: "subgroup_size_control",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.subpass_shading {
            if !supported.subpass_shading {
                return Err(FeatureRestrictionError {
                    feature: "subpass_shading",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.supersample_fragment_shading_rates {
            if !supported.supersample_fragment_shading_rates {
                return Err(FeatureRestrictionError {
                    feature: "supersample_fragment_shading_rates",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.synchronization2 {
            if !supported.synchronization2 {
                return Err(FeatureRestrictionError {
                    feature: "synchronization2",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.task_shader {
            if !supported.task_shader {
                return Err(FeatureRestrictionError {
                    feature: "task_shader",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.tessellation_isolines {
            if !supported.tessellation_isolines {
                return Err(FeatureRestrictionError {
                    feature: "tessellation_isolines",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.tessellation_point_mode {
            if !supported.tessellation_point_mode {
                return Err(FeatureRestrictionError {
                    feature: "tessellation_point_mode",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.tessellation_shader {
            if !supported.tessellation_shader {
                return Err(FeatureRestrictionError {
                    feature: "tessellation_shader",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.texel_buffer_alignment {
            if !supported.texel_buffer_alignment {
                return Err(FeatureRestrictionError {
                    feature: "texel_buffer_alignment",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.texture_compression_astc_hdr {
            if !supported.texture_compression_astc_hdr {
                return Err(FeatureRestrictionError {
                    feature: "texture_compression_astc_hdr",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.texture_compression_astc_ldr {
            if !supported.texture_compression_astc_ldr {
                return Err(FeatureRestrictionError {
                    feature: "texture_compression_astc_ldr",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.texture_compression_bc {
            if !supported.texture_compression_bc {
                return Err(FeatureRestrictionError {
                    feature: "texture_compression_bc",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.texture_compression_etc2 {
            if !supported.texture_compression_etc2 {
                return Err(FeatureRestrictionError {
                    feature: "texture_compression_etc2",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.timeline_semaphore {
            if !supported.timeline_semaphore {
                return Err(FeatureRestrictionError {
                    feature: "timeline_semaphore",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.transform_feedback {
            if !supported.transform_feedback {
                return Err(FeatureRestrictionError {
                    feature: "transform_feedback",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.transform_feedback_preserves_provoking_vertex {
            if !supported.transform_feedback_preserves_provoking_vertex {
                return Err(FeatureRestrictionError {
                    feature: "transform_feedback_preserves_provoking_vertex",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.triangle_fans {
            if !supported.triangle_fans {
                return Err(FeatureRestrictionError {
                    feature: "triangle_fans",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.uniform_and_storage_buffer16_bit_access {
            if !supported.uniform_and_storage_buffer16_bit_access {
                return Err(FeatureRestrictionError {
                    feature: "uniform_and_storage_buffer16_bit_access",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.uniform_and_storage_buffer8_bit_access {
            if !supported.uniform_and_storage_buffer8_bit_access {
                return Err(FeatureRestrictionError {
                    feature: "uniform_and_storage_buffer8_bit_access",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.uniform_buffer_standard_layout {
            if !supported.uniform_buffer_standard_layout {
                return Err(FeatureRestrictionError {
                    feature: "uniform_buffer_standard_layout",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.variable_multisample_rate {
            if !supported.variable_multisample_rate {
                return Err(FeatureRestrictionError {
                    feature: "variable_multisample_rate",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.variable_pointers {
            if !supported.variable_pointers {
                return Err(FeatureRestrictionError {
                    feature: "variable_pointers",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.variable_pointers_storage_buffer {
            if !supported.variable_pointers_storage_buffer {
                return Err(FeatureRestrictionError {
                    feature: "variable_pointers_storage_buffer",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.vertex_attribute_access_beyond_stride {
            if !supported.vertex_attribute_access_beyond_stride {
                return Err(FeatureRestrictionError {
                    feature: "vertex_attribute_access_beyond_stride",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.vertex_attribute_instance_rate_divisor {
            if !supported.vertex_attribute_instance_rate_divisor {
                return Err(FeatureRestrictionError {
                    feature: "vertex_attribute_instance_rate_divisor",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.vertex_attribute_instance_rate_zero_divisor {
            if !supported.vertex_attribute_instance_rate_zero_divisor {
                return Err(FeatureRestrictionError {
                    feature: "vertex_attribute_instance_rate_zero_divisor",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.vertex_input_dynamic_state {
            if !supported.vertex_input_dynamic_state {
                return Err(FeatureRestrictionError {
                    feature: "vertex_input_dynamic_state",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.vertex_pipeline_stores_and_atomics {
            if !supported.vertex_pipeline_stores_and_atomics {
                return Err(FeatureRestrictionError {
                    feature: "vertex_pipeline_stores_and_atomics",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.vulkan_memory_model {
            if !supported.vulkan_memory_model {
                return Err(FeatureRestrictionError {
                    feature: "vulkan_memory_model",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.vulkan_memory_model_availability_visibility_chains {
            if !supported.vulkan_memory_model_availability_visibility_chains {
                return Err(FeatureRestrictionError {
                    feature: "vulkan_memory_model_availability_visibility_chains",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.vulkan_memory_model_device_scope {
            if !supported.vulkan_memory_model_device_scope {
                return Err(FeatureRestrictionError {
                    feature: "vulkan_memory_model_device_scope",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.wide_lines {
            if !supported.wide_lines {
                return Err(FeatureRestrictionError {
                    feature: "wide_lines",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.workgroup_memory_explicit_layout {
            if !supported.workgroup_memory_explicit_layout {
                return Err(FeatureRestrictionError {
                    feature: "workgroup_memory_explicit_layout",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.workgroup_memory_explicit_layout16_bit_access {
            if !supported.workgroup_memory_explicit_layout16_bit_access {
                return Err(FeatureRestrictionError {
                    feature: "workgroup_memory_explicit_layout16_bit_access",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.workgroup_memory_explicit_layout8_bit_access {
            if !supported.workgroup_memory_explicit_layout8_bit_access {
                return Err(FeatureRestrictionError {
                    feature: "workgroup_memory_explicit_layout8_bit_access",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.workgroup_memory_explicit_layout_scalar_block_layout {
            if !supported.workgroup_memory_explicit_layout_scalar_block_layout {
                return Err(FeatureRestrictionError {
                    feature: "workgroup_memory_explicit_layout_scalar_block_layout",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ycbcr2plane444_formats {
            if !supported.ycbcr2plane444_formats {
                return Err(FeatureRestrictionError {
                    feature: "ycbcr2plane444_formats",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        if self.ycbcr_image_arrays {
            if !supported.ycbcr_image_arrays {
                return Err(FeatureRestrictionError {
                    feature: "ycbcr_image_arrays",
                    restriction: FeatureRestriction::NotSupported,
                });
            }
        } else {
        }
        Ok(())
    }
    #[doc = r" Builds a `Features` object with all values to false."]
    pub const fn none() -> Features {
        Features {
            acceleration_structure: false,
            acceleration_structure_capture_replay: false,
            acceleration_structure_host_commands: false,
            acceleration_structure_indirect_build: false,
            advanced_blend_coherent_operations: false,
            alpha_to_one: false,
            attachment_fragment_shading_rate: false,
            bresenham_lines: false,
            buffer_device_address: false,
            buffer_device_address_capture_replay: false,
            buffer_device_address_multi_device: false,
            color_write_enable: false,
            compute_derivative_group_linear: false,
            compute_derivative_group_quads: false,
            compute_full_subgroups: false,
            conditional_rendering: false,
            constant_alpha_color_blend_factors: false,
            cooperative_matrix: false,
            cooperative_matrix_robust_buffer_access: false,
            corner_sampled_image: false,
            coverage_reduction_mode: false,
            custom_border_color_without_format: false,
            custom_border_colors: false,
            decode_mode_shared_exponent: false,
            dedicated_allocation_image_aliasing: false,
            depth_bias_clamp: false,
            depth_bounds: false,
            depth_clamp: false,
            depth_clip_enable: false,
            descriptor_binding_acceleration_structure_update_after_bind: false,
            descriptor_binding_inline_uniform_block_update_after_bind: false,
            descriptor_binding_partially_bound: false,
            descriptor_binding_sampled_image_update_after_bind: false,
            descriptor_binding_storage_buffer_update_after_bind: false,
            descriptor_binding_storage_image_update_after_bind: false,
            descriptor_binding_storage_texel_buffer_update_after_bind: false,
            descriptor_binding_uniform_buffer_update_after_bind: false,
            descriptor_binding_uniform_texel_buffer_update_after_bind: false,
            descriptor_binding_update_unused_while_pending: false,
            descriptor_binding_variable_descriptor_count: false,
            descriptor_indexing: false,
            device_coherent_memory: false,
            device_generated_commands: false,
            device_memory_report: false,
            diagnostics_config: false,
            draw_indirect_count: false,
            draw_indirect_first_instance: false,
            dual_src_blend: false,
            events: false,
            exclusive_scissor: false,
            extended_dynamic_state: false,
            extended_dynamic_state2: false,
            extended_dynamic_state2_logic_op: false,
            extended_dynamic_state2_patch_control_points: false,
            external_memory_rdma: false,
            fill_mode_non_solid: false,
            format_a4b4g4r4: false,
            format_a4r4g4b4: false,
            fragment_density_map: false,
            fragment_density_map_deferred: false,
            fragment_density_map_dynamic: false,
            fragment_density_map_non_subsampled_images: false,
            fragment_shader_barycentric: false,
            fragment_shader_pixel_interlock: false,
            fragment_shader_sample_interlock: false,
            fragment_shader_shading_rate_interlock: false,
            fragment_shading_rate_enums: false,
            fragment_stores_and_atomics: false,
            full_draw_index_uint32: false,
            geometry_shader: false,
            geometry_streams: false,
            global_priority_query: false,
            host_query_reset: false,
            image_cube_array: false,
            image_footprint: false,
            image_view2_d_on3_d_image: false,
            image_view_format_reinterpretation: false,
            image_view_format_swizzle: false,
            imageless_framebuffer: false,
            independent_blend: false,
            index_type_uint8: false,
            inherited_conditional_rendering: false,
            inherited_queries: false,
            inherited_viewport_scissor2_d: false,
            inline_uniform_block: false,
            invocation_mask: false,
            large_points: false,
            logic_op: false,
            memory_priority: false,
            mesh_shader: false,
            multi_draw: false,
            multi_draw_indirect: false,
            multi_viewport: false,
            multisample_array_image: false,
            multiview: false,
            multiview_geometry_shader: false,
            multiview_tessellation_shader: false,
            mutable_comparison_samplers: false,
            mutable_descriptor_type: false,
            no_invocation_fragment_shading_rates: false,
            null_descriptor: false,
            occlusion_query_precise: false,
            pageable_device_local_memory: false,
            performance_counter_multiple_query_pools: false,
            performance_counter_query_pools: false,
            pipeline_creation_cache_control: false,
            pipeline_executable_info: false,
            pipeline_fragment_shading_rate: false,
            pipeline_statistics_query: false,
            point_polygons: false,
            present_id: false,
            present_wait: false,
            primitive_fragment_shading_rate: false,
            primitive_topology_list_restart: false,
            primitive_topology_patch_list_restart: false,
            private_data: false,
            protected_memory: false,
            provoking_vertex_last: false,
            ray_query: false,
            ray_tracing_motion_blur: false,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: false,
            ray_tracing_pipeline: false,
            ray_tracing_pipeline_shader_group_handle_capture_replay: false,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: false,
            ray_tracing_pipeline_trace_rays_indirect: false,
            ray_traversal_primitive_culling: false,
            rectangular_lines: false,
            representative_fragment_test: false,
            robust_buffer_access: false,
            robust_buffer_access2: false,
            robust_image_access: false,
            robust_image_access2: false,
            runtime_descriptor_array: false,
            sample_rate_shading: false,
            sampler_anisotropy: false,
            sampler_filter_minmax: false,
            sampler_mip_lod_bias: false,
            sampler_mirror_clamp_to_edge: false,
            sampler_ycbcr_conversion: false,
            scalar_block_layout: false,
            separate_depth_stencil_layouts: false,
            separate_stencil_mask_ref: false,
            shader_buffer_float16_atomic_add: false,
            shader_buffer_float16_atomic_min_max: false,
            shader_buffer_float16_atomics: false,
            shader_buffer_float32_atomic_add: false,
            shader_buffer_float32_atomic_min_max: false,
            shader_buffer_float32_atomics: false,
            shader_buffer_float64_atomic_add: false,
            shader_buffer_float64_atomic_min_max: false,
            shader_buffer_float64_atomics: false,
            shader_buffer_int64_atomics: false,
            shader_clip_distance: false,
            shader_cull_distance: false,
            shader_demote_to_helper_invocation: false,
            shader_device_clock: false,
            shader_draw_parameters: false,
            shader_float16: false,
            shader_float64: false,
            shader_image_float32_atomic_add: false,
            shader_image_float32_atomic_min_max: false,
            shader_image_float32_atomics: false,
            shader_image_gather_extended: false,
            shader_image_int64_atomics: false,
            shader_input_attachment_array_dynamic_indexing: false,
            shader_input_attachment_array_non_uniform_indexing: false,
            shader_int16: false,
            shader_int64: false,
            shader_int8: false,
            shader_integer_dot_product: false,
            shader_integer_functions2: false,
            shader_output_layer: false,
            shader_output_viewport_index: false,
            shader_resource_min_lod: false,
            shader_resource_residency: false,
            shader_sample_rate_interpolation_functions: false,
            shader_sampled_image_array_dynamic_indexing: false,
            shader_sampled_image_array_non_uniform_indexing: false,
            shader_shared_float16_atomic_add: false,
            shader_shared_float16_atomic_min_max: false,
            shader_shared_float16_atomics: false,
            shader_shared_float32_atomic_add: false,
            shader_shared_float32_atomic_min_max: false,
            shader_shared_float32_atomics: false,
            shader_shared_float64_atomic_add: false,
            shader_shared_float64_atomic_min_max: false,
            shader_shared_float64_atomics: false,
            shader_shared_int64_atomics: false,
            shader_sm_builtins: false,
            shader_storage_buffer_array_dynamic_indexing: false,
            shader_storage_buffer_array_non_uniform_indexing: false,
            shader_storage_image_array_dynamic_indexing: false,
            shader_storage_image_array_non_uniform_indexing: false,
            shader_storage_image_extended_formats: false,
            shader_storage_image_multisample: false,
            shader_storage_image_read_without_format: false,
            shader_storage_image_write_without_format: false,
            shader_storage_texel_buffer_array_dynamic_indexing: false,
            shader_storage_texel_buffer_array_non_uniform_indexing: false,
            shader_subgroup_clock: false,
            shader_subgroup_extended_types: false,
            shader_subgroup_uniform_control_flow: false,
            shader_terminate_invocation: false,
            shader_tessellation_and_geometry_point_size: false,
            shader_uniform_buffer_array_dynamic_indexing: false,
            shader_uniform_buffer_array_non_uniform_indexing: false,
            shader_uniform_texel_buffer_array_dynamic_indexing: false,
            shader_uniform_texel_buffer_array_non_uniform_indexing: false,
            shader_zero_initialize_workgroup_memory: false,
            shading_rate_coarse_sample_order: false,
            shading_rate_image: false,
            smooth_lines: false,
            sparse_binding: false,
            sparse_image_float32_atomic_add: false,
            sparse_image_float32_atomic_min_max: false,
            sparse_image_float32_atomics: false,
            sparse_image_int64_atomics: false,
            sparse_residency16_samples: false,
            sparse_residency2_samples: false,
            sparse_residency4_samples: false,
            sparse_residency8_samples: false,
            sparse_residency_aliased: false,
            sparse_residency_buffer: false,
            sparse_residency_image2_d: false,
            sparse_residency_image3_d: false,
            stippled_bresenham_lines: false,
            stippled_rectangular_lines: false,
            stippled_smooth_lines: false,
            storage_buffer16_bit_access: false,
            storage_buffer8_bit_access: false,
            storage_input_output16: false,
            storage_push_constant16: false,
            storage_push_constant8: false,
            subgroup_broadcast_dynamic_id: false,
            subgroup_size_control: false,
            subpass_shading: false,
            supersample_fragment_shading_rates: false,
            synchronization2: false,
            task_shader: false,
            tessellation_isolines: false,
            tessellation_point_mode: false,
            tessellation_shader: false,
            texel_buffer_alignment: false,
            texture_compression_astc_hdr: false,
            texture_compression_astc_ldr: false,
            texture_compression_bc: false,
            texture_compression_etc2: false,
            timeline_semaphore: false,
            transform_feedback: false,
            transform_feedback_preserves_provoking_vertex: false,
            triangle_fans: false,
            uniform_and_storage_buffer16_bit_access: false,
            uniform_and_storage_buffer8_bit_access: false,
            uniform_buffer_standard_layout: false,
            variable_multisample_rate: false,
            variable_pointers: false,
            variable_pointers_storage_buffer: false,
            vertex_attribute_access_beyond_stride: false,
            vertex_attribute_instance_rate_divisor: false,
            vertex_attribute_instance_rate_zero_divisor: false,
            vertex_input_dynamic_state: false,
            vertex_pipeline_stores_and_atomics: false,
            vulkan_memory_model: false,
            vulkan_memory_model_availability_visibility_chains: false,
            vulkan_memory_model_device_scope: false,
            wide_lines: false,
            workgroup_memory_explicit_layout: false,
            workgroup_memory_explicit_layout16_bit_access: false,
            workgroup_memory_explicit_layout8_bit_access: false,
            workgroup_memory_explicit_layout_scalar_block_layout: false,
            ycbcr2plane444_formats: false,
            ycbcr_image_arrays: false,
        }
    }
    #[doc = r" Builds a `Features` object with all values to true."]
    #[doc = r""]
    #[doc = r" > **Note**: This function is used for testing purposes, and is probably useless in"]
    #[doc = r" > a real code."]
    pub const fn all() -> Features {
        Features {
            acceleration_structure: true,
            acceleration_structure_capture_replay: true,
            acceleration_structure_host_commands: true,
            acceleration_structure_indirect_build: true,
            advanced_blend_coherent_operations: true,
            alpha_to_one: true,
            attachment_fragment_shading_rate: true,
            bresenham_lines: true,
            buffer_device_address: true,
            buffer_device_address_capture_replay: true,
            buffer_device_address_multi_device: true,
            color_write_enable: true,
            compute_derivative_group_linear: true,
            compute_derivative_group_quads: true,
            compute_full_subgroups: true,
            conditional_rendering: true,
            constant_alpha_color_blend_factors: true,
            cooperative_matrix: true,
            cooperative_matrix_robust_buffer_access: true,
            corner_sampled_image: true,
            coverage_reduction_mode: true,
            custom_border_color_without_format: true,
            custom_border_colors: true,
            decode_mode_shared_exponent: true,
            dedicated_allocation_image_aliasing: true,
            depth_bias_clamp: true,
            depth_bounds: true,
            depth_clamp: true,
            depth_clip_enable: true,
            descriptor_binding_acceleration_structure_update_after_bind: true,
            descriptor_binding_inline_uniform_block_update_after_bind: true,
            descriptor_binding_partially_bound: true,
            descriptor_binding_sampled_image_update_after_bind: true,
            descriptor_binding_storage_buffer_update_after_bind: true,
            descriptor_binding_storage_image_update_after_bind: true,
            descriptor_binding_storage_texel_buffer_update_after_bind: true,
            descriptor_binding_uniform_buffer_update_after_bind: true,
            descriptor_binding_uniform_texel_buffer_update_after_bind: true,
            descriptor_binding_update_unused_while_pending: true,
            descriptor_binding_variable_descriptor_count: true,
            descriptor_indexing: true,
            device_coherent_memory: true,
            device_generated_commands: true,
            device_memory_report: true,
            diagnostics_config: true,
            draw_indirect_count: true,
            draw_indirect_first_instance: true,
            dual_src_blend: true,
            events: true,
            exclusive_scissor: true,
            extended_dynamic_state: true,
            extended_dynamic_state2: true,
            extended_dynamic_state2_logic_op: true,
            extended_dynamic_state2_patch_control_points: true,
            external_memory_rdma: true,
            fill_mode_non_solid: true,
            format_a4b4g4r4: true,
            format_a4r4g4b4: true,
            fragment_density_map: true,
            fragment_density_map_deferred: true,
            fragment_density_map_dynamic: true,
            fragment_density_map_non_subsampled_images: true,
            fragment_shader_barycentric: true,
            fragment_shader_pixel_interlock: true,
            fragment_shader_sample_interlock: true,
            fragment_shader_shading_rate_interlock: true,
            fragment_shading_rate_enums: true,
            fragment_stores_and_atomics: true,
            full_draw_index_uint32: true,
            geometry_shader: true,
            geometry_streams: true,
            global_priority_query: true,
            host_query_reset: true,
            image_cube_array: true,
            image_footprint: true,
            image_view2_d_on3_d_image: true,
            image_view_format_reinterpretation: true,
            image_view_format_swizzle: true,
            imageless_framebuffer: true,
            independent_blend: true,
            index_type_uint8: true,
            inherited_conditional_rendering: true,
            inherited_queries: true,
            inherited_viewport_scissor2_d: true,
            inline_uniform_block: true,
            invocation_mask: true,
            large_points: true,
            logic_op: true,
            memory_priority: true,
            mesh_shader: true,
            multi_draw: true,
            multi_draw_indirect: true,
            multi_viewport: true,
            multisample_array_image: true,
            multiview: true,
            multiview_geometry_shader: true,
            multiview_tessellation_shader: true,
            mutable_comparison_samplers: true,
            mutable_descriptor_type: true,
            no_invocation_fragment_shading_rates: true,
            null_descriptor: true,
            occlusion_query_precise: true,
            pageable_device_local_memory: true,
            performance_counter_multiple_query_pools: true,
            performance_counter_query_pools: true,
            pipeline_creation_cache_control: true,
            pipeline_executable_info: true,
            pipeline_fragment_shading_rate: true,
            pipeline_statistics_query: true,
            point_polygons: true,
            present_id: true,
            present_wait: true,
            primitive_fragment_shading_rate: true,
            primitive_topology_list_restart: true,
            primitive_topology_patch_list_restart: true,
            private_data: true,
            protected_memory: true,
            provoking_vertex_last: true,
            ray_query: true,
            ray_tracing_motion_blur: true,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: true,
            ray_tracing_pipeline: true,
            ray_tracing_pipeline_shader_group_handle_capture_replay: true,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: true,
            ray_tracing_pipeline_trace_rays_indirect: true,
            ray_traversal_primitive_culling: true,
            rectangular_lines: true,
            representative_fragment_test: true,
            robust_buffer_access: true,
            robust_buffer_access2: true,
            robust_image_access: true,
            robust_image_access2: true,
            runtime_descriptor_array: true,
            sample_rate_shading: true,
            sampler_anisotropy: true,
            sampler_filter_minmax: true,
            sampler_mip_lod_bias: true,
            sampler_mirror_clamp_to_edge: true,
            sampler_ycbcr_conversion: true,
            scalar_block_layout: true,
            separate_depth_stencil_layouts: true,
            separate_stencil_mask_ref: true,
            shader_buffer_float16_atomic_add: true,
            shader_buffer_float16_atomic_min_max: true,
            shader_buffer_float16_atomics: true,
            shader_buffer_float32_atomic_add: true,
            shader_buffer_float32_atomic_min_max: true,
            shader_buffer_float32_atomics: true,
            shader_buffer_float64_atomic_add: true,
            shader_buffer_float64_atomic_min_max: true,
            shader_buffer_float64_atomics: true,
            shader_buffer_int64_atomics: true,
            shader_clip_distance: true,
            shader_cull_distance: true,
            shader_demote_to_helper_invocation: true,
            shader_device_clock: true,
            shader_draw_parameters: true,
            shader_float16: true,
            shader_float64: true,
            shader_image_float32_atomic_add: true,
            shader_image_float32_atomic_min_max: true,
            shader_image_float32_atomics: true,
            shader_image_gather_extended: true,
            shader_image_int64_atomics: true,
            shader_input_attachment_array_dynamic_indexing: true,
            shader_input_attachment_array_non_uniform_indexing: true,
            shader_int16: true,
            shader_int64: true,
            shader_int8: true,
            shader_integer_dot_product: true,
            shader_integer_functions2: true,
            shader_output_layer: true,
            shader_output_viewport_index: true,
            shader_resource_min_lod: true,
            shader_resource_residency: true,
            shader_sample_rate_interpolation_functions: true,
            shader_sampled_image_array_dynamic_indexing: true,
            shader_sampled_image_array_non_uniform_indexing: true,
            shader_shared_float16_atomic_add: true,
            shader_shared_float16_atomic_min_max: true,
            shader_shared_float16_atomics: true,
            shader_shared_float32_atomic_add: true,
            shader_shared_float32_atomic_min_max: true,
            shader_shared_float32_atomics: true,
            shader_shared_float64_atomic_add: true,
            shader_shared_float64_atomic_min_max: true,
            shader_shared_float64_atomics: true,
            shader_shared_int64_atomics: true,
            shader_sm_builtins: true,
            shader_storage_buffer_array_dynamic_indexing: true,
            shader_storage_buffer_array_non_uniform_indexing: true,
            shader_storage_image_array_dynamic_indexing: true,
            shader_storage_image_array_non_uniform_indexing: true,
            shader_storage_image_extended_formats: true,
            shader_storage_image_multisample: true,
            shader_storage_image_read_without_format: true,
            shader_storage_image_write_without_format: true,
            shader_storage_texel_buffer_array_dynamic_indexing: true,
            shader_storage_texel_buffer_array_non_uniform_indexing: true,
            shader_subgroup_clock: true,
            shader_subgroup_extended_types: true,
            shader_subgroup_uniform_control_flow: true,
            shader_terminate_invocation: true,
            shader_tessellation_and_geometry_point_size: true,
            shader_uniform_buffer_array_dynamic_indexing: true,
            shader_uniform_buffer_array_non_uniform_indexing: true,
            shader_uniform_texel_buffer_array_dynamic_indexing: true,
            shader_uniform_texel_buffer_array_non_uniform_indexing: true,
            shader_zero_initialize_workgroup_memory: true,
            shading_rate_coarse_sample_order: true,
            shading_rate_image: true,
            smooth_lines: true,
            sparse_binding: true,
            sparse_image_float32_atomic_add: true,
            sparse_image_float32_atomic_min_max: true,
            sparse_image_float32_atomics: true,
            sparse_image_int64_atomics: true,
            sparse_residency16_samples: true,
            sparse_residency2_samples: true,
            sparse_residency4_samples: true,
            sparse_residency8_samples: true,
            sparse_residency_aliased: true,
            sparse_residency_buffer: true,
            sparse_residency_image2_d: true,
            sparse_residency_image3_d: true,
            stippled_bresenham_lines: true,
            stippled_rectangular_lines: true,
            stippled_smooth_lines: true,
            storage_buffer16_bit_access: true,
            storage_buffer8_bit_access: true,
            storage_input_output16: true,
            storage_push_constant16: true,
            storage_push_constant8: true,
            subgroup_broadcast_dynamic_id: true,
            subgroup_size_control: true,
            subpass_shading: true,
            supersample_fragment_shading_rates: true,
            synchronization2: true,
            task_shader: true,
            tessellation_isolines: true,
            tessellation_point_mode: true,
            tessellation_shader: true,
            texel_buffer_alignment: true,
            texture_compression_astc_hdr: true,
            texture_compression_astc_ldr: true,
            texture_compression_bc: true,
            texture_compression_etc2: true,
            timeline_semaphore: true,
            transform_feedback: true,
            transform_feedback_preserves_provoking_vertex: true,
            triangle_fans: true,
            uniform_and_storage_buffer16_bit_access: true,
            uniform_and_storage_buffer8_bit_access: true,
            uniform_buffer_standard_layout: true,
            variable_multisample_rate: true,
            variable_pointers: true,
            variable_pointers_storage_buffer: true,
            vertex_attribute_access_beyond_stride: true,
            vertex_attribute_instance_rate_divisor: true,
            vertex_attribute_instance_rate_zero_divisor: true,
            vertex_input_dynamic_state: true,
            vertex_pipeline_stores_and_atomics: true,
            vulkan_memory_model: true,
            vulkan_memory_model_availability_visibility_chains: true,
            vulkan_memory_model_device_scope: true,
            wide_lines: true,
            workgroup_memory_explicit_layout: true,
            workgroup_memory_explicit_layout16_bit_access: true,
            workgroup_memory_explicit_layout8_bit_access: true,
            workgroup_memory_explicit_layout_scalar_block_layout: true,
            ycbcr2plane444_formats: true,
            ycbcr_image_arrays: true,
        }
    }
    #[doc = r" Returns true if `self` is a superset of the parameter."]
    #[doc = r""]
    #[doc = r" That is, for each feature of the parameter that is true, the corresponding value"]
    #[doc = r" in self is true as well."]
    pub const fn is_superset_of(&self, other: &Features) -> bool {
        (self.acceleration_structure || !other.acceleration_structure)
            && (self.acceleration_structure_capture_replay
                || !other.acceleration_structure_capture_replay)
            && (self.acceleration_structure_host_commands
                || !other.acceleration_structure_host_commands)
            && (self.acceleration_structure_indirect_build
                || !other.acceleration_structure_indirect_build)
            && (self.advanced_blend_coherent_operations
                || !other.advanced_blend_coherent_operations)
            && (self.alpha_to_one || !other.alpha_to_one)
            && (self.attachment_fragment_shading_rate || !other.attachment_fragment_shading_rate)
            && (self.bresenham_lines || !other.bresenham_lines)
            && (self.buffer_device_address || !other.buffer_device_address)
            && (self.buffer_device_address_capture_replay
                || !other.buffer_device_address_capture_replay)
            && (self.buffer_device_address_multi_device
                || !other.buffer_device_address_multi_device)
            && (self.color_write_enable || !other.color_write_enable)
            && (self.compute_derivative_group_linear || !other.compute_derivative_group_linear)
            && (self.compute_derivative_group_quads || !other.compute_derivative_group_quads)
            && (self.compute_full_subgroups || !other.compute_full_subgroups)
            && (self.conditional_rendering || !other.conditional_rendering)
            && (self.constant_alpha_color_blend_factors
                || !other.constant_alpha_color_blend_factors)
            && (self.cooperative_matrix || !other.cooperative_matrix)
            && (self.cooperative_matrix_robust_buffer_access
                || !other.cooperative_matrix_robust_buffer_access)
            && (self.corner_sampled_image || !other.corner_sampled_image)
            && (self.coverage_reduction_mode || !other.coverage_reduction_mode)
            && (self.custom_border_color_without_format
                || !other.custom_border_color_without_format)
            && (self.custom_border_colors || !other.custom_border_colors)
            && (self.decode_mode_shared_exponent || !other.decode_mode_shared_exponent)
            && (self.dedicated_allocation_image_aliasing
                || !other.dedicated_allocation_image_aliasing)
            && (self.depth_bias_clamp || !other.depth_bias_clamp)
            && (self.depth_bounds || !other.depth_bounds)
            && (self.depth_clamp || !other.depth_clamp)
            && (self.depth_clip_enable || !other.depth_clip_enable)
            && (self.descriptor_binding_acceleration_structure_update_after_bind
                || !other.descriptor_binding_acceleration_structure_update_after_bind)
            && (self.descriptor_binding_inline_uniform_block_update_after_bind
                || !other.descriptor_binding_inline_uniform_block_update_after_bind)
            && (self.descriptor_binding_partially_bound
                || !other.descriptor_binding_partially_bound)
            && (self.descriptor_binding_sampled_image_update_after_bind
                || !other.descriptor_binding_sampled_image_update_after_bind)
            && (self.descriptor_binding_storage_buffer_update_after_bind
                || !other.descriptor_binding_storage_buffer_update_after_bind)
            && (self.descriptor_binding_storage_image_update_after_bind
                || !other.descriptor_binding_storage_image_update_after_bind)
            && (self.descriptor_binding_storage_texel_buffer_update_after_bind
                || !other.descriptor_binding_storage_texel_buffer_update_after_bind)
            && (self.descriptor_binding_uniform_buffer_update_after_bind
                || !other.descriptor_binding_uniform_buffer_update_after_bind)
            && (self.descriptor_binding_uniform_texel_buffer_update_after_bind
                || !other.descriptor_binding_uniform_texel_buffer_update_after_bind)
            && (self.descriptor_binding_update_unused_while_pending
                || !other.descriptor_binding_update_unused_while_pending)
            && (self.descriptor_binding_variable_descriptor_count
                || !other.descriptor_binding_variable_descriptor_count)
            && (self.descriptor_indexing || !other.descriptor_indexing)
            && (self.device_coherent_memory || !other.device_coherent_memory)
            && (self.device_generated_commands || !other.device_generated_commands)
            && (self.device_memory_report || !other.device_memory_report)
            && (self.diagnostics_config || !other.diagnostics_config)
            && (self.draw_indirect_count || !other.draw_indirect_count)
            && (self.draw_indirect_first_instance || !other.draw_indirect_first_instance)
            && (self.dual_src_blend || !other.dual_src_blend)
            && (self.events || !other.events)
            && (self.exclusive_scissor || !other.exclusive_scissor)
            && (self.extended_dynamic_state || !other.extended_dynamic_state)
            && (self.extended_dynamic_state2 || !other.extended_dynamic_state2)
            && (self.extended_dynamic_state2_logic_op || !other.extended_dynamic_state2_logic_op)
            && (self.extended_dynamic_state2_patch_control_points
                || !other.extended_dynamic_state2_patch_control_points)
            && (self.external_memory_rdma || !other.external_memory_rdma)
            && (self.fill_mode_non_solid || !other.fill_mode_non_solid)
            && (self.format_a4b4g4r4 || !other.format_a4b4g4r4)
            && (self.format_a4r4g4b4 || !other.format_a4r4g4b4)
            && (self.fragment_density_map || !other.fragment_density_map)
            && (self.fragment_density_map_deferred || !other.fragment_density_map_deferred)
            && (self.fragment_density_map_dynamic || !other.fragment_density_map_dynamic)
            && (self.fragment_density_map_non_subsampled_images
                || !other.fragment_density_map_non_subsampled_images)
            && (self.fragment_shader_barycentric || !other.fragment_shader_barycentric)
            && (self.fragment_shader_pixel_interlock || !other.fragment_shader_pixel_interlock)
            && (self.fragment_shader_sample_interlock || !other.fragment_shader_sample_interlock)
            && (self.fragment_shader_shading_rate_interlock
                || !other.fragment_shader_shading_rate_interlock)
            && (self.fragment_shading_rate_enums || !other.fragment_shading_rate_enums)
            && (self.fragment_stores_and_atomics || !other.fragment_stores_and_atomics)
            && (self.full_draw_index_uint32 || !other.full_draw_index_uint32)
            && (self.geometry_shader || !other.geometry_shader)
            && (self.geometry_streams || !other.geometry_streams)
            && (self.global_priority_query || !other.global_priority_query)
            && (self.host_query_reset || !other.host_query_reset)
            && (self.image_cube_array || !other.image_cube_array)
            && (self.image_footprint || !other.image_footprint)
            && (self.image_view2_d_on3_d_image || !other.image_view2_d_on3_d_image)
            && (self.image_view_format_reinterpretation
                || !other.image_view_format_reinterpretation)
            && (self.image_view_format_swizzle || !other.image_view_format_swizzle)
            && (self.imageless_framebuffer || !other.imageless_framebuffer)
            && (self.independent_blend || !other.independent_blend)
            && (self.index_type_uint8 || !other.index_type_uint8)
            && (self.inherited_conditional_rendering || !other.inherited_conditional_rendering)
            && (self.inherited_queries || !other.inherited_queries)
            && (self.inherited_viewport_scissor2_d || !other.inherited_viewport_scissor2_d)
            && (self.inline_uniform_block || !other.inline_uniform_block)
            && (self.invocation_mask || !other.invocation_mask)
            && (self.large_points || !other.large_points)
            && (self.logic_op || !other.logic_op)
            && (self.memory_priority || !other.memory_priority)
            && (self.mesh_shader || !other.mesh_shader)
            && (self.multi_draw || !other.multi_draw)
            && (self.multi_draw_indirect || !other.multi_draw_indirect)
            && (self.multi_viewport || !other.multi_viewport)
            && (self.multisample_array_image || !other.multisample_array_image)
            && (self.multiview || !other.multiview)
            && (self.multiview_geometry_shader || !other.multiview_geometry_shader)
            && (self.multiview_tessellation_shader || !other.multiview_tessellation_shader)
            && (self.mutable_comparison_samplers || !other.mutable_comparison_samplers)
            && (self.mutable_descriptor_type || !other.mutable_descriptor_type)
            && (self.no_invocation_fragment_shading_rates
                || !other.no_invocation_fragment_shading_rates)
            && (self.null_descriptor || !other.null_descriptor)
            && (self.occlusion_query_precise || !other.occlusion_query_precise)
            && (self.pageable_device_local_memory || !other.pageable_device_local_memory)
            && (self.performance_counter_multiple_query_pools
                || !other.performance_counter_multiple_query_pools)
            && (self.performance_counter_query_pools || !other.performance_counter_query_pools)
            && (self.pipeline_creation_cache_control || !other.pipeline_creation_cache_control)
            && (self.pipeline_executable_info || !other.pipeline_executable_info)
            && (self.pipeline_fragment_shading_rate || !other.pipeline_fragment_shading_rate)
            && (self.pipeline_statistics_query || !other.pipeline_statistics_query)
            && (self.point_polygons || !other.point_polygons)
            && (self.present_id || !other.present_id)
            && (self.present_wait || !other.present_wait)
            && (self.primitive_fragment_shading_rate || !other.primitive_fragment_shading_rate)
            && (self.primitive_topology_list_restart || !other.primitive_topology_list_restart)
            && (self.primitive_topology_patch_list_restart
                || !other.primitive_topology_patch_list_restart)
            && (self.private_data || !other.private_data)
            && (self.protected_memory || !other.protected_memory)
            && (self.provoking_vertex_last || !other.provoking_vertex_last)
            && (self.ray_query || !other.ray_query)
            && (self.ray_tracing_motion_blur || !other.ray_tracing_motion_blur)
            && (self.ray_tracing_motion_blur_pipeline_trace_rays_indirect
                || !other.ray_tracing_motion_blur_pipeline_trace_rays_indirect)
            && (self.ray_tracing_pipeline || !other.ray_tracing_pipeline)
            && (self.ray_tracing_pipeline_shader_group_handle_capture_replay
                || !other.ray_tracing_pipeline_shader_group_handle_capture_replay)
            && (self.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                || !other.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed)
            && (self.ray_tracing_pipeline_trace_rays_indirect
                || !other.ray_tracing_pipeline_trace_rays_indirect)
            && (self.ray_traversal_primitive_culling || !other.ray_traversal_primitive_culling)
            && (self.rectangular_lines || !other.rectangular_lines)
            && (self.representative_fragment_test || !other.representative_fragment_test)
            && (self.robust_buffer_access || !other.robust_buffer_access)
            && (self.robust_buffer_access2 || !other.robust_buffer_access2)
            && (self.robust_image_access || !other.robust_image_access)
            && (self.robust_image_access2 || !other.robust_image_access2)
            && (self.runtime_descriptor_array || !other.runtime_descriptor_array)
            && (self.sample_rate_shading || !other.sample_rate_shading)
            && (self.sampler_anisotropy || !other.sampler_anisotropy)
            && (self.sampler_filter_minmax || !other.sampler_filter_minmax)
            && (self.sampler_mip_lod_bias || !other.sampler_mip_lod_bias)
            && (self.sampler_mirror_clamp_to_edge || !other.sampler_mirror_clamp_to_edge)
            && (self.sampler_ycbcr_conversion || !other.sampler_ycbcr_conversion)
            && (self.scalar_block_layout || !other.scalar_block_layout)
            && (self.separate_depth_stencil_layouts || !other.separate_depth_stencil_layouts)
            && (self.separate_stencil_mask_ref || !other.separate_stencil_mask_ref)
            && (self.shader_buffer_float16_atomic_add || !other.shader_buffer_float16_atomic_add)
            && (self.shader_buffer_float16_atomic_min_max
                || !other.shader_buffer_float16_atomic_min_max)
            && (self.shader_buffer_float16_atomics || !other.shader_buffer_float16_atomics)
            && (self.shader_buffer_float32_atomic_add || !other.shader_buffer_float32_atomic_add)
            && (self.shader_buffer_float32_atomic_min_max
                || !other.shader_buffer_float32_atomic_min_max)
            && (self.shader_buffer_float32_atomics || !other.shader_buffer_float32_atomics)
            && (self.shader_buffer_float64_atomic_add || !other.shader_buffer_float64_atomic_add)
            && (self.shader_buffer_float64_atomic_min_max
                || !other.shader_buffer_float64_atomic_min_max)
            && (self.shader_buffer_float64_atomics || !other.shader_buffer_float64_atomics)
            && (self.shader_buffer_int64_atomics || !other.shader_buffer_int64_atomics)
            && (self.shader_clip_distance || !other.shader_clip_distance)
            && (self.shader_cull_distance || !other.shader_cull_distance)
            && (self.shader_demote_to_helper_invocation
                || !other.shader_demote_to_helper_invocation)
            && (self.shader_device_clock || !other.shader_device_clock)
            && (self.shader_draw_parameters || !other.shader_draw_parameters)
            && (self.shader_float16 || !other.shader_float16)
            && (self.shader_float64 || !other.shader_float64)
            && (self.shader_image_float32_atomic_add || !other.shader_image_float32_atomic_add)
            && (self.shader_image_float32_atomic_min_max
                || !other.shader_image_float32_atomic_min_max)
            && (self.shader_image_float32_atomics || !other.shader_image_float32_atomics)
            && (self.shader_image_gather_extended || !other.shader_image_gather_extended)
            && (self.shader_image_int64_atomics || !other.shader_image_int64_atomics)
            && (self.shader_input_attachment_array_dynamic_indexing
                || !other.shader_input_attachment_array_dynamic_indexing)
            && (self.shader_input_attachment_array_non_uniform_indexing
                || !other.shader_input_attachment_array_non_uniform_indexing)
            && (self.shader_int16 || !other.shader_int16)
            && (self.shader_int64 || !other.shader_int64)
            && (self.shader_int8 || !other.shader_int8)
            && (self.shader_integer_dot_product || !other.shader_integer_dot_product)
            && (self.shader_integer_functions2 || !other.shader_integer_functions2)
            && (self.shader_output_layer || !other.shader_output_layer)
            && (self.shader_output_viewport_index || !other.shader_output_viewport_index)
            && (self.shader_resource_min_lod || !other.shader_resource_min_lod)
            && (self.shader_resource_residency || !other.shader_resource_residency)
            && (self.shader_sample_rate_interpolation_functions
                || !other.shader_sample_rate_interpolation_functions)
            && (self.shader_sampled_image_array_dynamic_indexing
                || !other.shader_sampled_image_array_dynamic_indexing)
            && (self.shader_sampled_image_array_non_uniform_indexing
                || !other.shader_sampled_image_array_non_uniform_indexing)
            && (self.shader_shared_float16_atomic_add || !other.shader_shared_float16_atomic_add)
            && (self.shader_shared_float16_atomic_min_max
                || !other.shader_shared_float16_atomic_min_max)
            && (self.shader_shared_float16_atomics || !other.shader_shared_float16_atomics)
            && (self.shader_shared_float32_atomic_add || !other.shader_shared_float32_atomic_add)
            && (self.shader_shared_float32_atomic_min_max
                || !other.shader_shared_float32_atomic_min_max)
            && (self.shader_shared_float32_atomics || !other.shader_shared_float32_atomics)
            && (self.shader_shared_float64_atomic_add || !other.shader_shared_float64_atomic_add)
            && (self.shader_shared_float64_atomic_min_max
                || !other.shader_shared_float64_atomic_min_max)
            && (self.shader_shared_float64_atomics || !other.shader_shared_float64_atomics)
            && (self.shader_shared_int64_atomics || !other.shader_shared_int64_atomics)
            && (self.shader_sm_builtins || !other.shader_sm_builtins)
            && (self.shader_storage_buffer_array_dynamic_indexing
                || !other.shader_storage_buffer_array_dynamic_indexing)
            && (self.shader_storage_buffer_array_non_uniform_indexing
                || !other.shader_storage_buffer_array_non_uniform_indexing)
            && (self.shader_storage_image_array_dynamic_indexing
                || !other.shader_storage_image_array_dynamic_indexing)
            && (self.shader_storage_image_array_non_uniform_indexing
                || !other.shader_storage_image_array_non_uniform_indexing)
            && (self.shader_storage_image_extended_formats
                || !other.shader_storage_image_extended_formats)
            && (self.shader_storage_image_multisample || !other.shader_storage_image_multisample)
            && (self.shader_storage_image_read_without_format
                || !other.shader_storage_image_read_without_format)
            && (self.shader_storage_image_write_without_format
                || !other.shader_storage_image_write_without_format)
            && (self.shader_storage_texel_buffer_array_dynamic_indexing
                || !other.shader_storage_texel_buffer_array_dynamic_indexing)
            && (self.shader_storage_texel_buffer_array_non_uniform_indexing
                || !other.shader_storage_texel_buffer_array_non_uniform_indexing)
            && (self.shader_subgroup_clock || !other.shader_subgroup_clock)
            && (self.shader_subgroup_extended_types || !other.shader_subgroup_extended_types)
            && (self.shader_subgroup_uniform_control_flow
                || !other.shader_subgroup_uniform_control_flow)
            && (self.shader_terminate_invocation || !other.shader_terminate_invocation)
            && (self.shader_tessellation_and_geometry_point_size
                || !other.shader_tessellation_and_geometry_point_size)
            && (self.shader_uniform_buffer_array_dynamic_indexing
                || !other.shader_uniform_buffer_array_dynamic_indexing)
            && (self.shader_uniform_buffer_array_non_uniform_indexing
                || !other.shader_uniform_buffer_array_non_uniform_indexing)
            && (self.shader_uniform_texel_buffer_array_dynamic_indexing
                || !other.shader_uniform_texel_buffer_array_dynamic_indexing)
            && (self.shader_uniform_texel_buffer_array_non_uniform_indexing
                || !other.shader_uniform_texel_buffer_array_non_uniform_indexing)
            && (self.shader_zero_initialize_workgroup_memory
                || !other.shader_zero_initialize_workgroup_memory)
            && (self.shading_rate_coarse_sample_order || !other.shading_rate_coarse_sample_order)
            && (self.shading_rate_image || !other.shading_rate_image)
            && (self.smooth_lines || !other.smooth_lines)
            && (self.sparse_binding || !other.sparse_binding)
            && (self.sparse_image_float32_atomic_add || !other.sparse_image_float32_atomic_add)
            && (self.sparse_image_float32_atomic_min_max
                || !other.sparse_image_float32_atomic_min_max)
            && (self.sparse_image_float32_atomics || !other.sparse_image_float32_atomics)
            && (self.sparse_image_int64_atomics || !other.sparse_image_int64_atomics)
            && (self.sparse_residency16_samples || !other.sparse_residency16_samples)
            && (self.sparse_residency2_samples || !other.sparse_residency2_samples)
            && (self.sparse_residency4_samples || !other.sparse_residency4_samples)
            && (self.sparse_residency8_samples || !other.sparse_residency8_samples)
            && (self.sparse_residency_aliased || !other.sparse_residency_aliased)
            && (self.sparse_residency_buffer || !other.sparse_residency_buffer)
            && (self.sparse_residency_image2_d || !other.sparse_residency_image2_d)
            && (self.sparse_residency_image3_d || !other.sparse_residency_image3_d)
            && (self.stippled_bresenham_lines || !other.stippled_bresenham_lines)
            && (self.stippled_rectangular_lines || !other.stippled_rectangular_lines)
            && (self.stippled_smooth_lines || !other.stippled_smooth_lines)
            && (self.storage_buffer16_bit_access || !other.storage_buffer16_bit_access)
            && (self.storage_buffer8_bit_access || !other.storage_buffer8_bit_access)
            && (self.storage_input_output16 || !other.storage_input_output16)
            && (self.storage_push_constant16 || !other.storage_push_constant16)
            && (self.storage_push_constant8 || !other.storage_push_constant8)
            && (self.subgroup_broadcast_dynamic_id || !other.subgroup_broadcast_dynamic_id)
            && (self.subgroup_size_control || !other.subgroup_size_control)
            && (self.subpass_shading || !other.subpass_shading)
            && (self.supersample_fragment_shading_rates
                || !other.supersample_fragment_shading_rates)
            && (self.synchronization2 || !other.synchronization2)
            && (self.task_shader || !other.task_shader)
            && (self.tessellation_isolines || !other.tessellation_isolines)
            && (self.tessellation_point_mode || !other.tessellation_point_mode)
            && (self.tessellation_shader || !other.tessellation_shader)
            && (self.texel_buffer_alignment || !other.texel_buffer_alignment)
            && (self.texture_compression_astc_hdr || !other.texture_compression_astc_hdr)
            && (self.texture_compression_astc_ldr || !other.texture_compression_astc_ldr)
            && (self.texture_compression_bc || !other.texture_compression_bc)
            && (self.texture_compression_etc2 || !other.texture_compression_etc2)
            && (self.timeline_semaphore || !other.timeline_semaphore)
            && (self.transform_feedback || !other.transform_feedback)
            && (self.transform_feedback_preserves_provoking_vertex
                || !other.transform_feedback_preserves_provoking_vertex)
            && (self.triangle_fans || !other.triangle_fans)
            && (self.uniform_and_storage_buffer16_bit_access
                || !other.uniform_and_storage_buffer16_bit_access)
            && (self.uniform_and_storage_buffer8_bit_access
                || !other.uniform_and_storage_buffer8_bit_access)
            && (self.uniform_buffer_standard_layout || !other.uniform_buffer_standard_layout)
            && (self.variable_multisample_rate || !other.variable_multisample_rate)
            && (self.variable_pointers || !other.variable_pointers)
            && (self.variable_pointers_storage_buffer || !other.variable_pointers_storage_buffer)
            && (self.vertex_attribute_access_beyond_stride
                || !other.vertex_attribute_access_beyond_stride)
            && (self.vertex_attribute_instance_rate_divisor
                || !other.vertex_attribute_instance_rate_divisor)
            && (self.vertex_attribute_instance_rate_zero_divisor
                || !other.vertex_attribute_instance_rate_zero_divisor)
            && (self.vertex_input_dynamic_state || !other.vertex_input_dynamic_state)
            && (self.vertex_pipeline_stores_and_atomics
                || !other.vertex_pipeline_stores_and_atomics)
            && (self.vulkan_memory_model || !other.vulkan_memory_model)
            && (self.vulkan_memory_model_availability_visibility_chains
                || !other.vulkan_memory_model_availability_visibility_chains)
            && (self.vulkan_memory_model_device_scope || !other.vulkan_memory_model_device_scope)
            && (self.wide_lines || !other.wide_lines)
            && (self.workgroup_memory_explicit_layout || !other.workgroup_memory_explicit_layout)
            && (self.workgroup_memory_explicit_layout16_bit_access
                || !other.workgroup_memory_explicit_layout16_bit_access)
            && (self.workgroup_memory_explicit_layout8_bit_access
                || !other.workgroup_memory_explicit_layout8_bit_access)
            && (self.workgroup_memory_explicit_layout_scalar_block_layout
                || !other.workgroup_memory_explicit_layout_scalar_block_layout)
            && (self.ycbcr2plane444_formats || !other.ycbcr2plane444_formats)
            && (self.ycbcr_image_arrays || !other.ycbcr_image_arrays)
    }
    #[doc = r" Builds a `Features` that is the intersection of `self` and another `Features`"]
    #[doc = r" object."]
    #[doc = r""]
    #[doc = r" The result's field will be true if it is also true in both `self` and `other`."]
    pub const fn intersection(&self, other: &Features) -> Features {
        Features {
            acceleration_structure: self.acceleration_structure && other.acceleration_structure,
            acceleration_structure_capture_replay: self.acceleration_structure_capture_replay
                && other.acceleration_structure_capture_replay,
            acceleration_structure_host_commands: self.acceleration_structure_host_commands
                && other.acceleration_structure_host_commands,
            acceleration_structure_indirect_build: self.acceleration_structure_indirect_build
                && other.acceleration_structure_indirect_build,
            advanced_blend_coherent_operations: self.advanced_blend_coherent_operations
                && other.advanced_blend_coherent_operations,
            alpha_to_one: self.alpha_to_one && other.alpha_to_one,
            attachment_fragment_shading_rate: self.attachment_fragment_shading_rate
                && other.attachment_fragment_shading_rate,
            bresenham_lines: self.bresenham_lines && other.bresenham_lines,
            buffer_device_address: self.buffer_device_address && other.buffer_device_address,
            buffer_device_address_capture_replay: self.buffer_device_address_capture_replay
                && other.buffer_device_address_capture_replay,
            buffer_device_address_multi_device: self.buffer_device_address_multi_device
                && other.buffer_device_address_multi_device,
            color_write_enable: self.color_write_enable && other.color_write_enable,
            compute_derivative_group_linear: self.compute_derivative_group_linear
                && other.compute_derivative_group_linear,
            compute_derivative_group_quads: self.compute_derivative_group_quads
                && other.compute_derivative_group_quads,
            compute_full_subgroups: self.compute_full_subgroups && other.compute_full_subgroups,
            conditional_rendering: self.conditional_rendering && other.conditional_rendering,
            constant_alpha_color_blend_factors: self.constant_alpha_color_blend_factors
                && other.constant_alpha_color_blend_factors,
            cooperative_matrix: self.cooperative_matrix && other.cooperative_matrix,
            cooperative_matrix_robust_buffer_access: self.cooperative_matrix_robust_buffer_access
                && other.cooperative_matrix_robust_buffer_access,
            corner_sampled_image: self.corner_sampled_image && other.corner_sampled_image,
            coverage_reduction_mode: self.coverage_reduction_mode && other.coverage_reduction_mode,
            custom_border_color_without_format: self.custom_border_color_without_format
                && other.custom_border_color_without_format,
            custom_border_colors: self.custom_border_colors && other.custom_border_colors,
            decode_mode_shared_exponent: self.decode_mode_shared_exponent
                && other.decode_mode_shared_exponent,
            dedicated_allocation_image_aliasing: self.dedicated_allocation_image_aliasing
                && other.dedicated_allocation_image_aliasing,
            depth_bias_clamp: self.depth_bias_clamp && other.depth_bias_clamp,
            depth_bounds: self.depth_bounds && other.depth_bounds,
            depth_clamp: self.depth_clamp && other.depth_clamp,
            depth_clip_enable: self.depth_clip_enable && other.depth_clip_enable,
            descriptor_binding_acceleration_structure_update_after_bind: self
                .descriptor_binding_acceleration_structure_update_after_bind
                && other.descriptor_binding_acceleration_structure_update_after_bind,
            descriptor_binding_inline_uniform_block_update_after_bind: self
                .descriptor_binding_inline_uniform_block_update_after_bind
                && other.descriptor_binding_inline_uniform_block_update_after_bind,
            descriptor_binding_partially_bound: self.descriptor_binding_partially_bound
                && other.descriptor_binding_partially_bound,
            descriptor_binding_sampled_image_update_after_bind: self
                .descriptor_binding_sampled_image_update_after_bind
                && other.descriptor_binding_sampled_image_update_after_bind,
            descriptor_binding_storage_buffer_update_after_bind: self
                .descriptor_binding_storage_buffer_update_after_bind
                && other.descriptor_binding_storage_buffer_update_after_bind,
            descriptor_binding_storage_image_update_after_bind: self
                .descriptor_binding_storage_image_update_after_bind
                && other.descriptor_binding_storage_image_update_after_bind,
            descriptor_binding_storage_texel_buffer_update_after_bind: self
                .descriptor_binding_storage_texel_buffer_update_after_bind
                && other.descriptor_binding_storage_texel_buffer_update_after_bind,
            descriptor_binding_uniform_buffer_update_after_bind: self
                .descriptor_binding_uniform_buffer_update_after_bind
                && other.descriptor_binding_uniform_buffer_update_after_bind,
            descriptor_binding_uniform_texel_buffer_update_after_bind: self
                .descriptor_binding_uniform_texel_buffer_update_after_bind
                && other.descriptor_binding_uniform_texel_buffer_update_after_bind,
            descriptor_binding_update_unused_while_pending: self
                .descriptor_binding_update_unused_while_pending
                && other.descriptor_binding_update_unused_while_pending,
            descriptor_binding_variable_descriptor_count: self
                .descriptor_binding_variable_descriptor_count
                && other.descriptor_binding_variable_descriptor_count,
            descriptor_indexing: self.descriptor_indexing && other.descriptor_indexing,
            device_coherent_memory: self.device_coherent_memory && other.device_coherent_memory,
            device_generated_commands: self.device_generated_commands
                && other.device_generated_commands,
            device_memory_report: self.device_memory_report && other.device_memory_report,
            diagnostics_config: self.diagnostics_config && other.diagnostics_config,
            draw_indirect_count: self.draw_indirect_count && other.draw_indirect_count,
            draw_indirect_first_instance: self.draw_indirect_first_instance
                && other.draw_indirect_first_instance,
            dual_src_blend: self.dual_src_blend && other.dual_src_blend,
            events: self.events && other.events,
            exclusive_scissor: self.exclusive_scissor && other.exclusive_scissor,
            extended_dynamic_state: self.extended_dynamic_state && other.extended_dynamic_state,
            extended_dynamic_state2: self.extended_dynamic_state2 && other.extended_dynamic_state2,
            extended_dynamic_state2_logic_op: self.extended_dynamic_state2_logic_op
                && other.extended_dynamic_state2_logic_op,
            extended_dynamic_state2_patch_control_points: self
                .extended_dynamic_state2_patch_control_points
                && other.extended_dynamic_state2_patch_control_points,
            external_memory_rdma: self.external_memory_rdma && other.external_memory_rdma,
            fill_mode_non_solid: self.fill_mode_non_solid && other.fill_mode_non_solid,
            format_a4b4g4r4: self.format_a4b4g4r4 && other.format_a4b4g4r4,
            format_a4r4g4b4: self.format_a4r4g4b4 && other.format_a4r4g4b4,
            fragment_density_map: self.fragment_density_map && other.fragment_density_map,
            fragment_density_map_deferred: self.fragment_density_map_deferred
                && other.fragment_density_map_deferred,
            fragment_density_map_dynamic: self.fragment_density_map_dynamic
                && other.fragment_density_map_dynamic,
            fragment_density_map_non_subsampled_images: self
                .fragment_density_map_non_subsampled_images
                && other.fragment_density_map_non_subsampled_images,
            fragment_shader_barycentric: self.fragment_shader_barycentric
                && other.fragment_shader_barycentric,
            fragment_shader_pixel_interlock: self.fragment_shader_pixel_interlock
                && other.fragment_shader_pixel_interlock,
            fragment_shader_sample_interlock: self.fragment_shader_sample_interlock
                && other.fragment_shader_sample_interlock,
            fragment_shader_shading_rate_interlock: self.fragment_shader_shading_rate_interlock
                && other.fragment_shader_shading_rate_interlock,
            fragment_shading_rate_enums: self.fragment_shading_rate_enums
                && other.fragment_shading_rate_enums,
            fragment_stores_and_atomics: self.fragment_stores_and_atomics
                && other.fragment_stores_and_atomics,
            full_draw_index_uint32: self.full_draw_index_uint32 && other.full_draw_index_uint32,
            geometry_shader: self.geometry_shader && other.geometry_shader,
            geometry_streams: self.geometry_streams && other.geometry_streams,
            global_priority_query: self.global_priority_query && other.global_priority_query,
            host_query_reset: self.host_query_reset && other.host_query_reset,
            image_cube_array: self.image_cube_array && other.image_cube_array,
            image_footprint: self.image_footprint && other.image_footprint,
            image_view2_d_on3_d_image: self.image_view2_d_on3_d_image
                && other.image_view2_d_on3_d_image,
            image_view_format_reinterpretation: self.image_view_format_reinterpretation
                && other.image_view_format_reinterpretation,
            image_view_format_swizzle: self.image_view_format_swizzle
                && other.image_view_format_swizzle,
            imageless_framebuffer: self.imageless_framebuffer && other.imageless_framebuffer,
            independent_blend: self.independent_blend && other.independent_blend,
            index_type_uint8: self.index_type_uint8 && other.index_type_uint8,
            inherited_conditional_rendering: self.inherited_conditional_rendering
                && other.inherited_conditional_rendering,
            inherited_queries: self.inherited_queries && other.inherited_queries,
            inherited_viewport_scissor2_d: self.inherited_viewport_scissor2_d
                && other.inherited_viewport_scissor2_d,
            inline_uniform_block: self.inline_uniform_block && other.inline_uniform_block,
            invocation_mask: self.invocation_mask && other.invocation_mask,
            large_points: self.large_points && other.large_points,
            logic_op: self.logic_op && other.logic_op,
            memory_priority: self.memory_priority && other.memory_priority,
            mesh_shader: self.mesh_shader && other.mesh_shader,
            multi_draw: self.multi_draw && other.multi_draw,
            multi_draw_indirect: self.multi_draw_indirect && other.multi_draw_indirect,
            multi_viewport: self.multi_viewport && other.multi_viewport,
            multisample_array_image: self.multisample_array_image && other.multisample_array_image,
            multiview: self.multiview && other.multiview,
            multiview_geometry_shader: self.multiview_geometry_shader
                && other.multiview_geometry_shader,
            multiview_tessellation_shader: self.multiview_tessellation_shader
                && other.multiview_tessellation_shader,
            mutable_comparison_samplers: self.mutable_comparison_samplers
                && other.mutable_comparison_samplers,
            mutable_descriptor_type: self.mutable_descriptor_type && other.mutable_descriptor_type,
            no_invocation_fragment_shading_rates: self.no_invocation_fragment_shading_rates
                && other.no_invocation_fragment_shading_rates,
            null_descriptor: self.null_descriptor && other.null_descriptor,
            occlusion_query_precise: self.occlusion_query_precise && other.occlusion_query_precise,
            pageable_device_local_memory: self.pageable_device_local_memory
                && other.pageable_device_local_memory,
            performance_counter_multiple_query_pools: self.performance_counter_multiple_query_pools
                && other.performance_counter_multiple_query_pools,
            performance_counter_query_pools: self.performance_counter_query_pools
                && other.performance_counter_query_pools,
            pipeline_creation_cache_control: self.pipeline_creation_cache_control
                && other.pipeline_creation_cache_control,
            pipeline_executable_info: self.pipeline_executable_info
                && other.pipeline_executable_info,
            pipeline_fragment_shading_rate: self.pipeline_fragment_shading_rate
                && other.pipeline_fragment_shading_rate,
            pipeline_statistics_query: self.pipeline_statistics_query
                && other.pipeline_statistics_query,
            point_polygons: self.point_polygons && other.point_polygons,
            present_id: self.present_id && other.present_id,
            present_wait: self.present_wait && other.present_wait,
            primitive_fragment_shading_rate: self.primitive_fragment_shading_rate
                && other.primitive_fragment_shading_rate,
            primitive_topology_list_restart: self.primitive_topology_list_restart
                && other.primitive_topology_list_restart,
            primitive_topology_patch_list_restart: self.primitive_topology_patch_list_restart
                && other.primitive_topology_patch_list_restart,
            private_data: self.private_data && other.private_data,
            protected_memory: self.protected_memory && other.protected_memory,
            provoking_vertex_last: self.provoking_vertex_last && other.provoking_vertex_last,
            ray_query: self.ray_query && other.ray_query,
            ray_tracing_motion_blur: self.ray_tracing_motion_blur && other.ray_tracing_motion_blur,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: self
                .ray_tracing_motion_blur_pipeline_trace_rays_indirect
                && other.ray_tracing_motion_blur_pipeline_trace_rays_indirect,
            ray_tracing_pipeline: self.ray_tracing_pipeline && other.ray_tracing_pipeline,
            ray_tracing_pipeline_shader_group_handle_capture_replay: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay
                && other.ray_tracing_pipeline_shader_group_handle_capture_replay,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                && other.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed,
            ray_tracing_pipeline_trace_rays_indirect: self.ray_tracing_pipeline_trace_rays_indirect
                && other.ray_tracing_pipeline_trace_rays_indirect,
            ray_traversal_primitive_culling: self.ray_traversal_primitive_culling
                && other.ray_traversal_primitive_culling,
            rectangular_lines: self.rectangular_lines && other.rectangular_lines,
            representative_fragment_test: self.representative_fragment_test
                && other.representative_fragment_test,
            robust_buffer_access: self.robust_buffer_access && other.robust_buffer_access,
            robust_buffer_access2: self.robust_buffer_access2 && other.robust_buffer_access2,
            robust_image_access: self.robust_image_access && other.robust_image_access,
            robust_image_access2: self.robust_image_access2 && other.robust_image_access2,
            runtime_descriptor_array: self.runtime_descriptor_array
                && other.runtime_descriptor_array,
            sample_rate_shading: self.sample_rate_shading && other.sample_rate_shading,
            sampler_anisotropy: self.sampler_anisotropy && other.sampler_anisotropy,
            sampler_filter_minmax: self.sampler_filter_minmax && other.sampler_filter_minmax,
            sampler_mip_lod_bias: self.sampler_mip_lod_bias && other.sampler_mip_lod_bias,
            sampler_mirror_clamp_to_edge: self.sampler_mirror_clamp_to_edge
                && other.sampler_mirror_clamp_to_edge,
            sampler_ycbcr_conversion: self.sampler_ycbcr_conversion
                && other.sampler_ycbcr_conversion,
            scalar_block_layout: self.scalar_block_layout && other.scalar_block_layout,
            separate_depth_stencil_layouts: self.separate_depth_stencil_layouts
                && other.separate_depth_stencil_layouts,
            separate_stencil_mask_ref: self.separate_stencil_mask_ref
                && other.separate_stencil_mask_ref,
            shader_buffer_float16_atomic_add: self.shader_buffer_float16_atomic_add
                && other.shader_buffer_float16_atomic_add,
            shader_buffer_float16_atomic_min_max: self.shader_buffer_float16_atomic_min_max
                && other.shader_buffer_float16_atomic_min_max,
            shader_buffer_float16_atomics: self.shader_buffer_float16_atomics
                && other.shader_buffer_float16_atomics,
            shader_buffer_float32_atomic_add: self.shader_buffer_float32_atomic_add
                && other.shader_buffer_float32_atomic_add,
            shader_buffer_float32_atomic_min_max: self.shader_buffer_float32_atomic_min_max
                && other.shader_buffer_float32_atomic_min_max,
            shader_buffer_float32_atomics: self.shader_buffer_float32_atomics
                && other.shader_buffer_float32_atomics,
            shader_buffer_float64_atomic_add: self.shader_buffer_float64_atomic_add
                && other.shader_buffer_float64_atomic_add,
            shader_buffer_float64_atomic_min_max: self.shader_buffer_float64_atomic_min_max
                && other.shader_buffer_float64_atomic_min_max,
            shader_buffer_float64_atomics: self.shader_buffer_float64_atomics
                && other.shader_buffer_float64_atomics,
            shader_buffer_int64_atomics: self.shader_buffer_int64_atomics
                && other.shader_buffer_int64_atomics,
            shader_clip_distance: self.shader_clip_distance && other.shader_clip_distance,
            shader_cull_distance: self.shader_cull_distance && other.shader_cull_distance,
            shader_demote_to_helper_invocation: self.shader_demote_to_helper_invocation
                && other.shader_demote_to_helper_invocation,
            shader_device_clock: self.shader_device_clock && other.shader_device_clock,
            shader_draw_parameters: self.shader_draw_parameters && other.shader_draw_parameters,
            shader_float16: self.shader_float16 && other.shader_float16,
            shader_float64: self.shader_float64 && other.shader_float64,
            shader_image_float32_atomic_add: self.shader_image_float32_atomic_add
                && other.shader_image_float32_atomic_add,
            shader_image_float32_atomic_min_max: self.shader_image_float32_atomic_min_max
                && other.shader_image_float32_atomic_min_max,
            shader_image_float32_atomics: self.shader_image_float32_atomics
                && other.shader_image_float32_atomics,
            shader_image_gather_extended: self.shader_image_gather_extended
                && other.shader_image_gather_extended,
            shader_image_int64_atomics: self.shader_image_int64_atomics
                && other.shader_image_int64_atomics,
            shader_input_attachment_array_dynamic_indexing: self
                .shader_input_attachment_array_dynamic_indexing
                && other.shader_input_attachment_array_dynamic_indexing,
            shader_input_attachment_array_non_uniform_indexing: self
                .shader_input_attachment_array_non_uniform_indexing
                && other.shader_input_attachment_array_non_uniform_indexing,
            shader_int16: self.shader_int16 && other.shader_int16,
            shader_int64: self.shader_int64 && other.shader_int64,
            shader_int8: self.shader_int8 && other.shader_int8,
            shader_integer_dot_product: self.shader_integer_dot_product
                && other.shader_integer_dot_product,
            shader_integer_functions2: self.shader_integer_functions2
                && other.shader_integer_functions2,
            shader_output_layer: self.shader_output_layer && other.shader_output_layer,
            shader_output_viewport_index: self.shader_output_viewport_index
                && other.shader_output_viewport_index,
            shader_resource_min_lod: self.shader_resource_min_lod && other.shader_resource_min_lod,
            shader_resource_residency: self.shader_resource_residency
                && other.shader_resource_residency,
            shader_sample_rate_interpolation_functions: self
                .shader_sample_rate_interpolation_functions
                && other.shader_sample_rate_interpolation_functions,
            shader_sampled_image_array_dynamic_indexing: self
                .shader_sampled_image_array_dynamic_indexing
                && other.shader_sampled_image_array_dynamic_indexing,
            shader_sampled_image_array_non_uniform_indexing: self
                .shader_sampled_image_array_non_uniform_indexing
                && other.shader_sampled_image_array_non_uniform_indexing,
            shader_shared_float16_atomic_add: self.shader_shared_float16_atomic_add
                && other.shader_shared_float16_atomic_add,
            shader_shared_float16_atomic_min_max: self.shader_shared_float16_atomic_min_max
                && other.shader_shared_float16_atomic_min_max,
            shader_shared_float16_atomics: self.shader_shared_float16_atomics
                && other.shader_shared_float16_atomics,
            shader_shared_float32_atomic_add: self.shader_shared_float32_atomic_add
                && other.shader_shared_float32_atomic_add,
            shader_shared_float32_atomic_min_max: self.shader_shared_float32_atomic_min_max
                && other.shader_shared_float32_atomic_min_max,
            shader_shared_float32_atomics: self.shader_shared_float32_atomics
                && other.shader_shared_float32_atomics,
            shader_shared_float64_atomic_add: self.shader_shared_float64_atomic_add
                && other.shader_shared_float64_atomic_add,
            shader_shared_float64_atomic_min_max: self.shader_shared_float64_atomic_min_max
                && other.shader_shared_float64_atomic_min_max,
            shader_shared_float64_atomics: self.shader_shared_float64_atomics
                && other.shader_shared_float64_atomics,
            shader_shared_int64_atomics: self.shader_shared_int64_atomics
                && other.shader_shared_int64_atomics,
            shader_sm_builtins: self.shader_sm_builtins && other.shader_sm_builtins,
            shader_storage_buffer_array_dynamic_indexing: self
                .shader_storage_buffer_array_dynamic_indexing
                && other.shader_storage_buffer_array_dynamic_indexing,
            shader_storage_buffer_array_non_uniform_indexing: self
                .shader_storage_buffer_array_non_uniform_indexing
                && other.shader_storage_buffer_array_non_uniform_indexing,
            shader_storage_image_array_dynamic_indexing: self
                .shader_storage_image_array_dynamic_indexing
                && other.shader_storage_image_array_dynamic_indexing,
            shader_storage_image_array_non_uniform_indexing: self
                .shader_storage_image_array_non_uniform_indexing
                && other.shader_storage_image_array_non_uniform_indexing,
            shader_storage_image_extended_formats: self.shader_storage_image_extended_formats
                && other.shader_storage_image_extended_formats,
            shader_storage_image_multisample: self.shader_storage_image_multisample
                && other.shader_storage_image_multisample,
            shader_storage_image_read_without_format: self.shader_storage_image_read_without_format
                && other.shader_storage_image_read_without_format,
            shader_storage_image_write_without_format: self
                .shader_storage_image_write_without_format
                && other.shader_storage_image_write_without_format,
            shader_storage_texel_buffer_array_dynamic_indexing: self
                .shader_storage_texel_buffer_array_dynamic_indexing
                && other.shader_storage_texel_buffer_array_dynamic_indexing,
            shader_storage_texel_buffer_array_non_uniform_indexing: self
                .shader_storage_texel_buffer_array_non_uniform_indexing
                && other.shader_storage_texel_buffer_array_non_uniform_indexing,
            shader_subgroup_clock: self.shader_subgroup_clock && other.shader_subgroup_clock,
            shader_subgroup_extended_types: self.shader_subgroup_extended_types
                && other.shader_subgroup_extended_types,
            shader_subgroup_uniform_control_flow: self.shader_subgroup_uniform_control_flow
                && other.shader_subgroup_uniform_control_flow,
            shader_terminate_invocation: self.shader_terminate_invocation
                && other.shader_terminate_invocation,
            shader_tessellation_and_geometry_point_size: self
                .shader_tessellation_and_geometry_point_size
                && other.shader_tessellation_and_geometry_point_size,
            shader_uniform_buffer_array_dynamic_indexing: self
                .shader_uniform_buffer_array_dynamic_indexing
                && other.shader_uniform_buffer_array_dynamic_indexing,
            shader_uniform_buffer_array_non_uniform_indexing: self
                .shader_uniform_buffer_array_non_uniform_indexing
                && other.shader_uniform_buffer_array_non_uniform_indexing,
            shader_uniform_texel_buffer_array_dynamic_indexing: self
                .shader_uniform_texel_buffer_array_dynamic_indexing
                && other.shader_uniform_texel_buffer_array_dynamic_indexing,
            shader_uniform_texel_buffer_array_non_uniform_indexing: self
                .shader_uniform_texel_buffer_array_non_uniform_indexing
                && other.shader_uniform_texel_buffer_array_non_uniform_indexing,
            shader_zero_initialize_workgroup_memory: self.shader_zero_initialize_workgroup_memory
                && other.shader_zero_initialize_workgroup_memory,
            shading_rate_coarse_sample_order: self.shading_rate_coarse_sample_order
                && other.shading_rate_coarse_sample_order,
            shading_rate_image: self.shading_rate_image && other.shading_rate_image,
            smooth_lines: self.smooth_lines && other.smooth_lines,
            sparse_binding: self.sparse_binding && other.sparse_binding,
            sparse_image_float32_atomic_add: self.sparse_image_float32_atomic_add
                && other.sparse_image_float32_atomic_add,
            sparse_image_float32_atomic_min_max: self.sparse_image_float32_atomic_min_max
                && other.sparse_image_float32_atomic_min_max,
            sparse_image_float32_atomics: self.sparse_image_float32_atomics
                && other.sparse_image_float32_atomics,
            sparse_image_int64_atomics: self.sparse_image_int64_atomics
                && other.sparse_image_int64_atomics,
            sparse_residency16_samples: self.sparse_residency16_samples
                && other.sparse_residency16_samples,
            sparse_residency2_samples: self.sparse_residency2_samples
                && other.sparse_residency2_samples,
            sparse_residency4_samples: self.sparse_residency4_samples
                && other.sparse_residency4_samples,
            sparse_residency8_samples: self.sparse_residency8_samples
                && other.sparse_residency8_samples,
            sparse_residency_aliased: self.sparse_residency_aliased
                && other.sparse_residency_aliased,
            sparse_residency_buffer: self.sparse_residency_buffer && other.sparse_residency_buffer,
            sparse_residency_image2_d: self.sparse_residency_image2_d
                && other.sparse_residency_image2_d,
            sparse_residency_image3_d: self.sparse_residency_image3_d
                && other.sparse_residency_image3_d,
            stippled_bresenham_lines: self.stippled_bresenham_lines
                && other.stippled_bresenham_lines,
            stippled_rectangular_lines: self.stippled_rectangular_lines
                && other.stippled_rectangular_lines,
            stippled_smooth_lines: self.stippled_smooth_lines && other.stippled_smooth_lines,
            storage_buffer16_bit_access: self.storage_buffer16_bit_access
                && other.storage_buffer16_bit_access,
            storage_buffer8_bit_access: self.storage_buffer8_bit_access
                && other.storage_buffer8_bit_access,
            storage_input_output16: self.storage_input_output16 && other.storage_input_output16,
            storage_push_constant16: self.storage_push_constant16 && other.storage_push_constant16,
            storage_push_constant8: self.storage_push_constant8 && other.storage_push_constant8,
            subgroup_broadcast_dynamic_id: self.subgroup_broadcast_dynamic_id
                && other.subgroup_broadcast_dynamic_id,
            subgroup_size_control: self.subgroup_size_control && other.subgroup_size_control,
            subpass_shading: self.subpass_shading && other.subpass_shading,
            supersample_fragment_shading_rates: self.supersample_fragment_shading_rates
                && other.supersample_fragment_shading_rates,
            synchronization2: self.synchronization2 && other.synchronization2,
            task_shader: self.task_shader && other.task_shader,
            tessellation_isolines: self.tessellation_isolines && other.tessellation_isolines,
            tessellation_point_mode: self.tessellation_point_mode && other.tessellation_point_mode,
            tessellation_shader: self.tessellation_shader && other.tessellation_shader,
            texel_buffer_alignment: self.texel_buffer_alignment && other.texel_buffer_alignment,
            texture_compression_astc_hdr: self.texture_compression_astc_hdr
                && other.texture_compression_astc_hdr,
            texture_compression_astc_ldr: self.texture_compression_astc_ldr
                && other.texture_compression_astc_ldr,
            texture_compression_bc: self.texture_compression_bc && other.texture_compression_bc,
            texture_compression_etc2: self.texture_compression_etc2
                && other.texture_compression_etc2,
            timeline_semaphore: self.timeline_semaphore && other.timeline_semaphore,
            transform_feedback: self.transform_feedback && other.transform_feedback,
            transform_feedback_preserves_provoking_vertex: self
                .transform_feedback_preserves_provoking_vertex
                && other.transform_feedback_preserves_provoking_vertex,
            triangle_fans: self.triangle_fans && other.triangle_fans,
            uniform_and_storage_buffer16_bit_access: self.uniform_and_storage_buffer16_bit_access
                && other.uniform_and_storage_buffer16_bit_access,
            uniform_and_storage_buffer8_bit_access: self.uniform_and_storage_buffer8_bit_access
                && other.uniform_and_storage_buffer8_bit_access,
            uniform_buffer_standard_layout: self.uniform_buffer_standard_layout
                && other.uniform_buffer_standard_layout,
            variable_multisample_rate: self.variable_multisample_rate
                && other.variable_multisample_rate,
            variable_pointers: self.variable_pointers && other.variable_pointers,
            variable_pointers_storage_buffer: self.variable_pointers_storage_buffer
                && other.variable_pointers_storage_buffer,
            vertex_attribute_access_beyond_stride: self.vertex_attribute_access_beyond_stride
                && other.vertex_attribute_access_beyond_stride,
            vertex_attribute_instance_rate_divisor: self.vertex_attribute_instance_rate_divisor
                && other.vertex_attribute_instance_rate_divisor,
            vertex_attribute_instance_rate_zero_divisor: self
                .vertex_attribute_instance_rate_zero_divisor
                && other.vertex_attribute_instance_rate_zero_divisor,
            vertex_input_dynamic_state: self.vertex_input_dynamic_state
                && other.vertex_input_dynamic_state,
            vertex_pipeline_stores_and_atomics: self.vertex_pipeline_stores_and_atomics
                && other.vertex_pipeline_stores_and_atomics,
            vulkan_memory_model: self.vulkan_memory_model && other.vulkan_memory_model,
            vulkan_memory_model_availability_visibility_chains: self
                .vulkan_memory_model_availability_visibility_chains
                && other.vulkan_memory_model_availability_visibility_chains,
            vulkan_memory_model_device_scope: self.vulkan_memory_model_device_scope
                && other.vulkan_memory_model_device_scope,
            wide_lines: self.wide_lines && other.wide_lines,
            workgroup_memory_explicit_layout: self.workgroup_memory_explicit_layout
                && other.workgroup_memory_explicit_layout,
            workgroup_memory_explicit_layout16_bit_access: self
                .workgroup_memory_explicit_layout16_bit_access
                && other.workgroup_memory_explicit_layout16_bit_access,
            workgroup_memory_explicit_layout8_bit_access: self
                .workgroup_memory_explicit_layout8_bit_access
                && other.workgroup_memory_explicit_layout8_bit_access,
            workgroup_memory_explicit_layout_scalar_block_layout: self
                .workgroup_memory_explicit_layout_scalar_block_layout
                && other.workgroup_memory_explicit_layout_scalar_block_layout,
            ycbcr2plane444_formats: self.ycbcr2plane444_formats && other.ycbcr2plane444_formats,
            ycbcr_image_arrays: self.ycbcr_image_arrays && other.ycbcr_image_arrays,
        }
    }
    #[doc = r" Builds a `Features` that is the difference of another `Features` object from `self`."]
    #[doc = r""]
    #[doc = r" The result's field will be true if it is true in `self` but not `other`."]
    pub const fn difference(&self, other: &Features) -> Features {
        Features {
            acceleration_structure: self.acceleration_structure && !other.acceleration_structure,
            acceleration_structure_capture_replay: self.acceleration_structure_capture_replay
                && !other.acceleration_structure_capture_replay,
            acceleration_structure_host_commands: self.acceleration_structure_host_commands
                && !other.acceleration_structure_host_commands,
            acceleration_structure_indirect_build: self.acceleration_structure_indirect_build
                && !other.acceleration_structure_indirect_build,
            advanced_blend_coherent_operations: self.advanced_blend_coherent_operations
                && !other.advanced_blend_coherent_operations,
            alpha_to_one: self.alpha_to_one && !other.alpha_to_one,
            attachment_fragment_shading_rate: self.attachment_fragment_shading_rate
                && !other.attachment_fragment_shading_rate,
            bresenham_lines: self.bresenham_lines && !other.bresenham_lines,
            buffer_device_address: self.buffer_device_address && !other.buffer_device_address,
            buffer_device_address_capture_replay: self.buffer_device_address_capture_replay
                && !other.buffer_device_address_capture_replay,
            buffer_device_address_multi_device: self.buffer_device_address_multi_device
                && !other.buffer_device_address_multi_device,
            color_write_enable: self.color_write_enable && !other.color_write_enable,
            compute_derivative_group_linear: self.compute_derivative_group_linear
                && !other.compute_derivative_group_linear,
            compute_derivative_group_quads: self.compute_derivative_group_quads
                && !other.compute_derivative_group_quads,
            compute_full_subgroups: self.compute_full_subgroups && !other.compute_full_subgroups,
            conditional_rendering: self.conditional_rendering && !other.conditional_rendering,
            constant_alpha_color_blend_factors: self.constant_alpha_color_blend_factors
                && !other.constant_alpha_color_blend_factors,
            cooperative_matrix: self.cooperative_matrix && !other.cooperative_matrix,
            cooperative_matrix_robust_buffer_access: self.cooperative_matrix_robust_buffer_access
                && !other.cooperative_matrix_robust_buffer_access,
            corner_sampled_image: self.corner_sampled_image && !other.corner_sampled_image,
            coverage_reduction_mode: self.coverage_reduction_mode && !other.coverage_reduction_mode,
            custom_border_color_without_format: self.custom_border_color_without_format
                && !other.custom_border_color_without_format,
            custom_border_colors: self.custom_border_colors && !other.custom_border_colors,
            decode_mode_shared_exponent: self.decode_mode_shared_exponent
                && !other.decode_mode_shared_exponent,
            dedicated_allocation_image_aliasing: self.dedicated_allocation_image_aliasing
                && !other.dedicated_allocation_image_aliasing,
            depth_bias_clamp: self.depth_bias_clamp && !other.depth_bias_clamp,
            depth_bounds: self.depth_bounds && !other.depth_bounds,
            depth_clamp: self.depth_clamp && !other.depth_clamp,
            depth_clip_enable: self.depth_clip_enable && !other.depth_clip_enable,
            descriptor_binding_acceleration_structure_update_after_bind: self
                .descriptor_binding_acceleration_structure_update_after_bind
                && !other.descriptor_binding_acceleration_structure_update_after_bind,
            descriptor_binding_inline_uniform_block_update_after_bind: self
                .descriptor_binding_inline_uniform_block_update_after_bind
                && !other.descriptor_binding_inline_uniform_block_update_after_bind,
            descriptor_binding_partially_bound: self.descriptor_binding_partially_bound
                && !other.descriptor_binding_partially_bound,
            descriptor_binding_sampled_image_update_after_bind: self
                .descriptor_binding_sampled_image_update_after_bind
                && !other.descriptor_binding_sampled_image_update_after_bind,
            descriptor_binding_storage_buffer_update_after_bind: self
                .descriptor_binding_storage_buffer_update_after_bind
                && !other.descriptor_binding_storage_buffer_update_after_bind,
            descriptor_binding_storage_image_update_after_bind: self
                .descriptor_binding_storage_image_update_after_bind
                && !other.descriptor_binding_storage_image_update_after_bind,
            descriptor_binding_storage_texel_buffer_update_after_bind: self
                .descriptor_binding_storage_texel_buffer_update_after_bind
                && !other.descriptor_binding_storage_texel_buffer_update_after_bind,
            descriptor_binding_uniform_buffer_update_after_bind: self
                .descriptor_binding_uniform_buffer_update_after_bind
                && !other.descriptor_binding_uniform_buffer_update_after_bind,
            descriptor_binding_uniform_texel_buffer_update_after_bind: self
                .descriptor_binding_uniform_texel_buffer_update_after_bind
                && !other.descriptor_binding_uniform_texel_buffer_update_after_bind,
            descriptor_binding_update_unused_while_pending: self
                .descriptor_binding_update_unused_while_pending
                && !other.descriptor_binding_update_unused_while_pending,
            descriptor_binding_variable_descriptor_count: self
                .descriptor_binding_variable_descriptor_count
                && !other.descriptor_binding_variable_descriptor_count,
            descriptor_indexing: self.descriptor_indexing && !other.descriptor_indexing,
            device_coherent_memory: self.device_coherent_memory && !other.device_coherent_memory,
            device_generated_commands: self.device_generated_commands
                && !other.device_generated_commands,
            device_memory_report: self.device_memory_report && !other.device_memory_report,
            diagnostics_config: self.diagnostics_config && !other.diagnostics_config,
            draw_indirect_count: self.draw_indirect_count && !other.draw_indirect_count,
            draw_indirect_first_instance: self.draw_indirect_first_instance
                && !other.draw_indirect_first_instance,
            dual_src_blend: self.dual_src_blend && !other.dual_src_blend,
            events: self.events && !other.events,
            exclusive_scissor: self.exclusive_scissor && !other.exclusive_scissor,
            extended_dynamic_state: self.extended_dynamic_state && !other.extended_dynamic_state,
            extended_dynamic_state2: self.extended_dynamic_state2 && !other.extended_dynamic_state2,
            extended_dynamic_state2_logic_op: self.extended_dynamic_state2_logic_op
                && !other.extended_dynamic_state2_logic_op,
            extended_dynamic_state2_patch_control_points: self
                .extended_dynamic_state2_patch_control_points
                && !other.extended_dynamic_state2_patch_control_points,
            external_memory_rdma: self.external_memory_rdma && !other.external_memory_rdma,
            fill_mode_non_solid: self.fill_mode_non_solid && !other.fill_mode_non_solid,
            format_a4b4g4r4: self.format_a4b4g4r4 && !other.format_a4b4g4r4,
            format_a4r4g4b4: self.format_a4r4g4b4 && !other.format_a4r4g4b4,
            fragment_density_map: self.fragment_density_map && !other.fragment_density_map,
            fragment_density_map_deferred: self.fragment_density_map_deferred
                && !other.fragment_density_map_deferred,
            fragment_density_map_dynamic: self.fragment_density_map_dynamic
                && !other.fragment_density_map_dynamic,
            fragment_density_map_non_subsampled_images: self
                .fragment_density_map_non_subsampled_images
                && !other.fragment_density_map_non_subsampled_images,
            fragment_shader_barycentric: self.fragment_shader_barycentric
                && !other.fragment_shader_barycentric,
            fragment_shader_pixel_interlock: self.fragment_shader_pixel_interlock
                && !other.fragment_shader_pixel_interlock,
            fragment_shader_sample_interlock: self.fragment_shader_sample_interlock
                && !other.fragment_shader_sample_interlock,
            fragment_shader_shading_rate_interlock: self.fragment_shader_shading_rate_interlock
                && !other.fragment_shader_shading_rate_interlock,
            fragment_shading_rate_enums: self.fragment_shading_rate_enums
                && !other.fragment_shading_rate_enums,
            fragment_stores_and_atomics: self.fragment_stores_and_atomics
                && !other.fragment_stores_and_atomics,
            full_draw_index_uint32: self.full_draw_index_uint32 && !other.full_draw_index_uint32,
            geometry_shader: self.geometry_shader && !other.geometry_shader,
            geometry_streams: self.geometry_streams && !other.geometry_streams,
            global_priority_query: self.global_priority_query && !other.global_priority_query,
            host_query_reset: self.host_query_reset && !other.host_query_reset,
            image_cube_array: self.image_cube_array && !other.image_cube_array,
            image_footprint: self.image_footprint && !other.image_footprint,
            image_view2_d_on3_d_image: self.image_view2_d_on3_d_image
                && !other.image_view2_d_on3_d_image,
            image_view_format_reinterpretation: self.image_view_format_reinterpretation
                && !other.image_view_format_reinterpretation,
            image_view_format_swizzle: self.image_view_format_swizzle
                && !other.image_view_format_swizzle,
            imageless_framebuffer: self.imageless_framebuffer && !other.imageless_framebuffer,
            independent_blend: self.independent_blend && !other.independent_blend,
            index_type_uint8: self.index_type_uint8 && !other.index_type_uint8,
            inherited_conditional_rendering: self.inherited_conditional_rendering
                && !other.inherited_conditional_rendering,
            inherited_queries: self.inherited_queries && !other.inherited_queries,
            inherited_viewport_scissor2_d: self.inherited_viewport_scissor2_d
                && !other.inherited_viewport_scissor2_d,
            inline_uniform_block: self.inline_uniform_block && !other.inline_uniform_block,
            invocation_mask: self.invocation_mask && !other.invocation_mask,
            large_points: self.large_points && !other.large_points,
            logic_op: self.logic_op && !other.logic_op,
            memory_priority: self.memory_priority && !other.memory_priority,
            mesh_shader: self.mesh_shader && !other.mesh_shader,
            multi_draw: self.multi_draw && !other.multi_draw,
            multi_draw_indirect: self.multi_draw_indirect && !other.multi_draw_indirect,
            multi_viewport: self.multi_viewport && !other.multi_viewport,
            multisample_array_image: self.multisample_array_image && !other.multisample_array_image,
            multiview: self.multiview && !other.multiview,
            multiview_geometry_shader: self.multiview_geometry_shader
                && !other.multiview_geometry_shader,
            multiview_tessellation_shader: self.multiview_tessellation_shader
                && !other.multiview_tessellation_shader,
            mutable_comparison_samplers: self.mutable_comparison_samplers
                && !other.mutable_comparison_samplers,
            mutable_descriptor_type: self.mutable_descriptor_type && !other.mutable_descriptor_type,
            no_invocation_fragment_shading_rates: self.no_invocation_fragment_shading_rates
                && !other.no_invocation_fragment_shading_rates,
            null_descriptor: self.null_descriptor && !other.null_descriptor,
            occlusion_query_precise: self.occlusion_query_precise && !other.occlusion_query_precise,
            pageable_device_local_memory: self.pageable_device_local_memory
                && !other.pageable_device_local_memory,
            performance_counter_multiple_query_pools: self.performance_counter_multiple_query_pools
                && !other.performance_counter_multiple_query_pools,
            performance_counter_query_pools: self.performance_counter_query_pools
                && !other.performance_counter_query_pools,
            pipeline_creation_cache_control: self.pipeline_creation_cache_control
                && !other.pipeline_creation_cache_control,
            pipeline_executable_info: self.pipeline_executable_info
                && !other.pipeline_executable_info,
            pipeline_fragment_shading_rate: self.pipeline_fragment_shading_rate
                && !other.pipeline_fragment_shading_rate,
            pipeline_statistics_query: self.pipeline_statistics_query
                && !other.pipeline_statistics_query,
            point_polygons: self.point_polygons && !other.point_polygons,
            present_id: self.present_id && !other.present_id,
            present_wait: self.present_wait && !other.present_wait,
            primitive_fragment_shading_rate: self.primitive_fragment_shading_rate
                && !other.primitive_fragment_shading_rate,
            primitive_topology_list_restart: self.primitive_topology_list_restart
                && !other.primitive_topology_list_restart,
            primitive_topology_patch_list_restart: self.primitive_topology_patch_list_restart
                && !other.primitive_topology_patch_list_restart,
            private_data: self.private_data && !other.private_data,
            protected_memory: self.protected_memory && !other.protected_memory,
            provoking_vertex_last: self.provoking_vertex_last && !other.provoking_vertex_last,
            ray_query: self.ray_query && !other.ray_query,
            ray_tracing_motion_blur: self.ray_tracing_motion_blur && !other.ray_tracing_motion_blur,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: self
                .ray_tracing_motion_blur_pipeline_trace_rays_indirect
                && !other.ray_tracing_motion_blur_pipeline_trace_rays_indirect,
            ray_tracing_pipeline: self.ray_tracing_pipeline && !other.ray_tracing_pipeline,
            ray_tracing_pipeline_shader_group_handle_capture_replay: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay
                && !other.ray_tracing_pipeline_shader_group_handle_capture_replay,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed: self
                .ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                && !other.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed,
            ray_tracing_pipeline_trace_rays_indirect: self.ray_tracing_pipeline_trace_rays_indirect
                && !other.ray_tracing_pipeline_trace_rays_indirect,
            ray_traversal_primitive_culling: self.ray_traversal_primitive_culling
                && !other.ray_traversal_primitive_culling,
            rectangular_lines: self.rectangular_lines && !other.rectangular_lines,
            representative_fragment_test: self.representative_fragment_test
                && !other.representative_fragment_test,
            robust_buffer_access: self.robust_buffer_access && !other.robust_buffer_access,
            robust_buffer_access2: self.robust_buffer_access2 && !other.robust_buffer_access2,
            robust_image_access: self.robust_image_access && !other.robust_image_access,
            robust_image_access2: self.robust_image_access2 && !other.robust_image_access2,
            runtime_descriptor_array: self.runtime_descriptor_array
                && !other.runtime_descriptor_array,
            sample_rate_shading: self.sample_rate_shading && !other.sample_rate_shading,
            sampler_anisotropy: self.sampler_anisotropy && !other.sampler_anisotropy,
            sampler_filter_minmax: self.sampler_filter_minmax && !other.sampler_filter_minmax,
            sampler_mip_lod_bias: self.sampler_mip_lod_bias && !other.sampler_mip_lod_bias,
            sampler_mirror_clamp_to_edge: self.sampler_mirror_clamp_to_edge
                && !other.sampler_mirror_clamp_to_edge,
            sampler_ycbcr_conversion: self.sampler_ycbcr_conversion
                && !other.sampler_ycbcr_conversion,
            scalar_block_layout: self.scalar_block_layout && !other.scalar_block_layout,
            separate_depth_stencil_layouts: self.separate_depth_stencil_layouts
                && !other.separate_depth_stencil_layouts,
            separate_stencil_mask_ref: self.separate_stencil_mask_ref
                && !other.separate_stencil_mask_ref,
            shader_buffer_float16_atomic_add: self.shader_buffer_float16_atomic_add
                && !other.shader_buffer_float16_atomic_add,
            shader_buffer_float16_atomic_min_max: self.shader_buffer_float16_atomic_min_max
                && !other.shader_buffer_float16_atomic_min_max,
            shader_buffer_float16_atomics: self.shader_buffer_float16_atomics
                && !other.shader_buffer_float16_atomics,
            shader_buffer_float32_atomic_add: self.shader_buffer_float32_atomic_add
                && !other.shader_buffer_float32_atomic_add,
            shader_buffer_float32_atomic_min_max: self.shader_buffer_float32_atomic_min_max
                && !other.shader_buffer_float32_atomic_min_max,
            shader_buffer_float32_atomics: self.shader_buffer_float32_atomics
                && !other.shader_buffer_float32_atomics,
            shader_buffer_float64_atomic_add: self.shader_buffer_float64_atomic_add
                && !other.shader_buffer_float64_atomic_add,
            shader_buffer_float64_atomic_min_max: self.shader_buffer_float64_atomic_min_max
                && !other.shader_buffer_float64_atomic_min_max,
            shader_buffer_float64_atomics: self.shader_buffer_float64_atomics
                && !other.shader_buffer_float64_atomics,
            shader_buffer_int64_atomics: self.shader_buffer_int64_atomics
                && !other.shader_buffer_int64_atomics,
            shader_clip_distance: self.shader_clip_distance && !other.shader_clip_distance,
            shader_cull_distance: self.shader_cull_distance && !other.shader_cull_distance,
            shader_demote_to_helper_invocation: self.shader_demote_to_helper_invocation
                && !other.shader_demote_to_helper_invocation,
            shader_device_clock: self.shader_device_clock && !other.shader_device_clock,
            shader_draw_parameters: self.shader_draw_parameters && !other.shader_draw_parameters,
            shader_float16: self.shader_float16 && !other.shader_float16,
            shader_float64: self.shader_float64 && !other.shader_float64,
            shader_image_float32_atomic_add: self.shader_image_float32_atomic_add
                && !other.shader_image_float32_atomic_add,
            shader_image_float32_atomic_min_max: self.shader_image_float32_atomic_min_max
                && !other.shader_image_float32_atomic_min_max,
            shader_image_float32_atomics: self.shader_image_float32_atomics
                && !other.shader_image_float32_atomics,
            shader_image_gather_extended: self.shader_image_gather_extended
                && !other.shader_image_gather_extended,
            shader_image_int64_atomics: self.shader_image_int64_atomics
                && !other.shader_image_int64_atomics,
            shader_input_attachment_array_dynamic_indexing: self
                .shader_input_attachment_array_dynamic_indexing
                && !other.shader_input_attachment_array_dynamic_indexing,
            shader_input_attachment_array_non_uniform_indexing: self
                .shader_input_attachment_array_non_uniform_indexing
                && !other.shader_input_attachment_array_non_uniform_indexing,
            shader_int16: self.shader_int16 && !other.shader_int16,
            shader_int64: self.shader_int64 && !other.shader_int64,
            shader_int8: self.shader_int8 && !other.shader_int8,
            shader_integer_dot_product: self.shader_integer_dot_product
                && !other.shader_integer_dot_product,
            shader_integer_functions2: self.shader_integer_functions2
                && !other.shader_integer_functions2,
            shader_output_layer: self.shader_output_layer && !other.shader_output_layer,
            shader_output_viewport_index: self.shader_output_viewport_index
                && !other.shader_output_viewport_index,
            shader_resource_min_lod: self.shader_resource_min_lod && !other.shader_resource_min_lod,
            shader_resource_residency: self.shader_resource_residency
                && !other.shader_resource_residency,
            shader_sample_rate_interpolation_functions: self
                .shader_sample_rate_interpolation_functions
                && !other.shader_sample_rate_interpolation_functions,
            shader_sampled_image_array_dynamic_indexing: self
                .shader_sampled_image_array_dynamic_indexing
                && !other.shader_sampled_image_array_dynamic_indexing,
            shader_sampled_image_array_non_uniform_indexing: self
                .shader_sampled_image_array_non_uniform_indexing
                && !other.shader_sampled_image_array_non_uniform_indexing,
            shader_shared_float16_atomic_add: self.shader_shared_float16_atomic_add
                && !other.shader_shared_float16_atomic_add,
            shader_shared_float16_atomic_min_max: self.shader_shared_float16_atomic_min_max
                && !other.shader_shared_float16_atomic_min_max,
            shader_shared_float16_atomics: self.shader_shared_float16_atomics
                && !other.shader_shared_float16_atomics,
            shader_shared_float32_atomic_add: self.shader_shared_float32_atomic_add
                && !other.shader_shared_float32_atomic_add,
            shader_shared_float32_atomic_min_max: self.shader_shared_float32_atomic_min_max
                && !other.shader_shared_float32_atomic_min_max,
            shader_shared_float32_atomics: self.shader_shared_float32_atomics
                && !other.shader_shared_float32_atomics,
            shader_shared_float64_atomic_add: self.shader_shared_float64_atomic_add
                && !other.shader_shared_float64_atomic_add,
            shader_shared_float64_atomic_min_max: self.shader_shared_float64_atomic_min_max
                && !other.shader_shared_float64_atomic_min_max,
            shader_shared_float64_atomics: self.shader_shared_float64_atomics
                && !other.shader_shared_float64_atomics,
            shader_shared_int64_atomics: self.shader_shared_int64_atomics
                && !other.shader_shared_int64_atomics,
            shader_sm_builtins: self.shader_sm_builtins && !other.shader_sm_builtins,
            shader_storage_buffer_array_dynamic_indexing: self
                .shader_storage_buffer_array_dynamic_indexing
                && !other.shader_storage_buffer_array_dynamic_indexing,
            shader_storage_buffer_array_non_uniform_indexing: self
                .shader_storage_buffer_array_non_uniform_indexing
                && !other.shader_storage_buffer_array_non_uniform_indexing,
            shader_storage_image_array_dynamic_indexing: self
                .shader_storage_image_array_dynamic_indexing
                && !other.shader_storage_image_array_dynamic_indexing,
            shader_storage_image_array_non_uniform_indexing: self
                .shader_storage_image_array_non_uniform_indexing
                && !other.shader_storage_image_array_non_uniform_indexing,
            shader_storage_image_extended_formats: self.shader_storage_image_extended_formats
                && !other.shader_storage_image_extended_formats,
            shader_storage_image_multisample: self.shader_storage_image_multisample
                && !other.shader_storage_image_multisample,
            shader_storage_image_read_without_format: self.shader_storage_image_read_without_format
                && !other.shader_storage_image_read_without_format,
            shader_storage_image_write_without_format: self
                .shader_storage_image_write_without_format
                && !other.shader_storage_image_write_without_format,
            shader_storage_texel_buffer_array_dynamic_indexing: self
                .shader_storage_texel_buffer_array_dynamic_indexing
                && !other.shader_storage_texel_buffer_array_dynamic_indexing,
            shader_storage_texel_buffer_array_non_uniform_indexing: self
                .shader_storage_texel_buffer_array_non_uniform_indexing
                && !other.shader_storage_texel_buffer_array_non_uniform_indexing,
            shader_subgroup_clock: self.shader_subgroup_clock && !other.shader_subgroup_clock,
            shader_subgroup_extended_types: self.shader_subgroup_extended_types
                && !other.shader_subgroup_extended_types,
            shader_subgroup_uniform_control_flow: self.shader_subgroup_uniform_control_flow
                && !other.shader_subgroup_uniform_control_flow,
            shader_terminate_invocation: self.shader_terminate_invocation
                && !other.shader_terminate_invocation,
            shader_tessellation_and_geometry_point_size: self
                .shader_tessellation_and_geometry_point_size
                && !other.shader_tessellation_and_geometry_point_size,
            shader_uniform_buffer_array_dynamic_indexing: self
                .shader_uniform_buffer_array_dynamic_indexing
                && !other.shader_uniform_buffer_array_dynamic_indexing,
            shader_uniform_buffer_array_non_uniform_indexing: self
                .shader_uniform_buffer_array_non_uniform_indexing
                && !other.shader_uniform_buffer_array_non_uniform_indexing,
            shader_uniform_texel_buffer_array_dynamic_indexing: self
                .shader_uniform_texel_buffer_array_dynamic_indexing
                && !other.shader_uniform_texel_buffer_array_dynamic_indexing,
            shader_uniform_texel_buffer_array_non_uniform_indexing: self
                .shader_uniform_texel_buffer_array_non_uniform_indexing
                && !other.shader_uniform_texel_buffer_array_non_uniform_indexing,
            shader_zero_initialize_workgroup_memory: self.shader_zero_initialize_workgroup_memory
                && !other.shader_zero_initialize_workgroup_memory,
            shading_rate_coarse_sample_order: self.shading_rate_coarse_sample_order
                && !other.shading_rate_coarse_sample_order,
            shading_rate_image: self.shading_rate_image && !other.shading_rate_image,
            smooth_lines: self.smooth_lines && !other.smooth_lines,
            sparse_binding: self.sparse_binding && !other.sparse_binding,
            sparse_image_float32_atomic_add: self.sparse_image_float32_atomic_add
                && !other.sparse_image_float32_atomic_add,
            sparse_image_float32_atomic_min_max: self.sparse_image_float32_atomic_min_max
                && !other.sparse_image_float32_atomic_min_max,
            sparse_image_float32_atomics: self.sparse_image_float32_atomics
                && !other.sparse_image_float32_atomics,
            sparse_image_int64_atomics: self.sparse_image_int64_atomics
                && !other.sparse_image_int64_atomics,
            sparse_residency16_samples: self.sparse_residency16_samples
                && !other.sparse_residency16_samples,
            sparse_residency2_samples: self.sparse_residency2_samples
                && !other.sparse_residency2_samples,
            sparse_residency4_samples: self.sparse_residency4_samples
                && !other.sparse_residency4_samples,
            sparse_residency8_samples: self.sparse_residency8_samples
                && !other.sparse_residency8_samples,
            sparse_residency_aliased: self.sparse_residency_aliased
                && !other.sparse_residency_aliased,
            sparse_residency_buffer: self.sparse_residency_buffer && !other.sparse_residency_buffer,
            sparse_residency_image2_d: self.sparse_residency_image2_d
                && !other.sparse_residency_image2_d,
            sparse_residency_image3_d: self.sparse_residency_image3_d
                && !other.sparse_residency_image3_d,
            stippled_bresenham_lines: self.stippled_bresenham_lines
                && !other.stippled_bresenham_lines,
            stippled_rectangular_lines: self.stippled_rectangular_lines
                && !other.stippled_rectangular_lines,
            stippled_smooth_lines: self.stippled_smooth_lines && !other.stippled_smooth_lines,
            storage_buffer16_bit_access: self.storage_buffer16_bit_access
                && !other.storage_buffer16_bit_access,
            storage_buffer8_bit_access: self.storage_buffer8_bit_access
                && !other.storage_buffer8_bit_access,
            storage_input_output16: self.storage_input_output16 && !other.storage_input_output16,
            storage_push_constant16: self.storage_push_constant16 && !other.storage_push_constant16,
            storage_push_constant8: self.storage_push_constant8 && !other.storage_push_constant8,
            subgroup_broadcast_dynamic_id: self.subgroup_broadcast_dynamic_id
                && !other.subgroup_broadcast_dynamic_id,
            subgroup_size_control: self.subgroup_size_control && !other.subgroup_size_control,
            subpass_shading: self.subpass_shading && !other.subpass_shading,
            supersample_fragment_shading_rates: self.supersample_fragment_shading_rates
                && !other.supersample_fragment_shading_rates,
            synchronization2: self.synchronization2 && !other.synchronization2,
            task_shader: self.task_shader && !other.task_shader,
            tessellation_isolines: self.tessellation_isolines && !other.tessellation_isolines,
            tessellation_point_mode: self.tessellation_point_mode && !other.tessellation_point_mode,
            tessellation_shader: self.tessellation_shader && !other.tessellation_shader,
            texel_buffer_alignment: self.texel_buffer_alignment && !other.texel_buffer_alignment,
            texture_compression_astc_hdr: self.texture_compression_astc_hdr
                && !other.texture_compression_astc_hdr,
            texture_compression_astc_ldr: self.texture_compression_astc_ldr
                && !other.texture_compression_astc_ldr,
            texture_compression_bc: self.texture_compression_bc && !other.texture_compression_bc,
            texture_compression_etc2: self.texture_compression_etc2
                && !other.texture_compression_etc2,
            timeline_semaphore: self.timeline_semaphore && !other.timeline_semaphore,
            transform_feedback: self.transform_feedback && !other.transform_feedback,
            transform_feedback_preserves_provoking_vertex: self
                .transform_feedback_preserves_provoking_vertex
                && !other.transform_feedback_preserves_provoking_vertex,
            triangle_fans: self.triangle_fans && !other.triangle_fans,
            uniform_and_storage_buffer16_bit_access: self.uniform_and_storage_buffer16_bit_access
                && !other.uniform_and_storage_buffer16_bit_access,
            uniform_and_storage_buffer8_bit_access: self.uniform_and_storage_buffer8_bit_access
                && !other.uniform_and_storage_buffer8_bit_access,
            uniform_buffer_standard_layout: self.uniform_buffer_standard_layout
                && !other.uniform_buffer_standard_layout,
            variable_multisample_rate: self.variable_multisample_rate
                && !other.variable_multisample_rate,
            variable_pointers: self.variable_pointers && !other.variable_pointers,
            variable_pointers_storage_buffer: self.variable_pointers_storage_buffer
                && !other.variable_pointers_storage_buffer,
            vertex_attribute_access_beyond_stride: self.vertex_attribute_access_beyond_stride
                && !other.vertex_attribute_access_beyond_stride,
            vertex_attribute_instance_rate_divisor: self.vertex_attribute_instance_rate_divisor
                && !other.vertex_attribute_instance_rate_divisor,
            vertex_attribute_instance_rate_zero_divisor: self
                .vertex_attribute_instance_rate_zero_divisor
                && !other.vertex_attribute_instance_rate_zero_divisor,
            vertex_input_dynamic_state: self.vertex_input_dynamic_state
                && !other.vertex_input_dynamic_state,
            vertex_pipeline_stores_and_atomics: self.vertex_pipeline_stores_and_atomics
                && !other.vertex_pipeline_stores_and_atomics,
            vulkan_memory_model: self.vulkan_memory_model && !other.vulkan_memory_model,
            vulkan_memory_model_availability_visibility_chains: self
                .vulkan_memory_model_availability_visibility_chains
                && !other.vulkan_memory_model_availability_visibility_chains,
            vulkan_memory_model_device_scope: self.vulkan_memory_model_device_scope
                && !other.vulkan_memory_model_device_scope,
            wide_lines: self.wide_lines && !other.wide_lines,
            workgroup_memory_explicit_layout: self.workgroup_memory_explicit_layout
                && !other.workgroup_memory_explicit_layout,
            workgroup_memory_explicit_layout16_bit_access: self
                .workgroup_memory_explicit_layout16_bit_access
                && !other.workgroup_memory_explicit_layout16_bit_access,
            workgroup_memory_explicit_layout8_bit_access: self
                .workgroup_memory_explicit_layout8_bit_access
                && !other.workgroup_memory_explicit_layout8_bit_access,
            workgroup_memory_explicit_layout_scalar_block_layout: self
                .workgroup_memory_explicit_layout_scalar_block_layout
                && !other.workgroup_memory_explicit_layout_scalar_block_layout,
            ycbcr2plane444_formats: self.ycbcr2plane444_formats && !other.ycbcr2plane444_formats,
            ycbcr_image_arrays: self.ycbcr_image_arrays && !other.ycbcr_image_arrays,
        }
    }
}
impl FeaturesFfi {
    pub(crate) fn write(&mut self, features: &Features) {
        std::array::IntoIter::new([self
            .features_acceleration_structure_khr
            .as_mut()
            .map(|s| &mut s.acceleration_structure)])
        .flatten()
        .next()
        .map(|f| *f = features.acceleration_structure as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_acceleration_structure_khr
            .as_mut()
            .map(|s| &mut s.acceleration_structure_capture_replay)])
        .flatten()
        .next()
        .map(|f| *f = features.acceleration_structure_capture_replay as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_acceleration_structure_khr
            .as_mut()
            .map(|s| &mut s.acceleration_structure_host_commands)])
        .flatten()
        .next()
        .map(|f| *f = features.acceleration_structure_host_commands as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_acceleration_structure_khr
            .as_mut()
            .map(|s| &mut s.acceleration_structure_indirect_build)])
        .flatten()
        .next()
        .map(|f| *f = features.acceleration_structure_indirect_build as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_blend_operation_advanced_ext
            .as_mut()
            .map(|s| &mut s.advanced_blend_coherent_operations)])
        .flatten()
        .next()
        .map(|f| *f = features.advanced_blend_coherent_operations as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.alpha_to_one])
            .next()
            .map(|f| *f = features.alpha_to_one as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shading_rate_khr
            .as_mut()
            .map(|s| &mut s.attachment_fragment_shading_rate)])
        .flatten()
        .next()
        .map(|f| *f = features.attachment_fragment_shading_rate as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_line_rasterization_ext
            .as_mut()
            .map(|s| &mut s.bresenham_lines)])
        .flatten()
        .next()
        .map(|f| *f = features.bresenham_lines as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.buffer_device_address),
            self.features_buffer_device_address
                .as_mut()
                .map(|s| &mut s.buffer_device_address),
            self.features_buffer_device_address_ext
                .as_mut()
                .map(|s| &mut s.buffer_device_address),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.buffer_device_address as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.buffer_device_address_capture_replay),
            self.features_buffer_device_address
                .as_mut()
                .map(|s| &mut s.buffer_device_address_capture_replay),
            self.features_buffer_device_address_ext
                .as_mut()
                .map(|s| &mut s.buffer_device_address_capture_replay),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.buffer_device_address_capture_replay as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.buffer_device_address_multi_device),
            self.features_buffer_device_address
                .as_mut()
                .map(|s| &mut s.buffer_device_address_multi_device),
            self.features_buffer_device_address_ext
                .as_mut()
                .map(|s| &mut s.buffer_device_address_multi_device),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.buffer_device_address_multi_device as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_color_write_enable_ext
            .as_mut()
            .map(|s| &mut s.color_write_enable)])
        .flatten()
        .next()
        .map(|f| *f = features.color_write_enable as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_compute_shader_derivatives_nv
            .as_mut()
            .map(|s| &mut s.compute_derivative_group_linear)])
        .flatten()
        .next()
        .map(|f| *f = features.compute_derivative_group_linear as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_compute_shader_derivatives_nv
            .as_mut()
            .map(|s| &mut s.compute_derivative_group_quads)])
        .flatten()
        .next()
        .map(|f| *f = features.compute_derivative_group_quads as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_subgroup_size_control_ext
            .as_mut()
            .map(|s| &mut s.compute_full_subgroups)])
        .flatten()
        .next()
        .map(|f| *f = features.compute_full_subgroups as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_conditional_rendering_ext
            .as_mut()
            .map(|s| &mut s.conditional_rendering)])
        .flatten()
        .next()
        .map(|f| *f = features.conditional_rendering as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.constant_alpha_color_blend_factors)])
        .flatten()
        .next()
        .map(|f| *f = features.constant_alpha_color_blend_factors as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_cooperative_matrix_nv
            .as_mut()
            .map(|s| &mut s.cooperative_matrix)])
        .flatten()
        .next()
        .map(|f| *f = features.cooperative_matrix as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_cooperative_matrix_nv
            .as_mut()
            .map(|s| &mut s.cooperative_matrix_robust_buffer_access)])
        .flatten()
        .next()
        .map(|f| *f = features.cooperative_matrix_robust_buffer_access as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_corner_sampled_image_nv
            .as_mut()
            .map(|s| &mut s.corner_sampled_image)])
        .flatten()
        .next()
        .map(|f| *f = features.corner_sampled_image as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_coverage_reduction_mode_nv
            .as_mut()
            .map(|s| &mut s.coverage_reduction_mode)])
        .flatten()
        .next()
        .map(|f| *f = features.coverage_reduction_mode as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_custom_border_color_ext
            .as_mut()
            .map(|s| &mut s.custom_border_color_without_format)])
        .flatten()
        .next()
        .map(|f| *f = features.custom_border_color_without_format as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_custom_border_color_ext
            .as_mut()
            .map(|s| &mut s.custom_border_colors)])
        .flatten()
        .next()
        .map(|f| *f = features.custom_border_colors as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_astc_decode_ext
            .as_mut()
            .map(|s| &mut s.decode_mode_shared_exponent)])
        .flatten()
        .next()
        .map(|f| *f = features.decode_mode_shared_exponent as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_dedicated_allocation_image_aliasing_nv
            .as_mut()
            .map(|s| &mut s.dedicated_allocation_image_aliasing)])
        .flatten()
        .next()
        .map(|f| *f = features.dedicated_allocation_image_aliasing as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.depth_bias_clamp])
            .next()
            .map(|f| *f = features.depth_bias_clamp as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.depth_bounds])
            .next()
            .map(|f| *f = features.depth_bounds as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.depth_clamp])
            .next()
            .map(|f| *f = features.depth_clamp as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_depth_clip_enable_ext
            .as_mut()
            .map(|s| &mut s.depth_clip_enable)])
        .flatten()
        .next()
        .map(|f| *f = features.depth_clip_enable as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_acceleration_structure_khr
            .as_mut()
            .map(|s| &mut s.descriptor_binding_acceleration_structure_update_after_bind)])
        .flatten()
        .next()
        .map(|f| {
            *f = features.descriptor_binding_acceleration_structure_update_after_bind
                as ash::vk::Bool32
        });
        std::array::IntoIter::new([self
            .features_inline_uniform_block_ext
            .as_mut()
            .map(|s| &mut s.descriptor_binding_inline_uniform_block_update_after_bind)])
        .flatten()
        .next()
        .map(|f| {
            *f = features.descriptor_binding_inline_uniform_block_update_after_bind
                as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_partially_bound),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_partially_bound),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.descriptor_binding_partially_bound as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_sampled_image_update_after_bind),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_sampled_image_update_after_bind),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.descriptor_binding_sampled_image_update_after_bind as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_buffer_update_after_bind),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_buffer_update_after_bind),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.descriptor_binding_storage_buffer_update_after_bind as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_image_update_after_bind),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_image_update_after_bind),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.descriptor_binding_storage_image_update_after_bind as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_texel_buffer_update_after_bind),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_storage_texel_buffer_update_after_bind),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.descriptor_binding_storage_texel_buffer_update_after_bind
                as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_uniform_buffer_update_after_bind),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_uniform_buffer_update_after_bind),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.descriptor_binding_uniform_buffer_update_after_bind as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_uniform_texel_buffer_update_after_bind),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_uniform_texel_buffer_update_after_bind),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.descriptor_binding_uniform_texel_buffer_update_after_bind
                as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_update_unused_while_pending),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_update_unused_while_pending),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.descriptor_binding_update_unused_while_pending as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.descriptor_binding_variable_descriptor_count),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.descriptor_binding_variable_descriptor_count),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.descriptor_binding_variable_descriptor_count as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vulkan12
            .as_mut()
            .map(|s| &mut s.descriptor_indexing)])
        .flatten()
        .next()
        .map(|f| *f = features.descriptor_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_coherent_memory_amd
            .as_mut()
            .map(|s| &mut s.device_coherent_memory)])
        .flatten()
        .next()
        .map(|f| *f = features.device_coherent_memory as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_device_generated_commands_nv
            .as_mut()
            .map(|s| &mut s.device_generated_commands)])
        .flatten()
        .next()
        .map(|f| *f = features.device_generated_commands as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_device_memory_report_ext
            .as_mut()
            .map(|s| &mut s.device_memory_report)])
        .flatten()
        .next()
        .map(|f| *f = features.device_memory_report as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_diagnostics_config_nv
            .as_mut()
            .map(|s| &mut s.diagnostics_config)])
        .flatten()
        .next()
        .map(|f| *f = features.diagnostics_config as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vulkan12
            .as_mut()
            .map(|s| &mut s.draw_indirect_count)])
        .flatten()
        .next()
        .map(|f| *f = features.draw_indirect_count as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .draw_indirect_first_instance])
        .next()
        .map(|f| *f = features.draw_indirect_first_instance as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.dual_src_blend])
            .next()
            .map(|f| *f = features.dual_src_blend as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.events)])
        .flatten()
        .next()
        .map(|f| *f = features.events as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_exclusive_scissor_nv
            .as_mut()
            .map(|s| &mut s.exclusive_scissor)])
        .flatten()
        .next()
        .map(|f| *f = features.exclusive_scissor as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_extended_dynamic_state_ext
            .as_mut()
            .map(|s| &mut s.extended_dynamic_state)])
        .flatten()
        .next()
        .map(|f| *f = features.extended_dynamic_state as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_extended_dynamic_state2_ext
            .as_mut()
            .map(|s| &mut s.extended_dynamic_state2)])
        .flatten()
        .next()
        .map(|f| *f = features.extended_dynamic_state2 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_extended_dynamic_state2_ext
            .as_mut()
            .map(|s| &mut s.extended_dynamic_state2_logic_op)])
        .flatten()
        .next()
        .map(|f| *f = features.extended_dynamic_state2_logic_op as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_extended_dynamic_state2_ext
            .as_mut()
            .map(|s| &mut s.extended_dynamic_state2_patch_control_points)])
        .flatten()
        .next()
        .map(|f| *f = features.extended_dynamic_state2_patch_control_points as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_external_memory_rdma_nv
            .as_mut()
            .map(|s| &mut s.external_memory_rdma)])
        .flatten()
        .next()
        .map(|f| *f = features.external_memory_rdma as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.fill_mode_non_solid])
            .next()
            .map(|f| *f = features.fill_mode_non_solid as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_4444formats_ext
            .as_mut()
            .map(|s| &mut s.format_a4b4g4r4)])
        .flatten()
        .next()
        .map(|f| *f = features.format_a4b4g4r4 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_4444formats_ext
            .as_mut()
            .map(|s| &mut s.format_a4r4g4b4)])
        .flatten()
        .next()
        .map(|f| *f = features.format_a4r4g4b4 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_density_map_ext
            .as_mut()
            .map(|s| &mut s.fragment_density_map)])
        .flatten()
        .next()
        .map(|f| *f = features.fragment_density_map as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_density_map2_ext
            .as_mut()
            .map(|s| &mut s.fragment_density_map_deferred)])
        .flatten()
        .next()
        .map(|f| *f = features.fragment_density_map_deferred as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_density_map_ext
            .as_mut()
            .map(|s| &mut s.fragment_density_map_dynamic)])
        .flatten()
        .next()
        .map(|f| *f = features.fragment_density_map_dynamic as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_density_map_ext
            .as_mut()
            .map(|s| &mut s.fragment_density_map_non_subsampled_images)])
        .flatten()
        .next()
        .map(|f| *f = features.fragment_density_map_non_subsampled_images as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shader_barycentric_nv
            .as_mut()
            .map(|s| &mut s.fragment_shader_barycentric)])
        .flatten()
        .next()
        .map(|f| *f = features.fragment_shader_barycentric as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shader_interlock_ext
            .as_mut()
            .map(|s| &mut s.fragment_shader_pixel_interlock)])
        .flatten()
        .next()
        .map(|f| *f = features.fragment_shader_pixel_interlock as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shader_interlock_ext
            .as_mut()
            .map(|s| &mut s.fragment_shader_sample_interlock)])
        .flatten()
        .next()
        .map(|f| *f = features.fragment_shader_sample_interlock as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shader_interlock_ext
            .as_mut()
            .map(|s| &mut s.fragment_shader_shading_rate_interlock)])
        .flatten()
        .next()
        .map(|f| *f = features.fragment_shader_shading_rate_interlock as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shading_rate_enums_nv
            .as_mut()
            .map(|s| &mut s.fragment_shading_rate_enums)])
        .flatten()
        .next()
        .map(|f| *f = features.fragment_shading_rate_enums as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .fragment_stores_and_atomics])
        .next()
        .map(|f| *f = features.fragment_stores_and_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.full_draw_index_uint32])
            .next()
            .map(|f| *f = features.full_draw_index_uint32 as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.geometry_shader])
            .next()
            .map(|f| *f = features.geometry_shader as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_transform_feedback_ext
            .as_mut()
            .map(|s| &mut s.geometry_streams)])
        .flatten()
        .next()
        .map(|f| *f = features.geometry_streams as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_global_priority_query_ext
            .as_mut()
            .map(|s| &mut s.global_priority_query)])
        .flatten()
        .next()
        .map(|f| *f = features.global_priority_query as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.host_query_reset),
            self.features_host_query_reset
                .as_mut()
                .map(|s| &mut s.host_query_reset),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.host_query_reset as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.image_cube_array])
            .next()
            .map(|f| *f = features.image_cube_array as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_image_footprint_nv
            .as_mut()
            .map(|s| &mut s.image_footprint)])
        .flatten()
        .next()
        .map(|f| *f = features.image_footprint as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.image_view2_d_on3_d_image)])
        .flatten()
        .next()
        .map(|f| *f = features.image_view2_d_on3_d_image as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.image_view_format_reinterpretation)])
        .flatten()
        .next()
        .map(|f| *f = features.image_view_format_reinterpretation as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.image_view_format_swizzle)])
        .flatten()
        .next()
        .map(|f| *f = features.image_view_format_swizzle as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.imageless_framebuffer),
            self.features_imageless_framebuffer
                .as_mut()
                .map(|s| &mut s.imageless_framebuffer),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.imageless_framebuffer as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.independent_blend])
            .next()
            .map(|f| *f = features.independent_blend as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_index_type_uint8_ext
            .as_mut()
            .map(|s| &mut s.index_type_uint8)])
        .flatten()
        .next()
        .map(|f| *f = features.index_type_uint8 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_conditional_rendering_ext
            .as_mut()
            .map(|s| &mut s.inherited_conditional_rendering)])
        .flatten()
        .next()
        .map(|f| *f = features.inherited_conditional_rendering as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.inherited_queries])
            .next()
            .map(|f| *f = features.inherited_queries as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_inherited_viewport_scissor_nv
            .as_mut()
            .map(|s| &mut s.inherited_viewport_scissor2_d)])
        .flatten()
        .next()
        .map(|f| *f = features.inherited_viewport_scissor2_d as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_inline_uniform_block_ext
            .as_mut()
            .map(|s| &mut s.inline_uniform_block)])
        .flatten()
        .next()
        .map(|f| *f = features.inline_uniform_block as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_invocation_mask_huawei
            .as_mut()
            .map(|s| &mut s.invocation_mask)])
        .flatten()
        .next()
        .map(|f| *f = features.invocation_mask as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.large_points])
            .next()
            .map(|f| *f = features.large_points as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.logic_op])
            .next()
            .map(|f| *f = features.logic_op as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_memory_priority_ext
            .as_mut()
            .map(|s| &mut s.memory_priority)])
        .flatten()
        .next()
        .map(|f| *f = features.memory_priority as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_mesh_shader_nv
            .as_mut()
            .map(|s| &mut s.mesh_shader)])
        .flatten()
        .next()
        .map(|f| *f = features.mesh_shader as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_multi_draw_ext
            .as_mut()
            .map(|s| &mut s.multi_draw)])
        .flatten()
        .next()
        .map(|f| *f = features.multi_draw as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.multi_draw_indirect])
            .next()
            .map(|f| *f = features.multi_draw_indirect as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.multi_viewport])
            .next()
            .map(|f| *f = features.multi_viewport as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.multisample_array_image)])
        .flatten()
        .next()
        .map(|f| *f = features.multisample_array_image as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11.as_mut().map(|s| &mut s.multiview),
            self.features_multiview.as_mut().map(|s| &mut s.multiview),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.multiview as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.multiview_geometry_shader),
            self.features_multiview
                .as_mut()
                .map(|s| &mut s.multiview_geometry_shader),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.multiview_geometry_shader as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.multiview_tessellation_shader),
            self.features_multiview
                .as_mut()
                .map(|s| &mut s.multiview_tessellation_shader),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.multiview_tessellation_shader as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.mutable_comparison_samplers)])
        .flatten()
        .next()
        .map(|f| *f = features.mutable_comparison_samplers as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_mutable_descriptor_type_valve
            .as_mut()
            .map(|s| &mut s.mutable_descriptor_type)])
        .flatten()
        .next()
        .map(|f| *f = features.mutable_descriptor_type as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shading_rate_enums_nv
            .as_mut()
            .map(|s| &mut s.no_invocation_fragment_shading_rates)])
        .flatten()
        .next()
        .map(|f| *f = features.no_invocation_fragment_shading_rates as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_robustness2_ext
            .as_mut()
            .map(|s| &mut s.null_descriptor)])
        .flatten()
        .next()
        .map(|f| *f = features.null_descriptor as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.occlusion_query_precise])
            .next()
            .map(|f| *f = features.occlusion_query_precise as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_pageable_device_local_memory_ext
            .as_mut()
            .map(|s| &mut s.pageable_device_local_memory)])
        .flatten()
        .next()
        .map(|f| *f = features.pageable_device_local_memory as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_performance_query_khr
            .as_mut()
            .map(|s| &mut s.performance_counter_multiple_query_pools)])
        .flatten()
        .next()
        .map(|f| *f = features.performance_counter_multiple_query_pools as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_performance_query_khr
            .as_mut()
            .map(|s| &mut s.performance_counter_query_pools)])
        .flatten()
        .next()
        .map(|f| *f = features.performance_counter_query_pools as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_pipeline_creation_cache_control_ext
            .as_mut()
            .map(|s| &mut s.pipeline_creation_cache_control)])
        .flatten()
        .next()
        .map(|f| *f = features.pipeline_creation_cache_control as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_pipeline_executable_properties_khr
            .as_mut()
            .map(|s| &mut s.pipeline_executable_info)])
        .flatten()
        .next()
        .map(|f| *f = features.pipeline_executable_info as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shading_rate_khr
            .as_mut()
            .map(|s| &mut s.pipeline_fragment_shading_rate)])
        .flatten()
        .next()
        .map(|f| *f = features.pipeline_fragment_shading_rate as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.pipeline_statistics_query])
            .next()
            .map(|f| *f = features.pipeline_statistics_query as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.point_polygons)])
        .flatten()
        .next()
        .map(|f| *f = features.point_polygons as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_present_id_khr
            .as_mut()
            .map(|s| &mut s.present_id)])
        .flatten()
        .next()
        .map(|f| *f = features.present_id as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_present_wait_khr
            .as_mut()
            .map(|s| &mut s.present_wait)])
        .flatten()
        .next()
        .map(|f| *f = features.present_wait as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shading_rate_khr
            .as_mut()
            .map(|s| &mut s.primitive_fragment_shading_rate)])
        .flatten()
        .next()
        .map(|f| *f = features.primitive_fragment_shading_rate as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_primitive_topology_list_restart_ext
            .as_mut()
            .map(|s| &mut s.primitive_topology_list_restart)])
        .flatten()
        .next()
        .map(|f| *f = features.primitive_topology_list_restart as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_primitive_topology_list_restart_ext
            .as_mut()
            .map(|s| &mut s.primitive_topology_patch_list_restart)])
        .flatten()
        .next()
        .map(|f| *f = features.primitive_topology_patch_list_restart as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_private_data_ext
            .as_mut()
            .map(|s| &mut s.private_data)])
        .flatten()
        .next()
        .map(|f| *f = features.private_data as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.protected_memory),
            self.features_protected_memory
                .as_mut()
                .map(|s| &mut s.protected_memory),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.protected_memory as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_provoking_vertex_ext
            .as_mut()
            .map(|s| &mut s.provoking_vertex_last)])
        .flatten()
        .next()
        .map(|f| *f = features.provoking_vertex_last as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_ray_query_khr
            .as_mut()
            .map(|s| &mut s.ray_query)])
        .flatten()
        .next()
        .map(|f| *f = features.ray_query as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_ray_tracing_motion_blur_nv
            .as_mut()
            .map(|s| &mut s.ray_tracing_motion_blur)])
        .flatten()
        .next()
        .map(|f| *f = features.ray_tracing_motion_blur as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_ray_tracing_motion_blur_nv
            .as_mut()
            .map(|s| &mut s.ray_tracing_motion_blur_pipeline_trace_rays_indirect)])
        .flatten()
        .next()
        .map(|f| {
            *f = features.ray_tracing_motion_blur_pipeline_trace_rays_indirect as ash::vk::Bool32
        });
        std::array::IntoIter::new([self
            .features_ray_tracing_pipeline_khr
            .as_mut()
            .map(|s| &mut s.ray_tracing_pipeline)])
        .flatten()
        .next()
        .map(|f| *f = features.ray_tracing_pipeline as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_ray_tracing_pipeline_khr
            .as_mut()
            .map(|s| &mut s.ray_tracing_pipeline_shader_group_handle_capture_replay)])
        .flatten()
        .next()
        .map(|f| {
            *f = features.ray_tracing_pipeline_shader_group_handle_capture_replay as ash::vk::Bool32
        });
        std::array::IntoIter::new([self
            .features_ray_tracing_pipeline_khr
            .as_mut()
            .map(|s| &mut s.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed)])
        .flatten()
        .next()
        .map(|f| {
            *f = features.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed
                as ash::vk::Bool32
        });
        std::array::IntoIter::new([self
            .features_ray_tracing_pipeline_khr
            .as_mut()
            .map(|s| &mut s.ray_tracing_pipeline_trace_rays_indirect)])
        .flatten()
        .next()
        .map(|f| *f = features.ray_tracing_pipeline_trace_rays_indirect as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_ray_tracing_pipeline_khr
            .as_mut()
            .map(|s| &mut s.ray_traversal_primitive_culling)])
        .flatten()
        .next()
        .map(|f| *f = features.ray_traversal_primitive_culling as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_line_rasterization_ext
            .as_mut()
            .map(|s| &mut s.rectangular_lines)])
        .flatten()
        .next()
        .map(|f| *f = features.rectangular_lines as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_representative_fragment_test_nv
            .as_mut()
            .map(|s| &mut s.representative_fragment_test)])
        .flatten()
        .next()
        .map(|f| *f = features.representative_fragment_test as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.robust_buffer_access])
            .next()
            .map(|f| *f = features.robust_buffer_access as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_robustness2_ext
            .as_mut()
            .map(|s| &mut s.robust_buffer_access2)])
        .flatten()
        .next()
        .map(|f| *f = features.robust_buffer_access2 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_image_robustness_ext
            .as_mut()
            .map(|s| &mut s.robust_image_access)])
        .flatten()
        .next()
        .map(|f| *f = features.robust_image_access as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_robustness2_ext
            .as_mut()
            .map(|s| &mut s.robust_image_access2)])
        .flatten()
        .next()
        .map(|f| *f = features.robust_image_access2 as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.runtime_descriptor_array),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.runtime_descriptor_array),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.runtime_descriptor_array as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sample_rate_shading])
            .next()
            .map(|f| *f = features.sample_rate_shading as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sampler_anisotropy])
            .next()
            .map(|f| *f = features.sampler_anisotropy as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vulkan12
            .as_mut()
            .map(|s| &mut s.sampler_filter_minmax)])
        .flatten()
        .next()
        .map(|f| *f = features.sampler_filter_minmax as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.sampler_mip_lod_bias)])
        .flatten()
        .next()
        .map(|f| *f = features.sampler_mip_lod_bias as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vulkan12
            .as_mut()
            .map(|s| &mut s.sampler_mirror_clamp_to_edge)])
        .flatten()
        .next()
        .map(|f| *f = features.sampler_mirror_clamp_to_edge as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.sampler_ycbcr_conversion),
            self.features_sampler_ycbcr_conversion
                .as_mut()
                .map(|s| &mut s.sampler_ycbcr_conversion),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.sampler_ycbcr_conversion as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.scalar_block_layout),
            self.features_scalar_block_layout
                .as_mut()
                .map(|s| &mut s.scalar_block_layout),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.scalar_block_layout as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.separate_depth_stencil_layouts),
            self.features_separate_depth_stencil_layouts
                .as_mut()
                .map(|s| &mut s.separate_depth_stencil_layouts),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.separate_depth_stencil_layouts as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.separate_stencil_mask_ref)])
        .flatten()
        .next()
        .map(|f| *f = features.separate_stencil_mask_ref as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_buffer_float16_atomic_add)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_float16_atomic_add as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_buffer_float16_atomic_min_max)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_float16_atomic_min_max as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_buffer_float16_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_float16_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_buffer_float32_atomic_add)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_float32_atomic_add as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_buffer_float32_atomic_min_max)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_float32_atomic_min_max as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_buffer_float32_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_float32_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_buffer_float64_atomic_add)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_float64_atomic_add as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_buffer_float64_atomic_min_max)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_float64_atomic_min_max as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_buffer_float64_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_float64_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_buffer_int64_atomics),
            self.features_shader_atomic_int64
                .as_mut()
                .map(|s| &mut s.shader_buffer_int64_atomics),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_buffer_int64_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.shader_clip_distance])
            .next()
            .map(|f| *f = features.shader_clip_distance as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.shader_cull_distance])
            .next()
            .map(|f| *f = features.shader_cull_distance as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_demote_to_helper_invocation_ext
            .as_mut()
            .map(|s| &mut s.shader_demote_to_helper_invocation)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_demote_to_helper_invocation as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_clock_khr
            .as_mut()
            .map(|s| &mut s.shader_device_clock)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_device_clock as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.shader_draw_parameters),
            self.features_shader_draw_parameters
                .as_mut()
                .map(|s| &mut s.shader_draw_parameters),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_draw_parameters as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_float16),
            self.features_shader_float16_int8
                .as_mut()
                .map(|s| &mut s.shader_float16),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_float16 as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.shader_float64])
            .next()
            .map(|f| *f = features.shader_float64 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_image_float32_atomic_add)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_image_float32_atomic_add as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_image_float32_atomic_min_max)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_image_float32_atomic_min_max as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_image_float32_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_image_float32_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_image_gather_extended])
        .next()
        .map(|f| *f = features.shader_image_gather_extended as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_image_atomic_int64_ext
            .as_mut()
            .map(|s| &mut s.shader_image_int64_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_image_int64_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_input_attachment_array_dynamic_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_input_attachment_array_dynamic_indexing),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_input_attachment_array_dynamic_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_input_attachment_array_non_uniform_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_input_attachment_array_non_uniform_indexing),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.shader_input_attachment_array_non_uniform_indexing as ash::vk::Bool32
        });
        std::array::IntoIter::new([&mut self.features_vulkan10.features.shader_int16])
            .next()
            .map(|f| *f = features.shader_int16 as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.shader_int64])
            .next()
            .map(|f| *f = features.shader_int64 as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12.as_mut().map(|s| &mut s.shader_int8),
            self.features_shader_float16_int8
                .as_mut()
                .map(|s| &mut s.shader_int8),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_int8 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_integer_dot_product_khr
            .as_mut()
            .map(|s| &mut s.shader_integer_dot_product)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_integer_dot_product as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_integer_functions2_intel
            .as_mut()
            .map(|s| &mut s.shader_integer_functions2)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_integer_functions2 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vulkan12
            .as_mut()
            .map(|s| &mut s.shader_output_layer)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_output_layer as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vulkan12
            .as_mut()
            .map(|s| &mut s.shader_output_viewport_index)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_output_viewport_index as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.shader_resource_min_lod])
            .next()
            .map(|f| *f = features.shader_resource_min_lod as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.shader_resource_residency])
            .next()
            .map(|f| *f = features.shader_resource_residency as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.shader_sample_rate_interpolation_functions)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_sample_rate_interpolation_functions as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_sampled_image_array_dynamic_indexing])
        .next()
        .map(|f| *f = features.shader_sampled_image_array_dynamic_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_sampled_image_array_non_uniform_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_sampled_image_array_non_uniform_indexing),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_sampled_image_array_non_uniform_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_shared_float16_atomic_add)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_float16_atomic_add as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_shared_float16_atomic_min_max)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_float16_atomic_min_max as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_shared_float16_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_float16_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_shared_float32_atomic_add)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_float32_atomic_add as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_shared_float32_atomic_min_max)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_float32_atomic_min_max as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_shared_float32_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_float32_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_shared_float64_atomic_add)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_float64_atomic_add as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.shader_shared_float64_atomic_min_max)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_float64_atomic_min_max as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.shader_shared_float64_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_float64_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_shared_int64_atomics),
            self.features_shader_atomic_int64
                .as_mut()
                .map(|s| &mut s.shader_shared_int64_atomics),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_shared_int64_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_sm_builtins_nv
            .as_mut()
            .map(|s| &mut s.shader_sm_builtins)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_sm_builtins as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_storage_buffer_array_dynamic_indexing])
        .next()
        .map(|f| *f = features.shader_storage_buffer_array_dynamic_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_storage_buffer_array_non_uniform_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_storage_buffer_array_non_uniform_indexing),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_storage_buffer_array_non_uniform_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_storage_image_array_dynamic_indexing])
        .next()
        .map(|f| *f = features.shader_storage_image_array_dynamic_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_storage_image_array_non_uniform_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_storage_image_array_non_uniform_indexing),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_storage_image_array_non_uniform_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_storage_image_extended_formats])
        .next()
        .map(|f| *f = features.shader_storage_image_extended_formats as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_storage_image_multisample])
        .next()
        .map(|f| *f = features.shader_storage_image_multisample as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_storage_image_read_without_format])
        .next()
        .map(|f| *f = features.shader_storage_image_read_without_format as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_storage_image_write_without_format])
        .next()
        .map(|f| *f = features.shader_storage_image_write_without_format as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_storage_texel_buffer_array_dynamic_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_storage_texel_buffer_array_dynamic_indexing),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.shader_storage_texel_buffer_array_dynamic_indexing as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_storage_texel_buffer_array_non_uniform_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_storage_texel_buffer_array_non_uniform_indexing),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.shader_storage_texel_buffer_array_non_uniform_indexing as ash::vk::Bool32
        });
        std::array::IntoIter::new([self
            .features_shader_clock_khr
            .as_mut()
            .map(|s| &mut s.shader_subgroup_clock)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_subgroup_clock as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_subgroup_extended_types),
            self.features_shader_subgroup_extended_types
                .as_mut()
                .map(|s| &mut s.shader_subgroup_extended_types),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_subgroup_extended_types as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_subgroup_uniform_control_flow_khr
            .as_mut()
            .map(|s| &mut s.shader_subgroup_uniform_control_flow)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_subgroup_uniform_control_flow as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_terminate_invocation_khr
            .as_mut()
            .map(|s| &mut s.shader_terminate_invocation)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_terminate_invocation as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_tessellation_and_geometry_point_size])
        .next()
        .map(|f| *f = features.shader_tessellation_and_geometry_point_size as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .shader_uniform_buffer_array_dynamic_indexing])
        .next()
        .map(|f| *f = features.shader_uniform_buffer_array_dynamic_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_uniform_buffer_array_non_uniform_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_uniform_buffer_array_non_uniform_indexing),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.shader_uniform_buffer_array_non_uniform_indexing as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_uniform_texel_buffer_array_dynamic_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_uniform_texel_buffer_array_dynamic_indexing),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.shader_uniform_texel_buffer_array_dynamic_indexing as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.shader_uniform_texel_buffer_array_non_uniform_indexing),
            self.features_descriptor_indexing
                .as_mut()
                .map(|s| &mut s.shader_uniform_texel_buffer_array_non_uniform_indexing),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.shader_uniform_texel_buffer_array_non_uniform_indexing as ash::vk::Bool32
        });
        std::array::IntoIter::new([self
            .features_zero_initialize_workgroup_memory_khr
            .as_mut()
            .map(|s| &mut s.shader_zero_initialize_workgroup_memory)])
        .flatten()
        .next()
        .map(|f| *f = features.shader_zero_initialize_workgroup_memory as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shading_rate_image_nv
            .as_mut()
            .map(|s| &mut s.shading_rate_coarse_sample_order)])
        .flatten()
        .next()
        .map(|f| *f = features.shading_rate_coarse_sample_order as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shading_rate_image_nv
            .as_mut()
            .map(|s| &mut s.shading_rate_image)])
        .flatten()
        .next()
        .map(|f| *f = features.shading_rate_image as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_line_rasterization_ext
            .as_mut()
            .map(|s| &mut s.smooth_lines)])
        .flatten()
        .next()
        .map(|f| *f = features.smooth_lines as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sparse_binding])
            .next()
            .map(|f| *f = features.sparse_binding as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.sparse_image_float32_atomic_add)])
        .flatten()
        .next()
        .map(|f| *f = features.sparse_image_float32_atomic_add as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float2_ext
            .as_mut()
            .map(|s| &mut s.sparse_image_float32_atomic_min_max)])
        .flatten()
        .next()
        .map(|f| *f = features.sparse_image_float32_atomic_min_max as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_atomic_float_ext
            .as_mut()
            .map(|s| &mut s.sparse_image_float32_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.sparse_image_float32_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_shader_image_atomic_int64_ext
            .as_mut()
            .map(|s| &mut s.sparse_image_int64_atomics)])
        .flatten()
        .next()
        .map(|f| *f = features.sparse_image_int64_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .sparse_residency16_samples])
        .next()
        .map(|f| *f = features.sparse_residency16_samples as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sparse_residency2_samples])
            .next()
            .map(|f| *f = features.sparse_residency2_samples as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sparse_residency4_samples])
            .next()
            .map(|f| *f = features.sparse_residency4_samples as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sparse_residency8_samples])
            .next()
            .map(|f| *f = features.sparse_residency8_samples as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sparse_residency_aliased])
            .next()
            .map(|f| *f = features.sparse_residency_aliased as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sparse_residency_buffer])
            .next()
            .map(|f| *f = features.sparse_residency_buffer as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sparse_residency_image2_d])
            .next()
            .map(|f| *f = features.sparse_residency_image2_d as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.sparse_residency_image3_d])
            .next()
            .map(|f| *f = features.sparse_residency_image3_d as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_line_rasterization_ext
            .as_mut()
            .map(|s| &mut s.stippled_bresenham_lines)])
        .flatten()
        .next()
        .map(|f| *f = features.stippled_bresenham_lines as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_line_rasterization_ext
            .as_mut()
            .map(|s| &mut s.stippled_rectangular_lines)])
        .flatten()
        .next()
        .map(|f| *f = features.stippled_rectangular_lines as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_line_rasterization_ext
            .as_mut()
            .map(|s| &mut s.stippled_smooth_lines)])
        .flatten()
        .next()
        .map(|f| *f = features.stippled_smooth_lines as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.storage_buffer16_bit_access),
            self.features_16bit_storage
                .as_mut()
                .map(|s| &mut s.storage_buffer16_bit_access),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.storage_buffer16_bit_access as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.storage_buffer8_bit_access),
            self.features_8bit_storage
                .as_mut()
                .map(|s| &mut s.storage_buffer8_bit_access),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.storage_buffer8_bit_access as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.storage_input_output16),
            self.features_16bit_storage
                .as_mut()
                .map(|s| &mut s.storage_input_output16),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.storage_input_output16 as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.storage_push_constant16),
            self.features_16bit_storage
                .as_mut()
                .map(|s| &mut s.storage_push_constant16),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.storage_push_constant16 as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.storage_push_constant8),
            self.features_8bit_storage
                .as_mut()
                .map(|s| &mut s.storage_push_constant8),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.storage_push_constant8 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vulkan12
            .as_mut()
            .map(|s| &mut s.subgroup_broadcast_dynamic_id)])
        .flatten()
        .next()
        .map(|f| *f = features.subgroup_broadcast_dynamic_id as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_subgroup_size_control_ext
            .as_mut()
            .map(|s| &mut s.subgroup_size_control)])
        .flatten()
        .next()
        .map(|f| *f = features.subgroup_size_control as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_subpass_shading_huawei
            .as_mut()
            .map(|s| &mut s.subpass_shading)])
        .flatten()
        .next()
        .map(|f| *f = features.subpass_shading as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_fragment_shading_rate_enums_nv
            .as_mut()
            .map(|s| &mut s.supersample_fragment_shading_rates)])
        .flatten()
        .next()
        .map(|f| *f = features.supersample_fragment_shading_rates as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_synchronization2_khr
            .as_mut()
            .map(|s| &mut s.synchronization2)])
        .flatten()
        .next()
        .map(|f| *f = features.synchronization2 as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_mesh_shader_nv
            .as_mut()
            .map(|s| &mut s.task_shader)])
        .flatten()
        .next()
        .map(|f| *f = features.task_shader as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.tessellation_isolines)])
        .flatten()
        .next()
        .map(|f| *f = features.tessellation_isolines as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.tessellation_point_mode)])
        .flatten()
        .next()
        .map(|f| *f = features.tessellation_point_mode as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.tessellation_shader])
            .next()
            .map(|f| *f = features.tessellation_shader as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_texel_buffer_alignment_ext
            .as_mut()
            .map(|s| &mut s.texel_buffer_alignment)])
        .flatten()
        .next()
        .map(|f| *f = features.texel_buffer_alignment as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_texture_compression_astchdr_ext
            .as_mut()
            .map(|s| &mut s.texture_compression_astc_hdr)])
        .flatten()
        .next()
        .map(|f| *f = features.texture_compression_astc_hdr as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .texture_compression_astc_ldr])
        .next()
        .map(|f| *f = features.texture_compression_astc_ldr as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.texture_compression_bc])
            .next()
            .map(|f| *f = features.texture_compression_bc as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.texture_compression_etc2])
            .next()
            .map(|f| *f = features.texture_compression_etc2 as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.timeline_semaphore),
            self.features_timeline_semaphore
                .as_mut()
                .map(|s| &mut s.timeline_semaphore),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.timeline_semaphore as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_transform_feedback_ext
            .as_mut()
            .map(|s| &mut s.transform_feedback)])
        .flatten()
        .next()
        .map(|f| *f = features.transform_feedback as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_provoking_vertex_ext
            .as_mut()
            .map(|s| &mut s.transform_feedback_preserves_provoking_vertex)])
        .flatten()
        .next()
        .map(|f| *f = features.transform_feedback_preserves_provoking_vertex as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.triangle_fans)])
        .flatten()
        .next()
        .map(|f| *f = features.triangle_fans as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.uniform_and_storage_buffer16_bit_access),
            self.features_16bit_storage
                .as_mut()
                .map(|s| &mut s.uniform_and_storage_buffer16_bit_access),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.uniform_and_storage_buffer16_bit_access as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.uniform_and_storage_buffer8_bit_access),
            self.features_8bit_storage
                .as_mut()
                .map(|s| &mut s.uniform_and_storage_buffer8_bit_access),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.uniform_and_storage_buffer8_bit_access as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.uniform_buffer_standard_layout),
            self.features_uniform_buffer_standard_layout
                .as_mut()
                .map(|s| &mut s.uniform_buffer_standard_layout),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.uniform_buffer_standard_layout as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.variable_multisample_rate])
            .next()
            .map(|f| *f = features.variable_multisample_rate as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.variable_pointers),
            self.features_variable_pointers
                .as_mut()
                .map(|s| &mut s.variable_pointers),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.variable_pointers as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan11
                .as_mut()
                .map(|s| &mut s.variable_pointers_storage_buffer),
            self.features_variable_pointers
                .as_mut()
                .map(|s| &mut s.variable_pointers_storage_buffer),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.variable_pointers_storage_buffer as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_portability_subset_khr
            .as_mut()
            .map(|s| &mut s.vertex_attribute_access_beyond_stride)])
        .flatten()
        .next()
        .map(|f| *f = features.vertex_attribute_access_beyond_stride as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vertex_attribute_divisor_ext
            .as_mut()
            .map(|s| &mut s.vertex_attribute_instance_rate_divisor)])
        .flatten()
        .next()
        .map(|f| *f = features.vertex_attribute_instance_rate_divisor as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vertex_attribute_divisor_ext
            .as_mut()
            .map(|s| &mut s.vertex_attribute_instance_rate_zero_divisor)])
        .flatten()
        .next()
        .map(|f| *f = features.vertex_attribute_instance_rate_zero_divisor as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_vertex_input_dynamic_state_ext
            .as_mut()
            .map(|s| &mut s.vertex_input_dynamic_state)])
        .flatten()
        .next()
        .map(|f| *f = features.vertex_input_dynamic_state as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self
            .features_vulkan10
            .features
            .vertex_pipeline_stores_and_atomics])
        .next()
        .map(|f| *f = features.vertex_pipeline_stores_and_atomics as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model),
            self.features_vulkan_memory_model
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.vulkan_memory_model as ash::vk::Bool32);
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model_availability_visibility_chains),
            self.features_vulkan_memory_model
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model_availability_visibility_chains),
        ])
        .flatten()
        .next()
        .map(|f| {
            *f = features.vulkan_memory_model_availability_visibility_chains as ash::vk::Bool32
        });
        std::array::IntoIter::new([
            self.features_vulkan12
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model_device_scope),
            self.features_vulkan_memory_model
                .as_mut()
                .map(|s| &mut s.vulkan_memory_model_device_scope),
        ])
        .flatten()
        .next()
        .map(|f| *f = features.vulkan_memory_model_device_scope as ash::vk::Bool32);
        std::array::IntoIter::new([&mut self.features_vulkan10.features.wide_lines])
            .next()
            .map(|f| *f = features.wide_lines as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_workgroup_memory_explicit_layout_khr
            .as_mut()
            .map(|s| &mut s.workgroup_memory_explicit_layout)])
        .flatten()
        .next()
        .map(|f| *f = features.workgroup_memory_explicit_layout as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_workgroup_memory_explicit_layout_khr
            .as_mut()
            .map(|s| &mut s.workgroup_memory_explicit_layout16_bit_access)])
        .flatten()
        .next()
        .map(|f| *f = features.workgroup_memory_explicit_layout16_bit_access as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_workgroup_memory_explicit_layout_khr
            .as_mut()
            .map(|s| &mut s.workgroup_memory_explicit_layout8_bit_access)])
        .flatten()
        .next()
        .map(|f| *f = features.workgroup_memory_explicit_layout8_bit_access as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_workgroup_memory_explicit_layout_khr
            .as_mut()
            .map(|s| &mut s.workgroup_memory_explicit_layout_scalar_block_layout)])
        .flatten()
        .next()
        .map(|f| {
            *f = features.workgroup_memory_explicit_layout_scalar_block_layout as ash::vk::Bool32
        });
        std::array::IntoIter::new([self
            .features_ycbcr2_plane444_formats_ext
            .as_mut()
            .map(|s| &mut s.ycbcr2plane444_formats)])
        .flatten()
        .next()
        .map(|f| *f = features.ycbcr2plane444_formats as ash::vk::Bool32);
        std::array::IntoIter::new([self
            .features_ycbcr_image_arrays_ext
            .as_mut()
            .map(|s| &mut s.ycbcr_image_arrays)])
        .flatten()
        .next()
        .map(|f| *f = features.ycbcr_image_arrays as ash::vk::Bool32);
    }
}
impl From<&FeaturesFfi> for Features {
    fn from(features_ffi: &FeaturesFfi) -> Self {
        Features {
            acceleration_structure: std::array::IntoIter::new([features_ffi
                .features_acceleration_structure_khr
                .map(|s| s.acceleration_structure)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            acceleration_structure_capture_replay: std::array::IntoIter::new([features_ffi
                .features_acceleration_structure_khr
                .map(|s| s.acceleration_structure_capture_replay)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            acceleration_structure_host_commands: std::array::IntoIter::new([features_ffi
                .features_acceleration_structure_khr
                .map(|s| s.acceleration_structure_host_commands)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            acceleration_structure_indirect_build: std::array::IntoIter::new([features_ffi
                .features_acceleration_structure_khr
                .map(|s| s.acceleration_structure_indirect_build)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            advanced_blend_coherent_operations: std::array::IntoIter::new([features_ffi
                .features_blend_operation_advanced_ext
                .map(|s| s.advanced_blend_coherent_operations)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            alpha_to_one: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .alpha_to_one])
            .next()
            .unwrap_or(0)
                != 0,
            attachment_fragment_shading_rate: std::array::IntoIter::new([features_ffi
                .features_fragment_shading_rate_khr
                .map(|s| s.attachment_fragment_shading_rate)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            bresenham_lines: std::array::IntoIter::new([features_ffi
                .features_line_rasterization_ext
                .map(|s| s.bresenham_lines)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            buffer_device_address: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.buffer_device_address),
                features_ffi
                    .features_buffer_device_address
                    .map(|s| s.buffer_device_address),
                features_ffi
                    .features_buffer_device_address_ext
                    .map(|s| s.buffer_device_address),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            buffer_device_address_capture_replay: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.buffer_device_address_capture_replay),
                features_ffi
                    .features_buffer_device_address
                    .map(|s| s.buffer_device_address_capture_replay),
                features_ffi
                    .features_buffer_device_address_ext
                    .map(|s| s.buffer_device_address_capture_replay),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            buffer_device_address_multi_device: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.buffer_device_address_multi_device),
                features_ffi
                    .features_buffer_device_address
                    .map(|s| s.buffer_device_address_multi_device),
                features_ffi
                    .features_buffer_device_address_ext
                    .map(|s| s.buffer_device_address_multi_device),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            color_write_enable: std::array::IntoIter::new([features_ffi
                .features_color_write_enable_ext
                .map(|s| s.color_write_enable)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            compute_derivative_group_linear: std::array::IntoIter::new([features_ffi
                .features_compute_shader_derivatives_nv
                .map(|s| s.compute_derivative_group_linear)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            compute_derivative_group_quads: std::array::IntoIter::new([features_ffi
                .features_compute_shader_derivatives_nv
                .map(|s| s.compute_derivative_group_quads)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            compute_full_subgroups: std::array::IntoIter::new([features_ffi
                .features_subgroup_size_control_ext
                .map(|s| s.compute_full_subgroups)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            conditional_rendering: std::array::IntoIter::new([features_ffi
                .features_conditional_rendering_ext
                .map(|s| s.conditional_rendering)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            constant_alpha_color_blend_factors: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.constant_alpha_color_blend_factors)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            cooperative_matrix: std::array::IntoIter::new([features_ffi
                .features_cooperative_matrix_nv
                .map(|s| s.cooperative_matrix)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            cooperative_matrix_robust_buffer_access: std::array::IntoIter::new([features_ffi
                .features_cooperative_matrix_nv
                .map(|s| s.cooperative_matrix_robust_buffer_access)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            corner_sampled_image: std::array::IntoIter::new([features_ffi
                .features_corner_sampled_image_nv
                .map(|s| s.corner_sampled_image)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            coverage_reduction_mode: std::array::IntoIter::new([features_ffi
                .features_coverage_reduction_mode_nv
                .map(|s| s.coverage_reduction_mode)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            custom_border_color_without_format: std::array::IntoIter::new([features_ffi
                .features_custom_border_color_ext
                .map(|s| s.custom_border_color_without_format)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            custom_border_colors: std::array::IntoIter::new([features_ffi
                .features_custom_border_color_ext
                .map(|s| s.custom_border_colors)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            decode_mode_shared_exponent: std::array::IntoIter::new([features_ffi
                .features_astc_decode_ext
                .map(|s| s.decode_mode_shared_exponent)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            dedicated_allocation_image_aliasing: std::array::IntoIter::new([features_ffi
                .features_dedicated_allocation_image_aliasing_nv
                .map(|s| s.dedicated_allocation_image_aliasing)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            depth_bias_clamp: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .depth_bias_clamp])
            .next()
            .unwrap_or(0)
                != 0,
            depth_bounds: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .depth_bounds])
            .next()
            .unwrap_or(0)
                != 0,
            depth_clamp: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .depth_clamp])
            .next()
            .unwrap_or(0)
                != 0,
            depth_clip_enable: std::array::IntoIter::new([features_ffi
                .features_depth_clip_enable_ext
                .map(|s| s.depth_clip_enable)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_acceleration_structure_update_after_bind: std::array::IntoIter::new(
                [features_ffi
                    .features_acceleration_structure_khr
                    .map(|s| s.descriptor_binding_acceleration_structure_update_after_bind)],
            )
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_inline_uniform_block_update_after_bind: std::array::IntoIter::new([
                features_ffi
                    .features_inline_uniform_block_ext
                    .map(|s| s.descriptor_binding_inline_uniform_block_update_after_bind),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_partially_bound: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_partially_bound),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_partially_bound),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_sampled_image_update_after_bind: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_sampled_image_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_sampled_image_update_after_bind),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_storage_buffer_update_after_bind: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_storage_buffer_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_storage_buffer_update_after_bind),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_storage_image_update_after_bind: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_storage_image_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_storage_image_update_after_bind),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_storage_texel_buffer_update_after_bind: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_storage_texel_buffer_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_storage_texel_buffer_update_after_bind),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_uniform_buffer_update_after_bind: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_uniform_buffer_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_uniform_buffer_update_after_bind),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_uniform_texel_buffer_update_after_bind: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_uniform_texel_buffer_update_after_bind),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_uniform_texel_buffer_update_after_bind),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_update_unused_while_pending: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_update_unused_while_pending),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_update_unused_while_pending),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_binding_variable_descriptor_count: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.descriptor_binding_variable_descriptor_count),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.descriptor_binding_variable_descriptor_count),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            descriptor_indexing: std::array::IntoIter::new([features_ffi
                .features_vulkan12
                .map(|s| s.descriptor_indexing)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            device_coherent_memory: std::array::IntoIter::new([features_ffi
                .features_coherent_memory_amd
                .map(|s| s.device_coherent_memory)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            device_generated_commands: std::array::IntoIter::new([features_ffi
                .features_device_generated_commands_nv
                .map(|s| s.device_generated_commands)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            device_memory_report: std::array::IntoIter::new([features_ffi
                .features_device_memory_report_ext
                .map(|s| s.device_memory_report)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            diagnostics_config: std::array::IntoIter::new([features_ffi
                .features_diagnostics_config_nv
                .map(|s| s.diagnostics_config)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            draw_indirect_count: std::array::IntoIter::new([features_ffi
                .features_vulkan12
                .map(|s| s.draw_indirect_count)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            draw_indirect_first_instance: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .draw_indirect_first_instance])
            .next()
            .unwrap_or(0)
                != 0,
            dual_src_blend: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .dual_src_blend])
            .next()
            .unwrap_or(0)
                != 0,
            events: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.events)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            exclusive_scissor: std::array::IntoIter::new([features_ffi
                .features_exclusive_scissor_nv
                .map(|s| s.exclusive_scissor)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            extended_dynamic_state: std::array::IntoIter::new([features_ffi
                .features_extended_dynamic_state_ext
                .map(|s| s.extended_dynamic_state)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            extended_dynamic_state2: std::array::IntoIter::new([features_ffi
                .features_extended_dynamic_state2_ext
                .map(|s| s.extended_dynamic_state2)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            extended_dynamic_state2_logic_op: std::array::IntoIter::new([features_ffi
                .features_extended_dynamic_state2_ext
                .map(|s| s.extended_dynamic_state2_logic_op)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            extended_dynamic_state2_patch_control_points: std::array::IntoIter::new([features_ffi
                .features_extended_dynamic_state2_ext
                .map(|s| s.extended_dynamic_state2_patch_control_points)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            external_memory_rdma: std::array::IntoIter::new([features_ffi
                .features_external_memory_rdma_nv
                .map(|s| s.external_memory_rdma)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fill_mode_non_solid: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .fill_mode_non_solid])
            .next()
            .unwrap_or(0)
                != 0,
            format_a4b4g4r4: std::array::IntoIter::new([features_ffi
                .features_4444formats_ext
                .map(|s| s.format_a4b4g4r4)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            format_a4r4g4b4: std::array::IntoIter::new([features_ffi
                .features_4444formats_ext
                .map(|s| s.format_a4r4g4b4)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_density_map: std::array::IntoIter::new([features_ffi
                .features_fragment_density_map_ext
                .map(|s| s.fragment_density_map)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_density_map_deferred: std::array::IntoIter::new([features_ffi
                .features_fragment_density_map2_ext
                .map(|s| s.fragment_density_map_deferred)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_density_map_dynamic: std::array::IntoIter::new([features_ffi
                .features_fragment_density_map_ext
                .map(|s| s.fragment_density_map_dynamic)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_density_map_non_subsampled_images: std::array::IntoIter::new([features_ffi
                .features_fragment_density_map_ext
                .map(|s| s.fragment_density_map_non_subsampled_images)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_shader_barycentric: std::array::IntoIter::new([features_ffi
                .features_fragment_shader_barycentric_nv
                .map(|s| s.fragment_shader_barycentric)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_shader_pixel_interlock: std::array::IntoIter::new([features_ffi
                .features_fragment_shader_interlock_ext
                .map(|s| s.fragment_shader_pixel_interlock)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_shader_sample_interlock: std::array::IntoIter::new([features_ffi
                .features_fragment_shader_interlock_ext
                .map(|s| s.fragment_shader_sample_interlock)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_shader_shading_rate_interlock: std::array::IntoIter::new([features_ffi
                .features_fragment_shader_interlock_ext
                .map(|s| s.fragment_shader_shading_rate_interlock)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_shading_rate_enums: std::array::IntoIter::new([features_ffi
                .features_fragment_shading_rate_enums_nv
                .map(|s| s.fragment_shading_rate_enums)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            fragment_stores_and_atomics: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .fragment_stores_and_atomics])
            .next()
            .unwrap_or(0)
                != 0,
            full_draw_index_uint32: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .full_draw_index_uint32])
            .next()
            .unwrap_or(0)
                != 0,
            geometry_shader: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .geometry_shader])
            .next()
            .unwrap_or(0)
                != 0,
            geometry_streams: std::array::IntoIter::new([features_ffi
                .features_transform_feedback_ext
                .map(|s| s.geometry_streams)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            global_priority_query: std::array::IntoIter::new([features_ffi
                .features_global_priority_query_ext
                .map(|s| s.global_priority_query)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            host_query_reset: std::array::IntoIter::new([
                features_ffi.features_vulkan12.map(|s| s.host_query_reset),
                features_ffi
                    .features_host_query_reset
                    .map(|s| s.host_query_reset),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            image_cube_array: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .image_cube_array])
            .next()
            .unwrap_or(0)
                != 0,
            image_footprint: std::array::IntoIter::new([features_ffi
                .features_shader_image_footprint_nv
                .map(|s| s.image_footprint)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            image_view2_d_on3_d_image: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.image_view2_d_on3_d_image)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            image_view_format_reinterpretation: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.image_view_format_reinterpretation)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            image_view_format_swizzle: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.image_view_format_swizzle)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            imageless_framebuffer: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.imageless_framebuffer),
                features_ffi
                    .features_imageless_framebuffer
                    .map(|s| s.imageless_framebuffer),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            independent_blend: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .independent_blend])
            .next()
            .unwrap_or(0)
                != 0,
            index_type_uint8: std::array::IntoIter::new([features_ffi
                .features_index_type_uint8_ext
                .map(|s| s.index_type_uint8)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            inherited_conditional_rendering: std::array::IntoIter::new([features_ffi
                .features_conditional_rendering_ext
                .map(|s| s.inherited_conditional_rendering)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            inherited_queries: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .inherited_queries])
            .next()
            .unwrap_or(0)
                != 0,
            inherited_viewport_scissor2_d: std::array::IntoIter::new([features_ffi
                .features_inherited_viewport_scissor_nv
                .map(|s| s.inherited_viewport_scissor2_d)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            inline_uniform_block: std::array::IntoIter::new([features_ffi
                .features_inline_uniform_block_ext
                .map(|s| s.inline_uniform_block)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            invocation_mask: std::array::IntoIter::new([features_ffi
                .features_invocation_mask_huawei
                .map(|s| s.invocation_mask)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            large_points: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .large_points])
            .next()
            .unwrap_or(0)
                != 0,
            logic_op: std::array::IntoIter::new([features_ffi.features_vulkan10.features.logic_op])
                .next()
                .unwrap_or(0)
                != 0,
            memory_priority: std::array::IntoIter::new([features_ffi
                .features_memory_priority_ext
                .map(|s| s.memory_priority)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            mesh_shader: std::array::IntoIter::new([features_ffi
                .features_mesh_shader_nv
                .map(|s| s.mesh_shader)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            multi_draw: std::array::IntoIter::new([features_ffi
                .features_multi_draw_ext
                .map(|s| s.multi_draw)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            multi_draw_indirect: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .multi_draw_indirect])
            .next()
            .unwrap_or(0)
                != 0,
            multi_viewport: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .multi_viewport])
            .next()
            .unwrap_or(0)
                != 0,
            multisample_array_image: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.multisample_array_image)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            multiview: std::array::IntoIter::new([
                features_ffi.features_vulkan11.map(|s| s.multiview),
                features_ffi.features_multiview.map(|s| s.multiview),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            multiview_geometry_shader: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan11
                    .map(|s| s.multiview_geometry_shader),
                features_ffi
                    .features_multiview
                    .map(|s| s.multiview_geometry_shader),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            multiview_tessellation_shader: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan11
                    .map(|s| s.multiview_tessellation_shader),
                features_ffi
                    .features_multiview
                    .map(|s| s.multiview_tessellation_shader),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            mutable_comparison_samplers: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.mutable_comparison_samplers)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            mutable_descriptor_type: std::array::IntoIter::new([features_ffi
                .features_mutable_descriptor_type_valve
                .map(|s| s.mutable_descriptor_type)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            no_invocation_fragment_shading_rates: std::array::IntoIter::new([features_ffi
                .features_fragment_shading_rate_enums_nv
                .map(|s| s.no_invocation_fragment_shading_rates)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            null_descriptor: std::array::IntoIter::new([features_ffi
                .features_robustness2_ext
                .map(|s| s.null_descriptor)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            occlusion_query_precise: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .occlusion_query_precise])
            .next()
            .unwrap_or(0)
                != 0,
            pageable_device_local_memory: std::array::IntoIter::new([features_ffi
                .features_pageable_device_local_memory_ext
                .map(|s| s.pageable_device_local_memory)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            performance_counter_multiple_query_pools: std::array::IntoIter::new([features_ffi
                .features_performance_query_khr
                .map(|s| s.performance_counter_multiple_query_pools)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            performance_counter_query_pools: std::array::IntoIter::new([features_ffi
                .features_performance_query_khr
                .map(|s| s.performance_counter_query_pools)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            pipeline_creation_cache_control: std::array::IntoIter::new([features_ffi
                .features_pipeline_creation_cache_control_ext
                .map(|s| s.pipeline_creation_cache_control)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            pipeline_executable_info: std::array::IntoIter::new([features_ffi
                .features_pipeline_executable_properties_khr
                .map(|s| s.pipeline_executable_info)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            pipeline_fragment_shading_rate: std::array::IntoIter::new([features_ffi
                .features_fragment_shading_rate_khr
                .map(|s| s.pipeline_fragment_shading_rate)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            pipeline_statistics_query: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .pipeline_statistics_query])
            .next()
            .unwrap_or(0)
                != 0,
            point_polygons: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.point_polygons)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            present_id: std::array::IntoIter::new([features_ffi
                .features_present_id_khr
                .map(|s| s.present_id)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            present_wait: std::array::IntoIter::new([features_ffi
                .features_present_wait_khr
                .map(|s| s.present_wait)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            primitive_fragment_shading_rate: std::array::IntoIter::new([features_ffi
                .features_fragment_shading_rate_khr
                .map(|s| s.primitive_fragment_shading_rate)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            primitive_topology_list_restart: std::array::IntoIter::new([features_ffi
                .features_primitive_topology_list_restart_ext
                .map(|s| s.primitive_topology_list_restart)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            primitive_topology_patch_list_restart: std::array::IntoIter::new([features_ffi
                .features_primitive_topology_list_restart_ext
                .map(|s| s.primitive_topology_patch_list_restart)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            private_data: std::array::IntoIter::new([features_ffi
                .features_private_data_ext
                .map(|s| s.private_data)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            protected_memory: std::array::IntoIter::new([
                features_ffi.features_vulkan11.map(|s| s.protected_memory),
                features_ffi
                    .features_protected_memory
                    .map(|s| s.protected_memory),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            provoking_vertex_last: std::array::IntoIter::new([features_ffi
                .features_provoking_vertex_ext
                .map(|s| s.provoking_vertex_last)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            ray_query: std::array::IntoIter::new([features_ffi
                .features_ray_query_khr
                .map(|s| s.ray_query)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            ray_tracing_motion_blur: std::array::IntoIter::new([features_ffi
                .features_ray_tracing_motion_blur_nv
                .map(|s| s.ray_tracing_motion_blur)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            ray_tracing_motion_blur_pipeline_trace_rays_indirect: std::array::IntoIter::new([
                features_ffi
                    .features_ray_tracing_motion_blur_nv
                    .map(|s| s.ray_tracing_motion_blur_pipeline_trace_rays_indirect),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            ray_tracing_pipeline: std::array::IntoIter::new([features_ffi
                .features_ray_tracing_pipeline_khr
                .map(|s| s.ray_tracing_pipeline)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            ray_tracing_pipeline_shader_group_handle_capture_replay: std::array::IntoIter::new([
                features_ffi
                    .features_ray_tracing_pipeline_khr
                    .map(|s| s.ray_tracing_pipeline_shader_group_handle_capture_replay),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            ray_tracing_pipeline_shader_group_handle_capture_replay_mixed:
                std::array::IntoIter::new([features_ffi
                    .features_ray_tracing_pipeline_khr
                    .map(|s| s.ray_tracing_pipeline_shader_group_handle_capture_replay_mixed)])
                .flatten()
                .next()
                .unwrap_or(0)
                    != 0,
            ray_tracing_pipeline_trace_rays_indirect: std::array::IntoIter::new([features_ffi
                .features_ray_tracing_pipeline_khr
                .map(|s| s.ray_tracing_pipeline_trace_rays_indirect)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            ray_traversal_primitive_culling: std::array::IntoIter::new([features_ffi
                .features_ray_tracing_pipeline_khr
                .map(|s| s.ray_traversal_primitive_culling)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            rectangular_lines: std::array::IntoIter::new([features_ffi
                .features_line_rasterization_ext
                .map(|s| s.rectangular_lines)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            representative_fragment_test: std::array::IntoIter::new([features_ffi
                .features_representative_fragment_test_nv
                .map(|s| s.representative_fragment_test)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            robust_buffer_access: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .robust_buffer_access])
            .next()
            .unwrap_or(0)
                != 0,
            robust_buffer_access2: std::array::IntoIter::new([features_ffi
                .features_robustness2_ext
                .map(|s| s.robust_buffer_access2)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            robust_image_access: std::array::IntoIter::new([features_ffi
                .features_image_robustness_ext
                .map(|s| s.robust_image_access)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            robust_image_access2: std::array::IntoIter::new([features_ffi
                .features_robustness2_ext
                .map(|s| s.robust_image_access2)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            runtime_descriptor_array: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.runtime_descriptor_array),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.runtime_descriptor_array),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            sample_rate_shading: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sample_rate_shading])
            .next()
            .unwrap_or(0)
                != 0,
            sampler_anisotropy: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sampler_anisotropy])
            .next()
            .unwrap_or(0)
                != 0,
            sampler_filter_minmax: std::array::IntoIter::new([features_ffi
                .features_vulkan12
                .map(|s| s.sampler_filter_minmax)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            sampler_mip_lod_bias: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.sampler_mip_lod_bias)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            sampler_mirror_clamp_to_edge: std::array::IntoIter::new([features_ffi
                .features_vulkan12
                .map(|s| s.sampler_mirror_clamp_to_edge)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            sampler_ycbcr_conversion: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan11
                    .map(|s| s.sampler_ycbcr_conversion),
                features_ffi
                    .features_sampler_ycbcr_conversion
                    .map(|s| s.sampler_ycbcr_conversion),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            scalar_block_layout: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.scalar_block_layout),
                features_ffi
                    .features_scalar_block_layout
                    .map(|s| s.scalar_block_layout),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            separate_depth_stencil_layouts: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.separate_depth_stencil_layouts),
                features_ffi
                    .features_separate_depth_stencil_layouts
                    .map(|s| s.separate_depth_stencil_layouts),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            separate_stencil_mask_ref: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.separate_stencil_mask_ref)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_float16_atomic_add: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_buffer_float16_atomic_add)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_float16_atomic_min_max: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_buffer_float16_atomic_min_max)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_float16_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_buffer_float16_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_float32_atomic_add: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_buffer_float32_atomic_add)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_float32_atomic_min_max: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_buffer_float32_atomic_min_max)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_float32_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_buffer_float32_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_float64_atomic_add: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_buffer_float64_atomic_add)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_float64_atomic_min_max: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_buffer_float64_atomic_min_max)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_float64_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_buffer_float64_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_buffer_int64_atomics: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_buffer_int64_atomics),
                features_ffi
                    .features_shader_atomic_int64
                    .map(|s| s.shader_buffer_int64_atomics),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_clip_distance: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_clip_distance])
            .next()
            .unwrap_or(0)
                != 0,
            shader_cull_distance: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_cull_distance])
            .next()
            .unwrap_or(0)
                != 0,
            shader_demote_to_helper_invocation: std::array::IntoIter::new([features_ffi
                .features_shader_demote_to_helper_invocation_ext
                .map(|s| s.shader_demote_to_helper_invocation)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_device_clock: std::array::IntoIter::new([features_ffi
                .features_shader_clock_khr
                .map(|s| s.shader_device_clock)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_draw_parameters: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan11
                    .map(|s| s.shader_draw_parameters),
                features_ffi
                    .features_shader_draw_parameters
                    .map(|s| s.shader_draw_parameters),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_float16: std::array::IntoIter::new([
                features_ffi.features_vulkan12.map(|s| s.shader_float16),
                features_ffi
                    .features_shader_float16_int8
                    .map(|s| s.shader_float16),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_float64: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_float64])
            .next()
            .unwrap_or(0)
                != 0,
            shader_image_float32_atomic_add: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_image_float32_atomic_add)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_image_float32_atomic_min_max: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_image_float32_atomic_min_max)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_image_float32_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_image_float32_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_image_gather_extended: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_image_gather_extended])
            .next()
            .unwrap_or(0)
                != 0,
            shader_image_int64_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_image_atomic_int64_ext
                .map(|s| s.shader_image_int64_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_input_attachment_array_dynamic_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_input_attachment_array_dynamic_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_input_attachment_array_dynamic_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_input_attachment_array_non_uniform_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_input_attachment_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_input_attachment_array_non_uniform_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_int16: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_int16])
            .next()
            .unwrap_or(0)
                != 0,
            shader_int64: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_int64])
            .next()
            .unwrap_or(0)
                != 0,
            shader_int8: std::array::IntoIter::new([
                features_ffi.features_vulkan12.map(|s| s.shader_int8),
                features_ffi
                    .features_shader_float16_int8
                    .map(|s| s.shader_int8),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_integer_dot_product: std::array::IntoIter::new([features_ffi
                .features_shader_integer_dot_product_khr
                .map(|s| s.shader_integer_dot_product)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_integer_functions2: std::array::IntoIter::new([features_ffi
                .features_shader_integer_functions2_intel
                .map(|s| s.shader_integer_functions2)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_output_layer: std::array::IntoIter::new([features_ffi
                .features_vulkan12
                .map(|s| s.shader_output_layer)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_output_viewport_index: std::array::IntoIter::new([features_ffi
                .features_vulkan12
                .map(|s| s.shader_output_viewport_index)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_resource_min_lod: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_resource_min_lod])
            .next()
            .unwrap_or(0)
                != 0,
            shader_resource_residency: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_resource_residency])
            .next()
            .unwrap_or(0)
                != 0,
            shader_sample_rate_interpolation_functions: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.shader_sample_rate_interpolation_functions)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_sampled_image_array_dynamic_indexing: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_sampled_image_array_dynamic_indexing])
            .next()
            .unwrap_or(0)
                != 0,
            shader_sampled_image_array_non_uniform_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_sampled_image_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_sampled_image_array_non_uniform_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_float16_atomic_add: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_shared_float16_atomic_add)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_float16_atomic_min_max: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_shared_float16_atomic_min_max)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_float16_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_shared_float16_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_float32_atomic_add: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_shared_float32_atomic_add)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_float32_atomic_min_max: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_shared_float32_atomic_min_max)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_float32_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_shared_float32_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_float64_atomic_add: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_shared_float64_atomic_add)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_float64_atomic_min_max: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.shader_shared_float64_atomic_min_max)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_float64_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.shader_shared_float64_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_shared_int64_atomics: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_shared_int64_atomics),
                features_ffi
                    .features_shader_atomic_int64
                    .map(|s| s.shader_shared_int64_atomics),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_sm_builtins: std::array::IntoIter::new([features_ffi
                .features_shader_sm_builtins_nv
                .map(|s| s.shader_sm_builtins)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_buffer_array_dynamic_indexing: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_storage_buffer_array_dynamic_indexing])
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_buffer_array_non_uniform_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_storage_buffer_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_storage_buffer_array_non_uniform_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_image_array_dynamic_indexing: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_storage_image_array_dynamic_indexing])
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_image_array_non_uniform_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_storage_image_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_storage_image_array_non_uniform_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_image_extended_formats: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_storage_image_extended_formats])
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_image_multisample: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_storage_image_multisample])
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_image_read_without_format: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_storage_image_read_without_format])
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_image_write_without_format: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_storage_image_write_without_format])
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_texel_buffer_array_dynamic_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_storage_texel_buffer_array_dynamic_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_storage_texel_buffer_array_dynamic_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_storage_texel_buffer_array_non_uniform_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_storage_texel_buffer_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_storage_texel_buffer_array_non_uniform_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_subgroup_clock: std::array::IntoIter::new([features_ffi
                .features_shader_clock_khr
                .map(|s| s.shader_subgroup_clock)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_subgroup_extended_types: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_subgroup_extended_types),
                features_ffi
                    .features_shader_subgroup_extended_types
                    .map(|s| s.shader_subgroup_extended_types),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_subgroup_uniform_control_flow: std::array::IntoIter::new([features_ffi
                .features_shader_subgroup_uniform_control_flow_khr
                .map(|s| s.shader_subgroup_uniform_control_flow)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_terminate_invocation: std::array::IntoIter::new([features_ffi
                .features_shader_terminate_invocation_khr
                .map(|s| s.shader_terminate_invocation)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_tessellation_and_geometry_point_size: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_tessellation_and_geometry_point_size])
            .next()
            .unwrap_or(0)
                != 0,
            shader_uniform_buffer_array_dynamic_indexing: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .shader_uniform_buffer_array_dynamic_indexing])
            .next()
            .unwrap_or(0)
                != 0,
            shader_uniform_buffer_array_non_uniform_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_uniform_buffer_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_uniform_buffer_array_non_uniform_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_uniform_texel_buffer_array_dynamic_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_uniform_texel_buffer_array_dynamic_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_uniform_texel_buffer_array_dynamic_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_uniform_texel_buffer_array_non_uniform_indexing: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.shader_uniform_texel_buffer_array_non_uniform_indexing),
                features_ffi
                    .features_descriptor_indexing
                    .map(|s| s.shader_uniform_texel_buffer_array_non_uniform_indexing),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shader_zero_initialize_workgroup_memory: std::array::IntoIter::new([features_ffi
                .features_zero_initialize_workgroup_memory_khr
                .map(|s| s.shader_zero_initialize_workgroup_memory)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shading_rate_coarse_sample_order: std::array::IntoIter::new([features_ffi
                .features_shading_rate_image_nv
                .map(|s| s.shading_rate_coarse_sample_order)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            shading_rate_image: std::array::IntoIter::new([features_ffi
                .features_shading_rate_image_nv
                .map(|s| s.shading_rate_image)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            smooth_lines: std::array::IntoIter::new([features_ffi
                .features_line_rasterization_ext
                .map(|s| s.smooth_lines)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            sparse_binding: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sparse_binding])
            .next()
            .unwrap_or(0)
                != 0,
            sparse_image_float32_atomic_add: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.sparse_image_float32_atomic_add)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            sparse_image_float32_atomic_min_max: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float2_ext
                .map(|s| s.sparse_image_float32_atomic_min_max)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            sparse_image_float32_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_atomic_float_ext
                .map(|s| s.sparse_image_float32_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            sparse_image_int64_atomics: std::array::IntoIter::new([features_ffi
                .features_shader_image_atomic_int64_ext
                .map(|s| s.sparse_image_int64_atomics)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            sparse_residency16_samples: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sparse_residency16_samples])
            .next()
            .unwrap_or(0)
                != 0,
            sparse_residency2_samples: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sparse_residency2_samples])
            .next()
            .unwrap_or(0)
                != 0,
            sparse_residency4_samples: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sparse_residency4_samples])
            .next()
            .unwrap_or(0)
                != 0,
            sparse_residency8_samples: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sparse_residency8_samples])
            .next()
            .unwrap_or(0)
                != 0,
            sparse_residency_aliased: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sparse_residency_aliased])
            .next()
            .unwrap_or(0)
                != 0,
            sparse_residency_buffer: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sparse_residency_buffer])
            .next()
            .unwrap_or(0)
                != 0,
            sparse_residency_image2_d: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sparse_residency_image2_d])
            .next()
            .unwrap_or(0)
                != 0,
            sparse_residency_image3_d: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .sparse_residency_image3_d])
            .next()
            .unwrap_or(0)
                != 0,
            stippled_bresenham_lines: std::array::IntoIter::new([features_ffi
                .features_line_rasterization_ext
                .map(|s| s.stippled_bresenham_lines)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            stippled_rectangular_lines: std::array::IntoIter::new([features_ffi
                .features_line_rasterization_ext
                .map(|s| s.stippled_rectangular_lines)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            stippled_smooth_lines: std::array::IntoIter::new([features_ffi
                .features_line_rasterization_ext
                .map(|s| s.stippled_smooth_lines)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            storage_buffer16_bit_access: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan11
                    .map(|s| s.storage_buffer16_bit_access),
                features_ffi
                    .features_16bit_storage
                    .map(|s| s.storage_buffer16_bit_access),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            storage_buffer8_bit_access: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.storage_buffer8_bit_access),
                features_ffi
                    .features_8bit_storage
                    .map(|s| s.storage_buffer8_bit_access),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            storage_input_output16: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan11
                    .map(|s| s.storage_input_output16),
                features_ffi
                    .features_16bit_storage
                    .map(|s| s.storage_input_output16),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            storage_push_constant16: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan11
                    .map(|s| s.storage_push_constant16),
                features_ffi
                    .features_16bit_storage
                    .map(|s| s.storage_push_constant16),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            storage_push_constant8: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.storage_push_constant8),
                features_ffi
                    .features_8bit_storage
                    .map(|s| s.storage_push_constant8),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            subgroup_broadcast_dynamic_id: std::array::IntoIter::new([features_ffi
                .features_vulkan12
                .map(|s| s.subgroup_broadcast_dynamic_id)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            subgroup_size_control: std::array::IntoIter::new([features_ffi
                .features_subgroup_size_control_ext
                .map(|s| s.subgroup_size_control)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            subpass_shading: std::array::IntoIter::new([features_ffi
                .features_subpass_shading_huawei
                .map(|s| s.subpass_shading)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            supersample_fragment_shading_rates: std::array::IntoIter::new([features_ffi
                .features_fragment_shading_rate_enums_nv
                .map(|s| s.supersample_fragment_shading_rates)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            synchronization2: std::array::IntoIter::new([features_ffi
                .features_synchronization2_khr
                .map(|s| s.synchronization2)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            task_shader: std::array::IntoIter::new([features_ffi
                .features_mesh_shader_nv
                .map(|s| s.task_shader)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            tessellation_isolines: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.tessellation_isolines)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            tessellation_point_mode: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.tessellation_point_mode)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            tessellation_shader: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .tessellation_shader])
            .next()
            .unwrap_or(0)
                != 0,
            texel_buffer_alignment: std::array::IntoIter::new([features_ffi
                .features_texel_buffer_alignment_ext
                .map(|s| s.texel_buffer_alignment)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            texture_compression_astc_hdr: std::array::IntoIter::new([features_ffi
                .features_texture_compression_astchdr_ext
                .map(|s| s.texture_compression_astc_hdr)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            texture_compression_astc_ldr: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .texture_compression_astc_ldr])
            .next()
            .unwrap_or(0)
                != 0,
            texture_compression_bc: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .texture_compression_bc])
            .next()
            .unwrap_or(0)
                != 0,
            texture_compression_etc2: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .texture_compression_etc2])
            .next()
            .unwrap_or(0)
                != 0,
            timeline_semaphore: std::array::IntoIter::new([
                features_ffi.features_vulkan12.map(|s| s.timeline_semaphore),
                features_ffi
                    .features_timeline_semaphore
                    .map(|s| s.timeline_semaphore),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            transform_feedback: std::array::IntoIter::new([features_ffi
                .features_transform_feedback_ext
                .map(|s| s.transform_feedback)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            transform_feedback_preserves_provoking_vertex: std::array::IntoIter::new([
                features_ffi
                    .features_provoking_vertex_ext
                    .map(|s| s.transform_feedback_preserves_provoking_vertex),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            triangle_fans: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.triangle_fans)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            uniform_and_storage_buffer16_bit_access: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan11
                    .map(|s| s.uniform_and_storage_buffer16_bit_access),
                features_ffi
                    .features_16bit_storage
                    .map(|s| s.uniform_and_storage_buffer16_bit_access),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            uniform_and_storage_buffer8_bit_access: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.uniform_and_storage_buffer8_bit_access),
                features_ffi
                    .features_8bit_storage
                    .map(|s| s.uniform_and_storage_buffer8_bit_access),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            uniform_buffer_standard_layout: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.uniform_buffer_standard_layout),
                features_ffi
                    .features_uniform_buffer_standard_layout
                    .map(|s| s.uniform_buffer_standard_layout),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            variable_multisample_rate: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .variable_multisample_rate])
            .next()
            .unwrap_or(0)
                != 0,
            variable_pointers: std::array::IntoIter::new([
                features_ffi.features_vulkan11.map(|s| s.variable_pointers),
                features_ffi
                    .features_variable_pointers
                    .map(|s| s.variable_pointers),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            variable_pointers_storage_buffer: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan11
                    .map(|s| s.variable_pointers_storage_buffer),
                features_ffi
                    .features_variable_pointers
                    .map(|s| s.variable_pointers_storage_buffer),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            vertex_attribute_access_beyond_stride: std::array::IntoIter::new([features_ffi
                .features_portability_subset_khr
                .map(|s| s.vertex_attribute_access_beyond_stride)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            vertex_attribute_instance_rate_divisor: std::array::IntoIter::new([features_ffi
                .features_vertex_attribute_divisor_ext
                .map(|s| s.vertex_attribute_instance_rate_divisor)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            vertex_attribute_instance_rate_zero_divisor: std::array::IntoIter::new([features_ffi
                .features_vertex_attribute_divisor_ext
                .map(|s| s.vertex_attribute_instance_rate_zero_divisor)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            vertex_input_dynamic_state: std::array::IntoIter::new([features_ffi
                .features_vertex_input_dynamic_state_ext
                .map(|s| s.vertex_input_dynamic_state)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            vertex_pipeline_stores_and_atomics: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .vertex_pipeline_stores_and_atomics])
            .next()
            .unwrap_or(0)
                != 0,
            vulkan_memory_model: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.vulkan_memory_model),
                features_ffi
                    .features_vulkan_memory_model
                    .map(|s| s.vulkan_memory_model),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            vulkan_memory_model_availability_visibility_chains: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.vulkan_memory_model_availability_visibility_chains),
                features_ffi
                    .features_vulkan_memory_model
                    .map(|s| s.vulkan_memory_model_availability_visibility_chains),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            vulkan_memory_model_device_scope: std::array::IntoIter::new([
                features_ffi
                    .features_vulkan12
                    .map(|s| s.vulkan_memory_model_device_scope),
                features_ffi
                    .features_vulkan_memory_model
                    .map(|s| s.vulkan_memory_model_device_scope),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            wide_lines: std::array::IntoIter::new([features_ffi
                .features_vulkan10
                .features
                .wide_lines])
            .next()
            .unwrap_or(0)
                != 0,
            workgroup_memory_explicit_layout: std::array::IntoIter::new([features_ffi
                .features_workgroup_memory_explicit_layout_khr
                .map(|s| s.workgroup_memory_explicit_layout)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            workgroup_memory_explicit_layout16_bit_access: std::array::IntoIter::new([
                features_ffi
                    .features_workgroup_memory_explicit_layout_khr
                    .map(|s| s.workgroup_memory_explicit_layout16_bit_access),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            workgroup_memory_explicit_layout8_bit_access: std::array::IntoIter::new([features_ffi
                .features_workgroup_memory_explicit_layout_khr
                .map(|s| s.workgroup_memory_explicit_layout8_bit_access)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            workgroup_memory_explicit_layout_scalar_block_layout: std::array::IntoIter::new([
                features_ffi
                    .features_workgroup_memory_explicit_layout_khr
                    .map(|s| s.workgroup_memory_explicit_layout_scalar_block_layout),
            ])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            ycbcr2plane444_formats: std::array::IntoIter::new([features_ffi
                .features_ycbcr2_plane444_formats_ext
                .map(|s| s.ycbcr2plane444_formats)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
            ycbcr_image_arrays: std::array::IntoIter::new([features_ffi
                .features_ycbcr_image_arrays_ext
                .map(|s| s.ycbcr_image_arrays)])
            .flatten()
            .next()
            .unwrap_or(0)
                != 0,
        }
    }
}
#[derive(Default)]
pub(crate) struct FeaturesFfi {
    features_vulkan10: ash::vk::PhysicalDeviceFeatures2KHR,
    features_vulkan11: Option<ash::vk::PhysicalDeviceVulkan11Features>,
    features_vulkan12: Option<ash::vk::PhysicalDeviceVulkan12Features>,
    features_16bit_storage: Option<ash::vk::PhysicalDevice16BitStorageFeatures>,
    features_multiview: Option<ash::vk::PhysicalDeviceMultiviewFeatures>,
    features_protected_memory: Option<ash::vk::PhysicalDeviceProtectedMemoryFeatures>,
    features_sampler_ycbcr_conversion:
        Option<ash::vk::PhysicalDeviceSamplerYcbcrConversionFeatures>,
    features_shader_draw_parameters: Option<ash::vk::PhysicalDeviceShaderDrawParametersFeatures>,
    features_variable_pointers: Option<ash::vk::PhysicalDeviceVariablePointersFeatures>,
    features_8bit_storage: Option<ash::vk::PhysicalDevice8BitStorageFeatures>,
    features_buffer_device_address: Option<ash::vk::PhysicalDeviceBufferDeviceAddressFeatures>,
    features_descriptor_indexing: Option<ash::vk::PhysicalDeviceDescriptorIndexingFeatures>,
    features_host_query_reset: Option<ash::vk::PhysicalDeviceHostQueryResetFeatures>,
    features_imageless_framebuffer: Option<ash::vk::PhysicalDeviceImagelessFramebufferFeatures>,
    features_scalar_block_layout: Option<ash::vk::PhysicalDeviceScalarBlockLayoutFeatures>,
    features_separate_depth_stencil_layouts:
        Option<ash::vk::PhysicalDeviceSeparateDepthStencilLayoutsFeatures>,
    features_shader_atomic_int64: Option<ash::vk::PhysicalDeviceShaderAtomicInt64Features>,
    features_shader_float16_int8: Option<ash::vk::PhysicalDeviceShaderFloat16Int8Features>,
    features_shader_subgroup_extended_types:
        Option<ash::vk::PhysicalDeviceShaderSubgroupExtendedTypesFeatures>,
    features_timeline_semaphore: Option<ash::vk::PhysicalDeviceTimelineSemaphoreFeatures>,
    features_uniform_buffer_standard_layout:
        Option<ash::vk::PhysicalDeviceUniformBufferStandardLayoutFeatures>,
    features_vulkan_memory_model: Option<ash::vk::PhysicalDeviceVulkanMemoryModelFeatures>,
    features_acceleration_structure_khr:
        Option<ash::vk::PhysicalDeviceAccelerationStructureFeaturesKHR>,
    features_fragment_shading_rate_khr:
        Option<ash::vk::PhysicalDeviceFragmentShadingRateFeaturesKHR>,
    features_performance_query_khr: Option<ash::vk::PhysicalDevicePerformanceQueryFeaturesKHR>,
    features_pipeline_executable_properties_khr:
        Option<ash::vk::PhysicalDevicePipelineExecutablePropertiesFeaturesKHR>,
    features_portability_subset_khr: Option<ash::vk::PhysicalDevicePortabilitySubsetFeaturesKHR>,
    features_present_id_khr: Option<ash::vk::PhysicalDevicePresentIdFeaturesKHR>,
    features_present_wait_khr: Option<ash::vk::PhysicalDevicePresentWaitFeaturesKHR>,
    features_ray_query_khr: Option<ash::vk::PhysicalDeviceRayQueryFeaturesKHR>,
    features_ray_tracing_pipeline_khr: Option<ash::vk::PhysicalDeviceRayTracingPipelineFeaturesKHR>,
    features_shader_clock_khr: Option<ash::vk::PhysicalDeviceShaderClockFeaturesKHR>,
    features_shader_integer_dot_product_khr:
        Option<ash::vk::PhysicalDeviceShaderIntegerDotProductFeaturesKHR>,
    features_shader_subgroup_uniform_control_flow_khr:
        Option<ash::vk::PhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>,
    features_shader_terminate_invocation_khr:
        Option<ash::vk::PhysicalDeviceShaderTerminateInvocationFeaturesKHR>,
    features_synchronization2_khr: Option<ash::vk::PhysicalDeviceSynchronization2FeaturesKHR>,
    features_workgroup_memory_explicit_layout_khr:
        Option<ash::vk::PhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>,
    features_zero_initialize_workgroup_memory_khr:
        Option<ash::vk::PhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR>,
    features_4444formats_ext: Option<ash::vk::PhysicalDevice4444FormatsFeaturesEXT>,
    features_astc_decode_ext: Option<ash::vk::PhysicalDeviceASTCDecodeFeaturesEXT>,
    features_blend_operation_advanced_ext:
        Option<ash::vk::PhysicalDeviceBlendOperationAdvancedFeaturesEXT>,
    features_buffer_device_address_ext:
        Option<ash::vk::PhysicalDeviceBufferDeviceAddressFeaturesEXT>,
    features_color_write_enable_ext: Option<ash::vk::PhysicalDeviceColorWriteEnableFeaturesEXT>,
    features_conditional_rendering_ext:
        Option<ash::vk::PhysicalDeviceConditionalRenderingFeaturesEXT>,
    features_custom_border_color_ext: Option<ash::vk::PhysicalDeviceCustomBorderColorFeaturesEXT>,
    features_depth_clip_enable_ext: Option<ash::vk::PhysicalDeviceDepthClipEnableFeaturesEXT>,
    features_device_memory_report_ext: Option<ash::vk::PhysicalDeviceDeviceMemoryReportFeaturesEXT>,
    features_extended_dynamic_state2_ext:
        Option<ash::vk::PhysicalDeviceExtendedDynamicState2FeaturesEXT>,
    features_extended_dynamic_state_ext:
        Option<ash::vk::PhysicalDeviceExtendedDynamicStateFeaturesEXT>,
    features_fragment_density_map2_ext:
        Option<ash::vk::PhysicalDeviceFragmentDensityMap2FeaturesEXT>,
    features_fragment_density_map_ext: Option<ash::vk::PhysicalDeviceFragmentDensityMapFeaturesEXT>,
    features_fragment_shader_interlock_ext:
        Option<ash::vk::PhysicalDeviceFragmentShaderInterlockFeaturesEXT>,
    features_global_priority_query_ext:
        Option<ash::vk::PhysicalDeviceGlobalPriorityQueryFeaturesEXT>,
    features_image_robustness_ext: Option<ash::vk::PhysicalDeviceImageRobustnessFeaturesEXT>,
    features_index_type_uint8_ext: Option<ash::vk::PhysicalDeviceIndexTypeUint8FeaturesEXT>,
    features_inline_uniform_block_ext: Option<ash::vk::PhysicalDeviceInlineUniformBlockFeaturesEXT>,
    features_line_rasterization_ext: Option<ash::vk::PhysicalDeviceLineRasterizationFeaturesEXT>,
    features_memory_priority_ext: Option<ash::vk::PhysicalDeviceMemoryPriorityFeaturesEXT>,
    features_multi_draw_ext: Option<ash::vk::PhysicalDeviceMultiDrawFeaturesEXT>,
    features_pageable_device_local_memory_ext:
        Option<ash::vk::PhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>,
    features_pipeline_creation_cache_control_ext:
        Option<ash::vk::PhysicalDevicePipelineCreationCacheControlFeaturesEXT>,
    features_primitive_topology_list_restart_ext:
        Option<ash::vk::PhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>,
    features_private_data_ext: Option<ash::vk::PhysicalDevicePrivateDataFeaturesEXT>,
    features_provoking_vertex_ext: Option<ash::vk::PhysicalDeviceProvokingVertexFeaturesEXT>,
    features_robustness2_ext: Option<ash::vk::PhysicalDeviceRobustness2FeaturesEXT>,
    features_shader_atomic_float2_ext: Option<ash::vk::PhysicalDeviceShaderAtomicFloat2FeaturesEXT>,
    features_shader_atomic_float_ext: Option<ash::vk::PhysicalDeviceShaderAtomicFloatFeaturesEXT>,
    features_shader_demote_to_helper_invocation_ext:
        Option<ash::vk::PhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>,
    features_shader_image_atomic_int64_ext:
        Option<ash::vk::PhysicalDeviceShaderImageAtomicInt64FeaturesEXT>,
    features_subgroup_size_control_ext:
        Option<ash::vk::PhysicalDeviceSubgroupSizeControlFeaturesEXT>,
    features_texel_buffer_alignment_ext:
        Option<ash::vk::PhysicalDeviceTexelBufferAlignmentFeaturesEXT>,
    features_texture_compression_astchdr_ext:
        Option<ash::vk::PhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>,
    features_transform_feedback_ext: Option<ash::vk::PhysicalDeviceTransformFeedbackFeaturesEXT>,
    features_vertex_attribute_divisor_ext:
        Option<ash::vk::PhysicalDeviceVertexAttributeDivisorFeaturesEXT>,
    features_vertex_input_dynamic_state_ext:
        Option<ash::vk::PhysicalDeviceVertexInputDynamicStateFeaturesEXT>,
    features_ycbcr2_plane444_formats_ext:
        Option<ash::vk::PhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>,
    features_ycbcr_image_arrays_ext: Option<ash::vk::PhysicalDeviceYcbcrImageArraysFeaturesEXT>,
    features_coherent_memory_amd: Option<ash::vk::PhysicalDeviceCoherentMemoryFeaturesAMD>,
    features_compute_shader_derivatives_nv:
        Option<ash::vk::PhysicalDeviceComputeShaderDerivativesFeaturesNV>,
    features_cooperative_matrix_nv: Option<ash::vk::PhysicalDeviceCooperativeMatrixFeaturesNV>,
    features_corner_sampled_image_nv: Option<ash::vk::PhysicalDeviceCornerSampledImageFeaturesNV>,
    features_coverage_reduction_mode_nv:
        Option<ash::vk::PhysicalDeviceCoverageReductionModeFeaturesNV>,
    features_dedicated_allocation_image_aliasing_nv:
        Option<ash::vk::PhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>,
    features_device_generated_commands_nv:
        Option<ash::vk::PhysicalDeviceDeviceGeneratedCommandsFeaturesNV>,
    features_diagnostics_config_nv: Option<ash::vk::PhysicalDeviceDiagnosticsConfigFeaturesNV>,
    features_exclusive_scissor_nv: Option<ash::vk::PhysicalDeviceExclusiveScissorFeaturesNV>,
    features_external_memory_rdma_nv: Option<ash::vk::PhysicalDeviceExternalMemoryRDMAFeaturesNV>,
    features_fragment_shader_barycentric_nv:
        Option<ash::vk::PhysicalDeviceFragmentShaderBarycentricFeaturesNV>,
    features_fragment_shading_rate_enums_nv:
        Option<ash::vk::PhysicalDeviceFragmentShadingRateEnumsFeaturesNV>,
    features_inherited_viewport_scissor_nv:
        Option<ash::vk::PhysicalDeviceInheritedViewportScissorFeaturesNV>,
    features_invocation_mask_huawei: Option<ash::vk::PhysicalDeviceInvocationMaskFeaturesHUAWEI>,
    features_mesh_shader_nv: Option<ash::vk::PhysicalDeviceMeshShaderFeaturesNV>,
    features_mutable_descriptor_type_valve:
        Option<ash::vk::PhysicalDeviceMutableDescriptorTypeFeaturesVALVE>,
    features_ray_tracing_motion_blur_nv:
        Option<ash::vk::PhysicalDeviceRayTracingMotionBlurFeaturesNV>,
    features_representative_fragment_test_nv:
        Option<ash::vk::PhysicalDeviceRepresentativeFragmentTestFeaturesNV>,
    features_shader_image_footprint_nv:
        Option<ash::vk::PhysicalDeviceShaderImageFootprintFeaturesNV>,
    features_shader_integer_functions2_intel:
        Option<ash::vk::PhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>,
    features_shader_sm_builtins_nv: Option<ash::vk::PhysicalDeviceShaderSMBuiltinsFeaturesNV>,
    features_shading_rate_image_nv: Option<ash::vk::PhysicalDeviceShadingRateImageFeaturesNV>,
    features_subpass_shading_huawei: Option<ash::vk::PhysicalDeviceSubpassShadingFeaturesHUAWEI>,
}
impl FeaturesFfi {
    pub(crate) fn make_chain(
        &mut self,
        api_version: Version,
        device_extensions: &DeviceExtensions,
        instance_extensions: &InstanceExtensions,
    ) {
        self.features_vulkan10 = Default::default();
        let head = &mut self.features_vulkan10;
        if std::array::IntoIter::new([api_version >= Version::V1_2]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_vulkan11 = Some(Default::default());
            let member = self.features_vulkan11.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([api_version >= Version::V1_2]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_vulkan12 = Some(Default::default());
            let member = self.features_vulkan12.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_1,
            device_extensions.khr_16bit_storage,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan11.is_none()]).all(|x| x)
        {
            self.features_16bit_storage = Some(Default::default());
            let member = self.features_16bit_storage.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_1,
            device_extensions.khr_multiview,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan11.is_none()]).all(|x| x)
        {
            self.features_multiview = Some(Default::default());
            let member = self.features_multiview.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([api_version >= Version::V1_1]).any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan11.is_none()]).all(|x| x)
        {
            self.features_protected_memory = Some(Default::default());
            let member = self.features_protected_memory.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_1,
            device_extensions.khr_sampler_ycbcr_conversion,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan11.is_none()]).all(|x| x)
        {
            self.features_sampler_ycbcr_conversion = Some(Default::default());
            let member = self.features_sampler_ycbcr_conversion.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([api_version >= Version::V1_1]).any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan11.is_none()]).all(|x| x)
        {
            self.features_shader_draw_parameters = Some(Default::default());
            let member = self.features_shader_draw_parameters.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_1,
            device_extensions.khr_variable_pointers,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan11.is_none()]).all(|x| x)
        {
            self.features_variable_pointers = Some(Default::default());
            let member = self.features_variable_pointers.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_8bit_storage,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_8bit_storage = Some(Default::default());
            let member = self.features_8bit_storage.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_buffer_device_address,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_buffer_device_address = Some(Default::default());
            let member = self.features_buffer_device_address.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.ext_descriptor_indexing,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_descriptor_indexing = Some(Default::default());
            let member = self.features_descriptor_indexing.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.ext_host_query_reset,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_host_query_reset = Some(Default::default());
            let member = self.features_host_query_reset.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_imageless_framebuffer,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_imageless_framebuffer = Some(Default::default());
            let member = self.features_imageless_framebuffer.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.ext_scalar_block_layout,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_scalar_block_layout = Some(Default::default());
            let member = self.features_scalar_block_layout.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_separate_depth_stencil_layouts,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_separate_depth_stencil_layouts = Some(Default::default());
            let member = self
                .features_separate_depth_stencil_layouts
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_shader_atomic_int64,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_shader_atomic_int64 = Some(Default::default());
            let member = self.features_shader_atomic_int64.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_shader_float16_int8,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_shader_float16_int8 = Some(Default::default());
            let member = self.features_shader_float16_int8.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_shader_subgroup_extended_types,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_shader_subgroup_extended_types = Some(Default::default());
            let member = self
                .features_shader_subgroup_extended_types
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_timeline_semaphore,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_timeline_semaphore = Some(Default::default());
            let member = self.features_timeline_semaphore.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_uniform_buffer_standard_layout,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_uniform_buffer_standard_layout = Some(Default::default());
            let member = self
                .features_uniform_buffer_standard_layout
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([
            api_version >= Version::V1_2,
            device_extensions.khr_vulkan_memory_model,
        ])
        .any(|x| x)
            && std::array::IntoIter::new([self.features_vulkan12.is_none()]).all(|x| x)
        {
            self.features_vulkan_memory_model = Some(Default::default());
            let member = self.features_vulkan_memory_model.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_acceleration_structure]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_acceleration_structure_khr = Some(Default::default());
            let member = self.features_acceleration_structure_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_fragment_shading_rate]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_fragment_shading_rate_khr = Some(Default::default());
            let member = self.features_fragment_shading_rate_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_performance_query]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_performance_query_khr = Some(Default::default());
            let member = self.features_performance_query_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_pipeline_executable_properties])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_pipeline_executable_properties_khr = Some(Default::default());
            let member = self
                .features_pipeline_executable_properties_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_portability_subset]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_portability_subset_khr = Some(Default::default());
            let member = self.features_portability_subset_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_present_id]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_present_id_khr = Some(Default::default());
            let member = self.features_present_id_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_present_wait]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_present_wait_khr = Some(Default::default());
            let member = self.features_present_wait_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_ray_query]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_ray_query_khr = Some(Default::default());
            let member = self.features_ray_query_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_ray_tracing_pipeline]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_ray_tracing_pipeline_khr = Some(Default::default());
            let member = self.features_ray_tracing_pipeline_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_shader_clock]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_clock_khr = Some(Default::default());
            let member = self.features_shader_clock_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_shader_integer_dot_product]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_integer_dot_product_khr = Some(Default::default());
            let member = self
                .features_shader_integer_dot_product_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_shader_subgroup_uniform_control_flow])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_subgroup_uniform_control_flow_khr = Some(Default::default());
            let member = self
                .features_shader_subgroup_uniform_control_flow_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_shader_terminate_invocation]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_terminate_invocation_khr = Some(Default::default());
            let member = self
                .features_shader_terminate_invocation_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_synchronization2]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_synchronization2_khr = Some(Default::default());
            let member = self.features_synchronization2_khr.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_workgroup_memory_explicit_layout])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_workgroup_memory_explicit_layout_khr = Some(Default::default());
            let member = self
                .features_workgroup_memory_explicit_layout_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.khr_zero_initialize_workgroup_memory])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_zero_initialize_workgroup_memory_khr = Some(Default::default());
            let member = self
                .features_zero_initialize_workgroup_memory_khr
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_4444_formats]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_4444formats_ext = Some(Default::default());
            let member = self.features_4444formats_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_astc_decode_mode]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_astc_decode_ext = Some(Default::default());
            let member = self.features_astc_decode_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_blend_operation_advanced]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_blend_operation_advanced_ext = Some(Default::default());
            let member = self.features_blend_operation_advanced_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_buffer_device_address]).any(|x| x)
            && std::array::IntoIter::new([
                self.features_vulkan12.is_none(),
                self.features_buffer_device_address.is_none(),
            ])
            .all(|x| x)
        {
            self.features_buffer_device_address_ext = Some(Default::default());
            let member = self.features_buffer_device_address_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_color_write_enable]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_color_write_enable_ext = Some(Default::default());
            let member = self.features_color_write_enable_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_conditional_rendering]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_conditional_rendering_ext = Some(Default::default());
            let member = self.features_conditional_rendering_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_custom_border_color]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_custom_border_color_ext = Some(Default::default());
            let member = self.features_custom_border_color_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_depth_clip_enable]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_depth_clip_enable_ext = Some(Default::default());
            let member = self.features_depth_clip_enable_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_device_memory_report]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_device_memory_report_ext = Some(Default::default());
            let member = self.features_device_memory_report_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_extended_dynamic_state2]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_extended_dynamic_state2_ext = Some(Default::default());
            let member = self.features_extended_dynamic_state2_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_extended_dynamic_state]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_extended_dynamic_state_ext = Some(Default::default());
            let member = self.features_extended_dynamic_state_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_fragment_density_map2]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_fragment_density_map2_ext = Some(Default::default());
            let member = self.features_fragment_density_map2_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_fragment_density_map]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_fragment_density_map_ext = Some(Default::default());
            let member = self.features_fragment_density_map_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_fragment_shader_interlock]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_fragment_shader_interlock_ext = Some(Default::default());
            let member = self
                .features_fragment_shader_interlock_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_global_priority_query]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_global_priority_query_ext = Some(Default::default());
            let member = self.features_global_priority_query_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_image_robustness]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_image_robustness_ext = Some(Default::default());
            let member = self.features_image_robustness_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_index_type_uint8]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_index_type_uint8_ext = Some(Default::default());
            let member = self.features_index_type_uint8_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_inline_uniform_block]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_inline_uniform_block_ext = Some(Default::default());
            let member = self.features_inline_uniform_block_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_line_rasterization]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_line_rasterization_ext = Some(Default::default());
            let member = self.features_line_rasterization_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_memory_priority]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_memory_priority_ext = Some(Default::default());
            let member = self.features_memory_priority_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_multi_draw]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_multi_draw_ext = Some(Default::default());
            let member = self.features_multi_draw_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_pageable_device_local_memory])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_pageable_device_local_memory_ext = Some(Default::default());
            let member = self
                .features_pageable_device_local_memory_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_pipeline_creation_cache_control])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_pipeline_creation_cache_control_ext = Some(Default::default());
            let member = self
                .features_pipeline_creation_cache_control_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_primitive_topology_list_restart])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_primitive_topology_list_restart_ext = Some(Default::default());
            let member = self
                .features_primitive_topology_list_restart_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_private_data]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_private_data_ext = Some(Default::default());
            let member = self.features_private_data_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_provoking_vertex]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_provoking_vertex_ext = Some(Default::default());
            let member = self.features_provoking_vertex_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_robustness2]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_robustness2_ext = Some(Default::default());
            let member = self.features_robustness2_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_shader_atomic_float2]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_atomic_float2_ext = Some(Default::default());
            let member = self.features_shader_atomic_float2_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_shader_atomic_float]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_atomic_float_ext = Some(Default::default());
            let member = self.features_shader_atomic_float_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_shader_demote_to_helper_invocation])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_demote_to_helper_invocation_ext = Some(Default::default());
            let member = self
                .features_shader_demote_to_helper_invocation_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_shader_image_atomic_int64]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_image_atomic_int64_ext = Some(Default::default());
            let member = self
                .features_shader_image_atomic_int64_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_subgroup_size_control]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_subgroup_size_control_ext = Some(Default::default());
            let member = self.features_subgroup_size_control_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_texel_buffer_alignment]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_texel_buffer_alignment_ext = Some(Default::default());
            let member = self.features_texel_buffer_alignment_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_texture_compression_astc_hdr])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_texture_compression_astchdr_ext = Some(Default::default());
            let member = self
                .features_texture_compression_astchdr_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_transform_feedback]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_transform_feedback_ext = Some(Default::default());
            let member = self.features_transform_feedback_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_vertex_attribute_divisor]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_vertex_attribute_divisor_ext = Some(Default::default());
            let member = self.features_vertex_attribute_divisor_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_vertex_input_dynamic_state]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_vertex_input_dynamic_state_ext = Some(Default::default());
            let member = self
                .features_vertex_input_dynamic_state_ext
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_ycbcr_2plane_444_formats]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_ycbcr2_plane444_formats_ext = Some(Default::default());
            let member = self.features_ycbcr2_plane444_formats_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.ext_ycbcr_image_arrays]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_ycbcr_image_arrays_ext = Some(Default::default());
            let member = self.features_ycbcr_image_arrays_ext.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.amd_device_coherent_memory]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_coherent_memory_amd = Some(Default::default());
            let member = self.features_coherent_memory_amd.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_compute_shader_derivatives]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_compute_shader_derivatives_nv = Some(Default::default());
            let member = self
                .features_compute_shader_derivatives_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_cooperative_matrix]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_cooperative_matrix_nv = Some(Default::default());
            let member = self.features_cooperative_matrix_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_corner_sampled_image]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_corner_sampled_image_nv = Some(Default::default());
            let member = self.features_corner_sampled_image_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_coverage_reduction_mode]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_coverage_reduction_mode_nv = Some(Default::default());
            let member = self.features_coverage_reduction_mode_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_dedicated_allocation_image_aliasing])
            .any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_dedicated_allocation_image_aliasing_nv = Some(Default::default());
            let member = self
                .features_dedicated_allocation_image_aliasing_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_device_generated_commands]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_device_generated_commands_nv = Some(Default::default());
            let member = self.features_device_generated_commands_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_device_diagnostics_config]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_diagnostics_config_nv = Some(Default::default());
            let member = self.features_diagnostics_config_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_scissor_exclusive]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_exclusive_scissor_nv = Some(Default::default());
            let member = self.features_exclusive_scissor_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_external_memory_rdma]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_external_memory_rdma_nv = Some(Default::default());
            let member = self.features_external_memory_rdma_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_fragment_shader_barycentric]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_fragment_shader_barycentric_nv = Some(Default::default());
            let member = self
                .features_fragment_shader_barycentric_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_fragment_shading_rate_enums]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_fragment_shading_rate_enums_nv = Some(Default::default());
            let member = self
                .features_fragment_shading_rate_enums_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_inherited_viewport_scissor]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_inherited_viewport_scissor_nv = Some(Default::default());
            let member = self
                .features_inherited_viewport_scissor_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.huawei_invocation_mask]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_invocation_mask_huawei = Some(Default::default());
            let member = self.features_invocation_mask_huawei.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_mesh_shader]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_mesh_shader_nv = Some(Default::default());
            let member = self.features_mesh_shader_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.valve_mutable_descriptor_type]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_mutable_descriptor_type_valve = Some(Default::default());
            let member = self
                .features_mutable_descriptor_type_valve
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_ray_tracing_motion_blur]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_ray_tracing_motion_blur_nv = Some(Default::default());
            let member = self.features_ray_tracing_motion_blur_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_representative_fragment_test]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_representative_fragment_test_nv = Some(Default::default());
            let member = self
                .features_representative_fragment_test_nv
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_shader_image_footprint]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_image_footprint_nv = Some(Default::default());
            let member = self.features_shader_image_footprint_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.intel_shader_integer_functions2]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_integer_functions2_intel = Some(Default::default());
            let member = self
                .features_shader_integer_functions2_intel
                .as_mut()
                .unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_shader_sm_builtins]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shader_sm_builtins_nv = Some(Default::default());
            let member = self.features_shader_sm_builtins_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.nv_shading_rate_image]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_shading_rate_image_nv = Some(Default::default());
            let member = self.features_shading_rate_image_nv.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
        if std::array::IntoIter::new([device_extensions.huawei_subpass_shading]).any(|x| x)
            && std::array::IntoIter::new([]).all(|x| x)
        {
            self.features_subpass_shading_huawei = Some(Default::default());
            let member = self.features_subpass_shading_huawei.as_mut().unwrap();
            member.p_next = head.p_next;
            head.p_next = member as *mut _ as _;
        }
    }
    pub(crate) fn head_as_ref(&self) -> &ash::vk::PhysicalDeviceFeatures2KHR {
        &self.features_vulkan10
    }
    pub(crate) fn head_as_mut(&mut self) -> &mut ash::vk::PhysicalDeviceFeatures2KHR {
        &mut self.features_vulkan10
    }
}
