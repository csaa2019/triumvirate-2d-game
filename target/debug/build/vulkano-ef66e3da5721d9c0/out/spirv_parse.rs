// This file is auto-generated by vulkano autogen from SPIR-V grammar version 1.5.4.
// It should not be edited manually. Changes should be made by editing autogen.

#[derive(Clone, Debug, PartialEq)]
#[doc = "A parsed SPIR-V instruction."]
pub enum Instruction {
    Nop,
    Undef {
        result_type_id: Id,
        result_id: Id,
    },
    SourceContinued {
        continued_source: String,
    },
    Source {
        source_language: SourceLanguage,
        version: u32,
        file: Option<Id>,
        source: Option<String>,
    },
    SourceExtension {
        extension: String,
    },
    Name {
        target: Id,
        name: String,
    },
    MemberName {
        ty: Id,
        member: u32,
        name: String,
    },
    String {
        result_id: Id,
        string: String,
    },
    Line {
        file: Id,
        line: u32,
        column: u32,
    },
    Extension {
        name: String,
    },
    ExtInstImport {
        result_id: Id,
        name: String,
    },
    ExtInst {
        result_type_id: Id,
        result_id: Id,
        set: Id,
        instruction: u32,
        operands: Vec<Id>,
    },
    MemoryModel {
        addressing_model: AddressingModel,
        memory_model: MemoryModel,
    },
    EntryPoint {
        execution_model: ExecutionModel,
        entry_point: Id,
        name: String,
        interface: Vec<Id>,
    },
    ExecutionMode {
        entry_point: Id,
        mode: ExecutionMode,
    },
    Capability {
        capability: Capability,
    },
    TypeVoid {
        result_id: Id,
    },
    TypeBool {
        result_id: Id,
    },
    TypeInt {
        result_id: Id,
        width: u32,
        signedness: u32,
    },
    TypeFloat {
        result_id: Id,
        width: u32,
    },
    TypeVector {
        result_id: Id,
        component_type: Id,
        component_count: u32,
    },
    TypeMatrix {
        result_id: Id,
        column_type: Id,
        column_count: u32,
    },
    TypeImage {
        result_id: Id,
        sampled_type: Id,
        dim: Dim,
        depth: u32,
        arrayed: u32,
        ms: u32,
        sampled: u32,
        image_format: ImageFormat,
        access_qualifier: Option<AccessQualifier>,
    },
    TypeSampler {
        result_id: Id,
    },
    TypeSampledImage {
        result_id: Id,
        image_type: Id,
    },
    TypeArray {
        result_id: Id,
        element_type: Id,
        length: Id,
    },
    TypeRuntimeArray {
        result_id: Id,
        element_type: Id,
    },
    TypeStruct {
        result_id: Id,
        member_types: Vec<Id>,
    },
    TypeOpaque {
        result_id: Id,
        name: String,
    },
    TypePointer {
        result_id: Id,
        storage_class: StorageClass,
        ty: Id,
    },
    TypeFunction {
        result_id: Id,
        return_type: Id,
        parameter_types: Vec<Id>,
    },
    TypeEvent {
        result_id: Id,
    },
    TypeDeviceEvent {
        result_id: Id,
    },
    TypeReserveId {
        result_id: Id,
    },
    TypeQueue {
        result_id: Id,
    },
    TypePipe {
        result_id: Id,
        qualifier: AccessQualifier,
    },
    TypeForwardPointer {
        pointer_type: Id,
        storage_class: StorageClass,
    },
    ConstantTrue {
        result_type_id: Id,
        result_id: Id,
    },
    ConstantFalse {
        result_type_id: Id,
        result_id: Id,
    },
    Constant {
        result_type_id: Id,
        result_id: Id,
        value: Vec<u32>,
    },
    ConstantComposite {
        result_type_id: Id,
        result_id: Id,
        constituents: Vec<Id>,
    },
    ConstantSampler {
        result_type_id: Id,
        result_id: Id,
        sampler_addressing_mode: SamplerAddressingMode,
        param: u32,
        sampler_filter_mode: SamplerFilterMode,
    },
    ConstantNull {
        result_type_id: Id,
        result_id: Id,
    },
    SpecConstantTrue {
        result_type_id: Id,
        result_id: Id,
    },
    SpecConstantFalse {
        result_type_id: Id,
        result_id: Id,
    },
    SpecConstant {
        result_type_id: Id,
        result_id: Id,
        value: Vec<u32>,
    },
    SpecConstantComposite {
        result_type_id: Id,
        result_id: Id,
        constituents: Vec<Id>,
    },
    SpecConstantOp {
        result_type_id: Id,
        result_id: Id,
        opcode: SpecConstantInstruction,
    },
    Function {
        result_type_id: Id,
        result_id: Id,
        function_control: FunctionControl,
        function_type: Id,
    },
    FunctionParameter {
        result_type_id: Id,
        result_id: Id,
    },
    FunctionEnd,
    FunctionCall {
        result_type_id: Id,
        result_id: Id,
        function: Id,
        arguments: Vec<Id>,
    },
    Variable {
        result_type_id: Id,
        result_id: Id,
        storage_class: StorageClass,
        initializer: Option<Id>,
    },
    ImageTexelPointer {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        sample: Id,
    },
    Load {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory_access: Option<MemoryAccess>,
    },
    Store {
        pointer: Id,
        object: Id,
        memory_access: Option<MemoryAccess>,
    },
    CopyMemory {
        target: Id,
        source: Id,
        memory_access1: Option<MemoryAccess>,
        memory_access2: Option<MemoryAccess>,
    },
    CopyMemorySized {
        target: Id,
        source: Id,
        size: Id,
        memory_access1: Option<MemoryAccess>,
        memory_access2: Option<MemoryAccess>,
    },
    AccessChain {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        indexes: Vec<Id>,
    },
    InBoundsAccessChain {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        indexes: Vec<Id>,
    },
    PtrAccessChain {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        element: Id,
        indexes: Vec<Id>,
    },
    ArrayLength {
        result_type_id: Id,
        result_id: Id,
        structure: Id,
        array_member: u32,
    },
    GenericPtrMemSemantics {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
    },
    InBoundsPtrAccessChain {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        element: Id,
        indexes: Vec<Id>,
    },
    Decorate {
        target: Id,
        decoration: Decoration,
    },
    MemberDecorate {
        structure_type: Id,
        member: u32,
        decoration: Decoration,
    },
    DecorationGroup {
        result_id: Id,
    },
    GroupDecorate {
        decoration_group: Id,
        targets: Vec<Id>,
    },
    GroupMemberDecorate {
        decoration_group: Id,
        targets: Vec<(Id, u32)>,
    },
    VectorExtractDynamic {
        result_type_id: Id,
        result_id: Id,
        vector: Id,
        index: Id,
    },
    VectorInsertDynamic {
        result_type_id: Id,
        result_id: Id,
        vector: Id,
        component: Id,
        index: Id,
    },
    VectorShuffle {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        components: Vec<u32>,
    },
    CompositeConstruct {
        result_type_id: Id,
        result_id: Id,
        constituents: Vec<Id>,
    },
    CompositeExtract {
        result_type_id: Id,
        result_id: Id,
        composite: Id,
        indexes: Vec<u32>,
    },
    CompositeInsert {
        result_type_id: Id,
        result_id: Id,
        object: Id,
        composite: Id,
        indexes: Vec<u32>,
    },
    CopyObject {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    Transpose {
        result_type_id: Id,
        result_id: Id,
        matrix: Id,
    },
    SampledImage {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        sampler: Id,
    },
    ImageSampleImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSampleExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: ImageOperands,
    },
    ImageSampleDrefImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSampleDrefExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: ImageOperands,
    },
    ImageSampleProjImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSampleProjExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: ImageOperands,
    },
    ImageSampleProjDrefImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSampleProjDrefExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: ImageOperands,
    },
    ImageFetch {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageGather {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        component: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageDrefGather {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageRead {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageWrite {
        image: Id,
        coordinate: Id,
        texel: Id,
        image_operands: Option<ImageOperands>,
    },
    Image {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
    },
    ImageQueryFormat {
        result_type_id: Id,
        result_id: Id,
        image: Id,
    },
    ImageQueryOrder {
        result_type_id: Id,
        result_id: Id,
        image: Id,
    },
    ImageQuerySizeLod {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        level_of_detail: Id,
    },
    ImageQuerySize {
        result_type_id: Id,
        result_id: Id,
        image: Id,
    },
    ImageQueryLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
    },
    ImageQueryLevels {
        result_type_id: Id,
        result_id: Id,
        image: Id,
    },
    ImageQuerySamples {
        result_type_id: Id,
        result_id: Id,
        image: Id,
    },
    ConvertFToU {
        result_type_id: Id,
        result_id: Id,
        float_value: Id,
    },
    ConvertFToS {
        result_type_id: Id,
        result_id: Id,
        float_value: Id,
    },
    ConvertSToF {
        result_type_id: Id,
        result_id: Id,
        signed_value: Id,
    },
    ConvertUToF {
        result_type_id: Id,
        result_id: Id,
        unsigned_value: Id,
    },
    UConvert {
        result_type_id: Id,
        result_id: Id,
        unsigned_value: Id,
    },
    SConvert {
        result_type_id: Id,
        result_id: Id,
        signed_value: Id,
    },
    FConvert {
        result_type_id: Id,
        result_id: Id,
        float_value: Id,
    },
    QuantizeToF16 {
        result_type_id: Id,
        result_id: Id,
        value: Id,
    },
    ConvertPtrToU {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
    },
    SatConvertSToU {
        result_type_id: Id,
        result_id: Id,
        signed_value: Id,
    },
    SatConvertUToS {
        result_type_id: Id,
        result_id: Id,
        unsigned_value: Id,
    },
    ConvertUToPtr {
        result_type_id: Id,
        result_id: Id,
        integer_value: Id,
    },
    PtrCastToGeneric {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
    },
    GenericCastToPtr {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
    },
    GenericCastToPtrExplicit {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        storage: StorageClass,
    },
    Bitcast {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    SNegate {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    FNegate {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    IAdd {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FAdd {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    ISub {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FSub {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    IMul {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FMul {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UDiv {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    SDiv {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FDiv {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UMod {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    SRem {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    SMod {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FRem {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FMod {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    VectorTimesScalar {
        result_type_id: Id,
        result_id: Id,
        vector: Id,
        scalar: Id,
    },
    MatrixTimesScalar {
        result_type_id: Id,
        result_id: Id,
        matrix: Id,
        scalar: Id,
    },
    VectorTimesMatrix {
        result_type_id: Id,
        result_id: Id,
        vector: Id,
        matrix: Id,
    },
    MatrixTimesVector {
        result_type_id: Id,
        result_id: Id,
        matrix: Id,
        vector: Id,
    },
    MatrixTimesMatrix {
        result_type_id: Id,
        result_id: Id,
        left_matrix: Id,
        right_matrix: Id,
    },
    OuterProduct {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
    },
    Dot {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
    },
    IAddCarry {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    ISubBorrow {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UMulExtended {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    SMulExtended {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    Any {
        result_type_id: Id,
        result_id: Id,
        vector: Id,
    },
    All {
        result_type_id: Id,
        result_id: Id,
        vector: Id,
    },
    IsNan {
        result_type_id: Id,
        result_id: Id,
        x: Id,
    },
    IsInf {
        result_type_id: Id,
        result_id: Id,
        x: Id,
    },
    IsFinite {
        result_type_id: Id,
        result_id: Id,
        x: Id,
    },
    IsNormal {
        result_type_id: Id,
        result_id: Id,
        x: Id,
    },
    SignBitSet {
        result_type_id: Id,
        result_id: Id,
        x: Id,
    },
    LessOrGreater {
        result_type_id: Id,
        result_id: Id,
        x: Id,
        y: Id,
    },
    Ordered {
        result_type_id: Id,
        result_id: Id,
        x: Id,
        y: Id,
    },
    Unordered {
        result_type_id: Id,
        result_id: Id,
        x: Id,
        y: Id,
    },
    LogicalEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    LogicalNotEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    LogicalOr {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    LogicalAnd {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    LogicalNot {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    Select {
        result_type_id: Id,
        result_id: Id,
        condition: Id,
        object_1: Id,
        object_2: Id,
    },
    IEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    INotEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UGreaterThan {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    SGreaterThan {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UGreaterThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    SGreaterThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    ULessThan {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    SLessThan {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    ULessThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    SLessThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FOrdEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FUnordEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FOrdNotEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FUnordNotEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FOrdLessThan {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FUnordLessThan {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FOrdGreaterThan {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FUnordGreaterThan {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FOrdLessThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FUnordLessThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FOrdGreaterThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    FUnordGreaterThanEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    ShiftRightLogical {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        shift: Id,
    },
    ShiftRightArithmetic {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        shift: Id,
    },
    ShiftLeftLogical {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        shift: Id,
    },
    BitwiseOr {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    BitwiseXor {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    BitwiseAnd {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    Not {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    BitFieldInsert {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        insert: Id,
        offset: Id,
        count: Id,
    },
    BitFieldSExtract {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        offset: Id,
        count: Id,
    },
    BitFieldUExtract {
        result_type_id: Id,
        result_id: Id,
        base: Id,
        offset: Id,
        count: Id,
    },
    BitReverse {
        result_type_id: Id,
        result_id: Id,
        base: Id,
    },
    BitCount {
        result_type_id: Id,
        result_id: Id,
        base: Id,
    },
    DPdx {
        result_type_id: Id,
        result_id: Id,
        p: Id,
    },
    DPdy {
        result_type_id: Id,
        result_id: Id,
        p: Id,
    },
    Fwidth {
        result_type_id: Id,
        result_id: Id,
        p: Id,
    },
    DPdxFine {
        result_type_id: Id,
        result_id: Id,
        p: Id,
    },
    DPdyFine {
        result_type_id: Id,
        result_id: Id,
        p: Id,
    },
    FwidthFine {
        result_type_id: Id,
        result_id: Id,
        p: Id,
    },
    DPdxCoarse {
        result_type_id: Id,
        result_id: Id,
        p: Id,
    },
    DPdyCoarse {
        result_type_id: Id,
        result_id: Id,
        p: Id,
    },
    FwidthCoarse {
        result_type_id: Id,
        result_id: Id,
        p: Id,
    },
    EmitVertex,
    EndPrimitive,
    EmitStreamVertex {
        stream: Id,
    },
    EndStreamPrimitive {
        stream: Id,
    },
    ControlBarrier {
        execution: Id,
        memory: Id,
        semantics: Id,
    },
    MemoryBarrier {
        memory: Id,
        semantics: Id,
    },
    AtomicLoad {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
    },
    AtomicStore {
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicExchange {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicCompareExchange {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        equal: Id,
        unequal: Id,
        value: Id,
        comparator: Id,
    },
    AtomicCompareExchangeWeak {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        equal: Id,
        unequal: Id,
        value: Id,
        comparator: Id,
    },
    AtomicIIncrement {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
    },
    AtomicIDecrement {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
    },
    AtomicIAdd {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicISub {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicSMin {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicUMin {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicSMax {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicUMax {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicAnd {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicOr {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicXor {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    Phi {
        result_type_id: Id,
        result_id: Id,
        variable_parent: Vec<(Id, Id)>,
    },
    LoopMerge {
        merge_block: Id,
        continue_target: Id,
        loop_control: LoopControl,
    },
    SelectionMerge {
        merge_block: Id,
        selection_control: SelectionControl,
    },
    Label {
        result_id: Id,
    },
    Branch {
        target_label: Id,
    },
    BranchConditional {
        condition: Id,
        true_label: Id,
        false_label: Id,
        branch_weights: Vec<u32>,
    },
    Switch {
        selector: Id,
        default: Id,
        target: Vec<(u32, Id)>,
    },
    Kill,
    Return,
    ReturnValue {
        value: Id,
    },
    Unreachable,
    LifetimeStart {
        pointer: Id,
        size: u32,
    },
    LifetimeStop {
        pointer: Id,
        size: u32,
    },
    GroupAsyncCopy {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        destination: Id,
        source: Id,
        num_elements: Id,
        stride: Id,
        event: Id,
    },
    GroupWaitEvents {
        execution: Id,
        num_events: Id,
        events_list: Id,
    },
    GroupAll {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        predicate: Id,
    },
    GroupAny {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        predicate: Id,
    },
    GroupBroadcast {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        local_id: Id,
    },
    GroupIAdd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFAdd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupUMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupSMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupUMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupSMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    ReadPipe {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        pointer: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    WritePipe {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        pointer: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    ReservedReadPipe {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        reserve_id: Id,
        index: Id,
        pointer: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    ReservedWritePipe {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        reserve_id: Id,
        index: Id,
        pointer: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    ReserveReadPipePackets {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        num_packets: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    ReserveWritePipePackets {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        num_packets: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    CommitReadPipe {
        pipe: Id,
        reserve_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    CommitWritePipe {
        pipe: Id,
        reserve_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    IsValidReserveId {
        result_type_id: Id,
        result_id: Id,
        reserve_id: Id,
    },
    GetNumPipePackets {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GetMaxPipePackets {
        result_type_id: Id,
        result_id: Id,
        pipe: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GroupReserveReadPipePackets {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        pipe: Id,
        num_packets: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GroupReserveWritePipePackets {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        pipe: Id,
        num_packets: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GroupCommitReadPipe {
        execution: Id,
        pipe: Id,
        reserve_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    GroupCommitWritePipe {
        execution: Id,
        pipe: Id,
        reserve_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    EnqueueMarker {
        result_type_id: Id,
        result_id: Id,
        queue: Id,
        num_events: Id,
        wait_events: Id,
        ret_event: Id,
    },
    EnqueueKernel {
        result_type_id: Id,
        result_id: Id,
        queue: Id,
        flags: Id,
        nd_range: Id,
        num_events: Id,
        wait_events: Id,
        ret_event: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
        local_size: Vec<Id>,
    },
    GetKernelNDrangeSubGroupCount {
        result_type_id: Id,
        result_id: Id,
        nd_range: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    GetKernelNDrangeMaxSubGroupSize {
        result_type_id: Id,
        result_id: Id,
        nd_range: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    GetKernelWorkGroupSize {
        result_type_id: Id,
        result_id: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    GetKernelPreferredWorkGroupSizeMultiple {
        result_type_id: Id,
        result_id: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    RetainEvent {
        event: Id,
    },
    ReleaseEvent {
        event: Id,
    },
    CreateUserEvent {
        result_type_id: Id,
        result_id: Id,
    },
    IsValidEvent {
        result_type_id: Id,
        result_id: Id,
        event: Id,
    },
    SetUserEventStatus {
        event: Id,
        status: Id,
    },
    CaptureEventProfilingInfo {
        event: Id,
        profiling_info: Id,
        value: Id,
    },
    GetDefaultQueue {
        result_type_id: Id,
        result_id: Id,
    },
    BuildNDRange {
        result_type_id: Id,
        result_id: Id,
        global_work_size: Id,
        local_work_size: Id,
        global_work_offset: Id,
    },
    ImageSparseSampleImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseSampleExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: ImageOperands,
    },
    ImageSparseSampleDrefImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseSampleDrefExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: ImageOperands,
    },
    ImageSparseSampleProjImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseSampleProjExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        image_operands: ImageOperands,
    },
    ImageSparseSampleProjDrefImplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseSampleProjDrefExplicitLod {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: ImageOperands,
    },
    ImageSparseFetch {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseGather {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        component: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseDrefGather {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        dref: Id,
        image_operands: Option<ImageOperands>,
    },
    ImageSparseTexelsResident {
        result_type_id: Id,
        result_id: Id,
        resident_code: Id,
    },
    NoLine,
    AtomicFlagTestAndSet {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
    },
    AtomicFlagClear {
        pointer: Id,
        memory: Id,
        semantics: Id,
    },
    ImageSparseRead {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        image_operands: Option<ImageOperands>,
    },
    SizeOf {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
    },
    TypePipeStorage {
        result_id: Id,
    },
    ConstantPipeStorage {
        result_type_id: Id,
        result_id: Id,
        packet_size: u32,
        packet_alignment: u32,
        capacity: u32,
    },
    CreatePipeFromPipeStorage {
        result_type_id: Id,
        result_id: Id,
        pipe_storage: Id,
    },
    GetKernelLocalSizeForSubgroupCount {
        result_type_id: Id,
        result_id: Id,
        subgroup_count: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    GetKernelMaxNumSubgroups {
        result_type_id: Id,
        result_id: Id,
        invoke: Id,
        param: Id,
        param_size: Id,
        param_align: Id,
    },
    TypeNamedBarrier {
        result_id: Id,
    },
    NamedBarrierInitialize {
        result_type_id: Id,
        result_id: Id,
        subgroup_count: Id,
    },
    MemoryNamedBarrier {
        named_barrier: Id,
        memory: Id,
        semantics: Id,
    },
    ModuleProcessed {
        process: String,
    },
    ExecutionModeId {
        entry_point: Id,
        mode: ExecutionMode,
    },
    DecorateId {
        target: Id,
        decoration: Decoration,
    },
    GroupNonUniformElect {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
    },
    GroupNonUniformAll {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        predicate: Id,
    },
    GroupNonUniformAny {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        predicate: Id,
    },
    GroupNonUniformAllEqual {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformBroadcast {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        id: Id,
    },
    GroupNonUniformBroadcastFirst {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformBallot {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        predicate: Id,
    },
    GroupNonUniformInverseBallot {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformBallotBitExtract {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        index: Id,
    },
    GroupNonUniformBallotBitCount {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
    },
    GroupNonUniformBallotFindLSB {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformBallotFindMSB {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
    },
    GroupNonUniformShuffle {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        id: Id,
    },
    GroupNonUniformShuffleXor {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        mask: Id,
    },
    GroupNonUniformShuffleUp {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        delta: Id,
    },
    GroupNonUniformShuffleDown {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        delta: Id,
    },
    GroupNonUniformIAdd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformFAdd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformIMul {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformFMul {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformSMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformUMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformFMin {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformSMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformUMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformFMax {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformBitwiseAnd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformBitwiseOr {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformBitwiseXor {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformLogicalAnd {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformLogicalOr {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformLogicalXor {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        value: Id,
        cluster_size: Option<Id>,
    },
    GroupNonUniformQuadBroadcast {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        index: Id,
    },
    GroupNonUniformQuadSwap {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        value: Id,
        direction: Id,
    },
    CopyLogical {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    PtrEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    PtrNotEqual {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    PtrDiff {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    TerminateInvocation,
    SubgroupBallotKHR {
        result_type_id: Id,
        result_id: Id,
        predicate: Id,
    },
    SubgroupFirstInvocationKHR {
        result_type_id: Id,
        result_id: Id,
        value: Id,
    },
    SubgroupAllKHR {
        result_type_id: Id,
        result_id: Id,
        predicate: Id,
    },
    SubgroupAnyKHR {
        result_type_id: Id,
        result_id: Id,
        predicate: Id,
    },
    SubgroupAllEqualKHR {
        result_type_id: Id,
        result_id: Id,
        predicate: Id,
    },
    SubgroupReadInvocationKHR {
        result_type_id: Id,
        result_id: Id,
        value: Id,
        index: Id,
    },
    TraceRayKHR {
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        sbt_offset: Id,
        sbt_stride: Id,
        miss_index: Id,
        ray_origin: Id,
        ray_tmin: Id,
        ray_direction: Id,
        ray_tmax: Id,
        payload: Id,
    },
    ExecuteCallableKHR {
        sbt_index: Id,
        callable_data: Id,
    },
    ConvertUToAccelerationStructureKHR {
        result_type_id: Id,
        result_id: Id,
        accel: Id,
    },
    IgnoreIntersectionKHR,
    TerminateRayKHR,
    SDotKHR {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    UDotKHR {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    SUDotKHR {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    SDotAccSatKHR {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        accumulator: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    UDotAccSatKHR {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        accumulator: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    SUDotAccSatKHR {
        result_type_id: Id,
        result_id: Id,
        vector_1: Id,
        vector_2: Id,
        accumulator: Id,
        packed_vector_format: Option<PackedVectorFormat>,
    },
    TypeRayQueryKHR {
        result_id: Id,
    },
    RayQueryInitializeKHR {
        ray_query: Id,
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        ray_origin: Id,
        ray_t_min: Id,
        ray_direction: Id,
        ray_t_max: Id,
    },
    RayQueryTerminateKHR {
        ray_query: Id,
    },
    RayQueryGenerateIntersectionKHR {
        ray_query: Id,
        hit_t: Id,
    },
    RayQueryConfirmIntersectionKHR {
        ray_query: Id,
    },
    RayQueryProceedKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
    },
    RayQueryGetIntersectionTypeKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    GroupIAddNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFAddNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFMinNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupUMinNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupSMinNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupFMaxNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupUMaxNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    GroupSMaxNonUniformAMD {
        result_type_id: Id,
        result_id: Id,
        execution: Id,
        operation: GroupOperation,
        x: Id,
    },
    FragmentMaskFetchAMD {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
    },
    FragmentFetchAMD {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        fragment_index: Id,
    },
    ReadClockKHR {
        result_type_id: Id,
        result_id: Id,
        scope: Id,
    },
    ImageSampleFootprintNV {
        result_type_id: Id,
        result_id: Id,
        sampled_image: Id,
        coordinate: Id,
        granularity: Id,
        coarse: Id,
        image_operands: Option<ImageOperands>,
    },
    GroupNonUniformPartitionNV {
        result_type_id: Id,
        result_id: Id,
        value: Id,
    },
    WritePackedPrimitiveIndices4x8NV {
        index_offset: Id,
        packed_indices: Id,
    },
    ReportIntersectionKHR {
        result_type_id: Id,
        result_id: Id,
        hit: Id,
        hit_kind: Id,
    },
    IgnoreIntersectionNV,
    TerminateRayNV,
    TraceNV {
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        sbt_offset: Id,
        sbt_stride: Id,
        miss_index: Id,
        ray_origin: Id,
        ray_tmin: Id,
        ray_direction: Id,
        ray_tmax: Id,
        payload_id: Id,
    },
    TraceMotionNV {
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        sbt_offset: Id,
        sbt_stride: Id,
        miss_index: Id,
        ray_origin: Id,
        ray_tmin: Id,
        ray_direction: Id,
        ray_tmax: Id,
        time: Id,
        payload_id: Id,
    },
    TraceRayMotionNV {
        accel: Id,
        ray_flags: Id,
        cull_mask: Id,
        sbt_offset: Id,
        sbt_stride: Id,
        miss_index: Id,
        ray_origin: Id,
        ray_tmin: Id,
        ray_direction: Id,
        ray_tmax: Id,
        time: Id,
        payload: Id,
    },
    TypeAccelerationStructureKHR {
        result_id: Id,
    },
    ExecuteCallableNV {
        sbt_index: Id,
        callable_data_id: Id,
    },
    TypeCooperativeMatrixNV {
        result_id: Id,
        component_type: Id,
        execution: Id,
        rows: Id,
        columns: Id,
    },
    CooperativeMatrixLoadNV {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        stride: Id,
        column_major: Id,
        memory_access: Option<MemoryAccess>,
    },
    CooperativeMatrixStoreNV {
        pointer: Id,
        object: Id,
        stride: Id,
        column_major: Id,
        memory_access: Option<MemoryAccess>,
    },
    CooperativeMatrixMulAddNV {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        b: Id,
        c: Id,
    },
    CooperativeMatrixLengthNV {
        result_type_id: Id,
        result_id: Id,
        ty: Id,
    },
    BeginInvocationInterlockEXT,
    EndInvocationInterlockEXT,
    DemoteToHelperInvocationEXT,
    IsHelperInvocationEXT {
        result_type_id: Id,
        result_id: Id,
    },
    ConvertUToImageNV {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    ConvertUToSamplerNV {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    ConvertImageToUNV {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    ConvertSamplerToUNV {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    ConvertUToSampledImageNV {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    ConvertSampledImageToUNV {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    SamplerImageAddressingModeNV {
        bit_width: u32,
    },
    SubgroupShuffleINTEL {
        result_type_id: Id,
        result_id: Id,
        data: Id,
        invocation_id: Id,
    },
    SubgroupShuffleDownINTEL {
        result_type_id: Id,
        result_id: Id,
        current: Id,
        next: Id,
        delta: Id,
    },
    SubgroupShuffleUpINTEL {
        result_type_id: Id,
        result_id: Id,
        previous: Id,
        current: Id,
        delta: Id,
    },
    SubgroupShuffleXorINTEL {
        result_type_id: Id,
        result_id: Id,
        data: Id,
        value: Id,
    },
    SubgroupBlockReadINTEL {
        result_type_id: Id,
        result_id: Id,
        ptr: Id,
    },
    SubgroupBlockWriteINTEL {
        ptr: Id,
        data: Id,
    },
    SubgroupImageBlockReadINTEL {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
    },
    SubgroupImageBlockWriteINTEL {
        image: Id,
        coordinate: Id,
        data: Id,
    },
    SubgroupImageMediaBlockReadINTEL {
        result_type_id: Id,
        result_id: Id,
        image: Id,
        coordinate: Id,
        width: Id,
        height: Id,
    },
    SubgroupImageMediaBlockWriteINTEL {
        image: Id,
        coordinate: Id,
        width: Id,
        height: Id,
        data: Id,
    },
    UCountLeadingZerosINTEL {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    UCountTrailingZerosINTEL {
        result_type_id: Id,
        result_id: Id,
        operand: Id,
    },
    AbsISubINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    AbsUSubINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    IAddSatINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UAddSatINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    IAverageINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UAverageINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    IAverageRoundedINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UAverageRoundedINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    ISubSatINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    USubSatINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    IMul32x16INTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    UMul32x16INTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Id,
        operand2: Id,
    },
    ConstFunctionPointerINTEL {
        result_type_id: Id,
        result_id: Id,
        function: Id,
    },
    FunctionPointerCallINTEL {
        result_type_id: Id,
        result_id: Id,
        operand1: Vec<Id>,
    },
    AsmTargetINTEL {
        result_type_id: Id,
        result_id: Id,
        asm_target: String,
    },
    AsmINTEL {
        result_type_id: Id,
        result_id: Id,
        asm_type: Id,
        target: Id,
        asm_instructions: String,
        constraints: String,
    },
    AsmCallINTEL {
        result_type_id: Id,
        result_id: Id,
        asm: Id,
        argument_0: Vec<Id>,
    },
    AtomicFMinEXT {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AtomicFMaxEXT {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    AssumeTrueKHR {
        condition: Id,
    },
    ExpectKHR {
        result_type_id: Id,
        result_id: Id,
        value: Id,
        expected_value: Id,
    },
    DecorateString {
        target: Id,
        decoration: Decoration,
    },
    MemberDecorateString {
        struct_type: Id,
        member: u32,
        decoration: Decoration,
    },
    VmeImageINTEL {
        result_type_id: Id,
        result_id: Id,
        image_type: Id,
        sampler: Id,
    },
    TypeVmeImageINTEL {
        result_id: Id,
        image_type: Id,
    },
    TypeAvcImePayloadINTEL {
        result_id: Id,
    },
    TypeAvcRefPayloadINTEL {
        result_id: Id,
    },
    TypeAvcSicPayloadINTEL {
        result_id: Id,
    },
    TypeAvcMcePayloadINTEL {
        result_id: Id,
    },
    TypeAvcMceResultINTEL {
        result_id: Id,
    },
    TypeAvcImeResultINTEL {
        result_id: Id,
    },
    TypeAvcImeResultSingleReferenceStreamoutINTEL {
        result_id: Id,
    },
    TypeAvcImeResultDualReferenceStreamoutINTEL {
        result_id: Id,
    },
    TypeAvcImeSingleReferenceStreaminINTEL {
        result_id: Id,
    },
    TypeAvcImeDualReferenceStreaminINTEL {
        result_id: Id,
    },
    TypeAvcRefResultINTEL {
        result_id: Id,
    },
    TypeAvcSicResultINTEL {
        result_id: Id,
    },
    SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        reference_base_penalty: Id,
        payload: Id,
    },
    SubgroupAvcMceGetDefaultInterShapePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceSetInterShapePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_shape_penalty: Id,
        payload: Id,
    },
    SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceSetInterDirectionPenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        direction_cost: Id,
        payload: Id,
    },
    SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceSetMotionVectorCostFunctionINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_cost_center_delta: Id,
        packed_cost_table: Id,
        cost_precision: Id,
        payload: Id,
    },
    SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        slice_type: Id,
        qp: Id,
    },
    SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    SubgroupAvcMceSetAcOnlyHaarINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL {
        result_type_id: Id,
        result_id: Id,
        source_field_polarity: Id,
        payload: Id,
    },
    SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL {
        result_type_id: Id,
        result_id: Id,
        reference_field_polarity: Id,
        payload: Id,
    },
    SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL {
        result_type_id: Id,
        result_id: Id,
        forward_reference_field_polarity: Id,
        backward_reference_field_polarity: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToImePayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToImeResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToRefPayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToRefResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToSicPayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceConvertToSicResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetMotionVectorsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterDistortionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetBestInterDistortionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterMajorShapeINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterMinorShapeINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterDirectionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterMotionVectorCountINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterReferenceIdsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_reference_ids: Id,
        packed_reference_parameter_field_polarities: Id,
        payload: Id,
    },
    SubgroupAvcImeInitializeINTEL {
        result_type_id: Id,
        result_id: Id,
        src_coord: Id,
        partition_mask: Id,
        sad_adjustment: Id,
    },
    SubgroupAvcImeSetSingleReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        ref_offset: Id,
        search_window_config: Id,
        payload: Id,
    },
    SubgroupAvcImeSetDualReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        fwd_ref_offset: Id,
        bwd_ref_offset: Id,
        id_search_window_config: Id,
        payload: Id,
    },
    SubgroupAvcImeRefWindowSizeINTEL {
        result_type_id: Id,
        result_id: Id,
        search_window_config: Id,
        dual_ref: Id,
    },
    SubgroupAvcImeAdjustRefOffsetINTEL {
        result_type_id: Id,
        result_id: Id,
        ref_offset: Id,
        src_coord: Id,
        ref_window_size: Id,
        image_size: Id,
    },
    SubgroupAvcImeConvertToMcePayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeSetMaxMotionVectorCountINTEL {
        result_type_id: Id,
        result_id: Id,
        max_motion_vector_count: Id,
        payload: Id,
    },
    SubgroupAvcImeSetUnidirectionalMixDisableINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL {
        result_type_id: Id,
        result_id: Id,
        threshold: Id,
        payload: Id,
    },
    SubgroupAvcImeSetWeightedSadINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_sad_weights: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithSingleReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithDualReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
        streamin_components: Id,
    },
    SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
        streamin_components: Id,
    },
    SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
    },
    SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
        streamin_components: Id,
    },
    SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
        streamin_components: Id,
    },
    SubgroupAvcImeConvertToMceResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetSingleReferenceStreaminINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetDualReferenceStreaminINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeStripSingleReferenceStreamoutINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeStripDualReferenceStreamoutINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
    },
    SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
    },
    SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
    },
    SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
        direction: Id,
    },
    SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
        direction: Id,
    },
    SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
        major_shape: Id,
        direction: Id,
    },
    SubgroupAvcImeGetBorderReachedINTEL {
        result_type_id: Id,
        result_id: Id,
        image_select: Id,
        payload: Id,
    },
    SubgroupAvcImeGetTruncatedSearchIndicationINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcFmeInitializeINTEL {
        result_type_id: Id,
        result_id: Id,
        src_coord: Id,
        motion_vectors: Id,
        major_shapes: Id,
        minor_shapes: Id,
        direction: Id,
        pixel_resolution: Id,
        sad_adjustment: Id,
    },
    SubgroupAvcBmeInitializeINTEL {
        result_type_id: Id,
        result_id: Id,
        src_coord: Id,
        motion_vectors: Id,
        major_shapes: Id,
        minor_shapes: Id,
        direction: Id,
        pixel_resolution: Id,
        bidirectional_weight: Id,
        sad_adjustment: Id,
    },
    SubgroupAvcRefConvertToMcePayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcRefSetBidirectionalMixDisableINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcRefSetBilinearFilterEnableINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcRefEvaluateWithSingleReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
    },
    SubgroupAvcRefEvaluateWithDualReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
    },
    SubgroupAvcRefEvaluateWithMultiReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        packed_reference_ids: Id,
        payload: Id,
    },
    SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        packed_reference_ids: Id,
        packed_reference_field_polarities: Id,
        payload: Id,
    },
    SubgroupAvcRefConvertToMceResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicInitializeINTEL {
        result_type_id: Id,
        result_id: Id,
        src_coord: Id,
    },
    SubgroupAvcSicConfigureSkcINTEL {
        result_type_id: Id,
        result_id: Id,
        skip_block_partition_type: Id,
        skip_motion_vector_mask: Id,
        motion_vectors: Id,
        bidirectional_weight: Id,
        sad_adjustment: Id,
        payload: Id,
    },
    SubgroupAvcSicConfigureIpeLumaINTEL {
        result_type_id: Id,
        result_id: Id,
        luma_intra_partition_mask: Id,
        intra_neighbour_availabilty: Id,
        left_edge_luma_pixels: Id,
        upper_left_corner_luma_pixel: Id,
        upper_edge_luma_pixels: Id,
        upper_right_edge_luma_pixels: Id,
        sad_adjustment: Id,
        payload: Id,
    },
    SubgroupAvcSicConfigureIpeLumaChromaINTEL {
        result_type_id: Id,
        result_id: Id,
        luma_intra_partition_mask: Id,
        intra_neighbour_availabilty: Id,
        left_edge_luma_pixels: Id,
        upper_left_corner_luma_pixel: Id,
        upper_edge_luma_pixels: Id,
        upper_right_edge_luma_pixels: Id,
        left_edge_chroma_pixels: Id,
        upper_left_corner_chroma_pixel: Id,
        upper_edge_chroma_pixels: Id,
        sad_adjustment: Id,
        payload: Id,
    },
    SubgroupAvcSicGetMotionVectorMaskINTEL {
        result_type_id: Id,
        result_id: Id,
        skip_block_partition_type: Id,
        direction: Id,
    },
    SubgroupAvcSicConvertToMcePayloadINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicSetIntraLumaShapePenaltyINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_shape_penalty: Id,
        payload: Id,
    },
    SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL {
        result_type_id: Id,
        result_id: Id,
        luma_mode_penalty: Id,
        luma_packed_neighbor_modes: Id,
        luma_packed_non_dc_penalty: Id,
        payload: Id,
    },
    SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL {
        result_type_id: Id,
        result_id: Id,
        chroma_mode_base_penalty: Id,
        payload: Id,
    },
    SubgroupAvcSicSetBilinearFilterEnableINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicSetSkcForwardTransformEnableINTEL {
        result_type_id: Id,
        result_id: Id,
        packed_sad_coefficients: Id,
        payload: Id,
    },
    SubgroupAvcSicSetBlockBasedRawSkipSadINTEL {
        result_type_id: Id,
        result_id: Id,
        block_based_skip_type: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateIpeINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateWithSingleReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        ref_image: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateWithDualReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        fwd_ref_image: Id,
        bwd_ref_image: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateWithMultiReferenceINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        packed_reference_ids: Id,
        payload: Id,
    },
    SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL {
        result_type_id: Id,
        result_id: Id,
        src_image: Id,
        packed_reference_ids: Id,
        packed_reference_field_polarities: Id,
        payload: Id,
    },
    SubgroupAvcSicConvertToMceResultINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetIpeLumaShapeINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetBestIpeLumaDistortionINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetBestIpeChromaDistortionINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetPackedIpeLumaModesINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetIpeChromaModeINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    SubgroupAvcSicGetInterRawSadsINTEL {
        result_type_id: Id,
        result_id: Id,
        payload: Id,
    },
    VariableLengthArrayINTEL {
        result_type_id: Id,
        result_id: Id,
        lenght: Id,
    },
    SaveMemoryINTEL {
        result_type_id: Id,
        result_id: Id,
    },
    RestoreMemoryINTEL {
        ptr: Id,
    },
    ArbitraryFloatSinCosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        from_sign: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCastINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCastFromIntINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        mout: u32,
        from_sign: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCastToIntINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatAddINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSubINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatMulINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatDivINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatGTINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatGEINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatLTINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatLEINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatEQINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
    },
    ArbitraryFloatRecipINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatRSqrtINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCbrtINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatHypotINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSqrtINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatLogINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatLog2INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatLog10INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatLog1pINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatExpINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatExp2INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatExp10INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatExpm1INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSinINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCosINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSinCosINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatSinPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatCosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatASinINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatASinPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatACosINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatACosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatATanINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatATanPiINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatATan2INTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatPowINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatPowRINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        m2: u32,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    ArbitraryFloatPowNINTEL {
        result_type_id: Id,
        result_id: Id,
        a: Id,
        m1: u32,
        b: Id,
        mout: u32,
        enable_subnormals: u32,
        rounding_mode: u32,
        rounding_accuracy: u32,
    },
    LoopControlINTEL {
        loop_control_parameters: Vec<u32>,
    },
    FixedSqrtINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedRecipINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedRsqrtINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedSinINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedCosINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedSinCosINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedSinPiINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedCosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedSinCosPiINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedLogINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    FixedExpINTEL {
        result_type_id: Id,
        result_id: Id,
        input_type: Id,
        input: Id,
        s: u32,
        i: u32,
        r_i: u32,
        q: u32,
        o: u32,
    },
    PtrCastToCrossWorkgroupINTEL {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
    },
    CrossWorkgroupCastToPtrINTEL {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
    },
    ReadPipeBlockingINTEL {
        result_type_id: Id,
        result_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    WritePipeBlockingINTEL {
        result_type_id: Id,
        result_id: Id,
        packet_size: Id,
        packet_alignment: Id,
    },
    FPGARegINTEL {
        result_type_id: Id,
        result_id: Id,
        result: Id,
        input: Id,
    },
    RayQueryGetRayTMinKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
    },
    RayQueryGetRayFlagsKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
    },
    RayQueryGetIntersectionTKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionInstanceCustomIndexKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionInstanceIdKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionGeometryIndexKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionPrimitiveIndexKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionBarycentricsKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionFrontFaceKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionCandidateAABBOpaqueKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
    },
    RayQueryGetIntersectionObjectRayDirectionKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionObjectRayOriginKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetWorldRayDirectionKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
    },
    RayQueryGetWorldRayOriginKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
    },
    RayQueryGetIntersectionObjectToWorldKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    RayQueryGetIntersectionWorldToObjectKHR {
        result_type_id: Id,
        result_id: Id,
        ray_query: Id,
        intersection: Id,
    },
    AtomicFAddEXT {
        result_type_id: Id,
        result_id: Id,
        pointer: Id,
        memory: Id,
        semantics: Id,
        value: Id,
    },
    TypeBufferSurfaceINTEL {
        result_id: Id,
        access_qualifier: AccessQualifier,
    },
    TypeStructContinuedINTEL {
        member_types: Vec<Id>,
    },
    ConstantCompositeContinuedINTEL {
        constituents: Vec<Id>,
    },
    SpecConstantCompositeContinuedINTEL {
        constituents: Vec<Id>,
    },
}
impl Instruction {
    fn parse(reader: &mut InstructionReader) -> Result<Self, ParseError> {
        let opcode = (reader.next_u32()? & 0xffff) as u16;
        Ok(match opcode {
            0u16 => Self::Nop,
            1u16 => Self::Undef {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            2u16 => Self::SourceContinued {
                continued_source: reader.next_string()?,
            },
            3u16 => Self::Source {
                source_language: SourceLanguage::parse(reader)?,
                version: reader.next_u32()?,
                file: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
                source: if !reader.is_empty() {
                    Some(reader.next_string()?)
                } else {
                    None
                },
            },
            4u16 => Self::SourceExtension {
                extension: reader.next_string()?,
            },
            5u16 => Self::Name {
                target: Id(reader.next_u32()?),
                name: reader.next_string()?,
            },
            6u16 => Self::MemberName {
                ty: Id(reader.next_u32()?),
                member: reader.next_u32()?,
                name: reader.next_string()?,
            },
            7u16 => Self::String {
                result_id: Id(reader.next_u32()?),
                string: reader.next_string()?,
            },
            8u16 => Self::Line {
                file: Id(reader.next_u32()?),
                line: reader.next_u32()?,
                column: reader.next_u32()?,
            },
            10u16 => Self::Extension {
                name: reader.next_string()?,
            },
            11u16 => Self::ExtInstImport {
                result_id: Id(reader.next_u32()?),
                name: reader.next_string()?,
            },
            12u16 => Self::ExtInst {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                set: Id(reader.next_u32()?),
                instruction: reader.next_u32()?,
                operands: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            14u16 => Self::MemoryModel {
                addressing_model: AddressingModel::parse(reader)?,
                memory_model: MemoryModel::parse(reader)?,
            },
            15u16 => Self::EntryPoint {
                execution_model: ExecutionModel::parse(reader)?,
                entry_point: Id(reader.next_u32()?),
                name: reader.next_string()?,
                interface: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            16u16 => Self::ExecutionMode {
                entry_point: Id(reader.next_u32()?),
                mode: ExecutionMode::parse(reader)?,
            },
            17u16 => Self::Capability {
                capability: Capability::parse(reader)?,
            },
            19u16 => Self::TypeVoid {
                result_id: Id(reader.next_u32()?),
            },
            20u16 => Self::TypeBool {
                result_id: Id(reader.next_u32()?),
            },
            21u16 => Self::TypeInt {
                result_id: Id(reader.next_u32()?),
                width: reader.next_u32()?,
                signedness: reader.next_u32()?,
            },
            22u16 => Self::TypeFloat {
                result_id: Id(reader.next_u32()?),
                width: reader.next_u32()?,
            },
            23u16 => Self::TypeVector {
                result_id: Id(reader.next_u32()?),
                component_type: Id(reader.next_u32()?),
                component_count: reader.next_u32()?,
            },
            24u16 => Self::TypeMatrix {
                result_id: Id(reader.next_u32()?),
                column_type: Id(reader.next_u32()?),
                column_count: reader.next_u32()?,
            },
            25u16 => Self::TypeImage {
                result_id: Id(reader.next_u32()?),
                sampled_type: Id(reader.next_u32()?),
                dim: Dim::parse(reader)?,
                depth: reader.next_u32()?,
                arrayed: reader.next_u32()?,
                ms: reader.next_u32()?,
                sampled: reader.next_u32()?,
                image_format: ImageFormat::parse(reader)?,
                access_qualifier: if !reader.is_empty() {
                    Some(AccessQualifier::parse(reader)?)
                } else {
                    None
                },
            },
            26u16 => Self::TypeSampler {
                result_id: Id(reader.next_u32()?),
            },
            27u16 => Self::TypeSampledImage {
                result_id: Id(reader.next_u32()?),
                image_type: Id(reader.next_u32()?),
            },
            28u16 => Self::TypeArray {
                result_id: Id(reader.next_u32()?),
                element_type: Id(reader.next_u32()?),
                length: Id(reader.next_u32()?),
            },
            29u16 => Self::TypeRuntimeArray {
                result_id: Id(reader.next_u32()?),
                element_type: Id(reader.next_u32()?),
            },
            30u16 => Self::TypeStruct {
                result_id: Id(reader.next_u32()?),
                member_types: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            31u16 => Self::TypeOpaque {
                result_id: Id(reader.next_u32()?),
                name: reader.next_string()?,
            },
            32u16 => Self::TypePointer {
                result_id: Id(reader.next_u32()?),
                storage_class: StorageClass::parse(reader)?,
                ty: Id(reader.next_u32()?),
            },
            33u16 => Self::TypeFunction {
                result_id: Id(reader.next_u32()?),
                return_type: Id(reader.next_u32()?),
                parameter_types: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            34u16 => Self::TypeEvent {
                result_id: Id(reader.next_u32()?),
            },
            35u16 => Self::TypeDeviceEvent {
                result_id: Id(reader.next_u32()?),
            },
            36u16 => Self::TypeReserveId {
                result_id: Id(reader.next_u32()?),
            },
            37u16 => Self::TypeQueue {
                result_id: Id(reader.next_u32()?),
            },
            38u16 => Self::TypePipe {
                result_id: Id(reader.next_u32()?),
                qualifier: AccessQualifier::parse(reader)?,
            },
            39u16 => Self::TypeForwardPointer {
                pointer_type: Id(reader.next_u32()?),
                storage_class: StorageClass::parse(reader)?,
            },
            41u16 => Self::ConstantTrue {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            42u16 => Self::ConstantFalse {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            43u16 => Self::Constant {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                value: reader.remainder(),
            },
            44u16 => Self::ConstantComposite {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                constituents: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            45u16 => Self::ConstantSampler {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampler_addressing_mode: SamplerAddressingMode::parse(reader)?,
                param: reader.next_u32()?,
                sampler_filter_mode: SamplerFilterMode::parse(reader)?,
            },
            46u16 => Self::ConstantNull {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            48u16 => Self::SpecConstantTrue {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            49u16 => Self::SpecConstantFalse {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            50u16 => Self::SpecConstant {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                value: reader.remainder(),
            },
            51u16 => Self::SpecConstantComposite {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                constituents: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            52u16 => Self::SpecConstantOp {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                opcode: SpecConstantInstruction::parse(reader)?,
            },
            54u16 => Self::Function {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                function_control: FunctionControl::parse(reader)?,
                function_type: Id(reader.next_u32()?),
            },
            55u16 => Self::FunctionParameter {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            56u16 => Self::FunctionEnd,
            57u16 => Self::FunctionCall {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                function: Id(reader.next_u32()?),
                arguments: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            59u16 => Self::Variable {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                storage_class: StorageClass::parse(reader)?,
                initializer: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            60u16 => Self::ImageTexelPointer {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                sample: Id(reader.next_u32()?),
            },
            61u16 => Self::Load {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory_access: if !reader.is_empty() {
                    Some(MemoryAccess::parse(reader)?)
                } else {
                    None
                },
            },
            62u16 => Self::Store {
                pointer: Id(reader.next_u32()?),
                object: Id(reader.next_u32()?),
                memory_access: if !reader.is_empty() {
                    Some(MemoryAccess::parse(reader)?)
                } else {
                    None
                },
            },
            63u16 => Self::CopyMemory {
                target: Id(reader.next_u32()?),
                source: Id(reader.next_u32()?),
                memory_access1: if !reader.is_empty() {
                    Some(MemoryAccess::parse(reader)?)
                } else {
                    None
                },
                memory_access2: if !reader.is_empty() {
                    Some(MemoryAccess::parse(reader)?)
                } else {
                    None
                },
            },
            64u16 => Self::CopyMemorySized {
                target: Id(reader.next_u32()?),
                source: Id(reader.next_u32()?),
                size: Id(reader.next_u32()?),
                memory_access1: if !reader.is_empty() {
                    Some(MemoryAccess::parse(reader)?)
                } else {
                    None
                },
                memory_access2: if !reader.is_empty() {
                    Some(MemoryAccess::parse(reader)?)
                } else {
                    None
                },
            },
            65u16 => Self::AccessChain {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            66u16 => Self::InBoundsAccessChain {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            67u16 => Self::PtrAccessChain {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                element: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            68u16 => Self::ArrayLength {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                structure: Id(reader.next_u32()?),
                array_member: reader.next_u32()?,
            },
            69u16 => Self::GenericPtrMemSemantics {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
            },
            70u16 => Self::InBoundsPtrAccessChain {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                element: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            71u16 => Self::Decorate {
                target: Id(reader.next_u32()?),
                decoration: Decoration::parse(reader)?,
            },
            72u16 => Self::MemberDecorate {
                structure_type: Id(reader.next_u32()?),
                member: reader.next_u32()?,
                decoration: Decoration::parse(reader)?,
            },
            73u16 => Self::DecorationGroup {
                result_id: Id(reader.next_u32()?),
            },
            74u16 => Self::GroupDecorate {
                decoration_group: Id(reader.next_u32()?),
                targets: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            75u16 => Self::GroupMemberDecorate {
                decoration_group: Id(reader.next_u32()?),
                targets: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push((Id(reader.next_u32()?), reader.next_u32()?));
                    }
                    vec
                },
            },
            77u16 => Self::VectorExtractDynamic {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector: Id(reader.next_u32()?),
                index: Id(reader.next_u32()?),
            },
            78u16 => Self::VectorInsertDynamic {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector: Id(reader.next_u32()?),
                component: Id(reader.next_u32()?),
                index: Id(reader.next_u32()?),
            },
            79u16 => Self::VectorShuffle {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
                components: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(reader.next_u32()?);
                    }
                    vec
                },
            },
            80u16 => Self::CompositeConstruct {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                constituents: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            81u16 => Self::CompositeExtract {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                composite: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(reader.next_u32()?);
                    }
                    vec
                },
            },
            82u16 => Self::CompositeInsert {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                object: Id(reader.next_u32()?),
                composite: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(reader.next_u32()?);
                    }
                    vec
                },
            },
            83u16 => Self::CopyObject {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            84u16 => Self::Transpose {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                matrix: Id(reader.next_u32()?),
            },
            86u16 => Self::SampledImage {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                sampler: Id(reader.next_u32()?),
            },
            87u16 => Self::ImageSampleImplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            88u16 => Self::ImageSampleExplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: ImageOperands::parse(reader)?,
            },
            89u16 => Self::ImageSampleDrefImplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            90u16 => Self::ImageSampleDrefExplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: ImageOperands::parse(reader)?,
            },
            91u16 => Self::ImageSampleProjImplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            92u16 => Self::ImageSampleProjExplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: ImageOperands::parse(reader)?,
            },
            93u16 => Self::ImageSampleProjDrefImplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            94u16 => Self::ImageSampleProjDrefExplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: ImageOperands::parse(reader)?,
            },
            95u16 => Self::ImageFetch {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            96u16 => Self::ImageGather {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                component: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            97u16 => Self::ImageDrefGather {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            98u16 => Self::ImageRead {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            99u16 => Self::ImageWrite {
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                texel: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            100u16 => Self::Image {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
            },
            101u16 => Self::ImageQueryFormat {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
            },
            102u16 => Self::ImageQueryOrder {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
            },
            103u16 => Self::ImageQuerySizeLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                level_of_detail: Id(reader.next_u32()?),
            },
            104u16 => Self::ImageQuerySize {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
            },
            105u16 => Self::ImageQueryLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
            },
            106u16 => Self::ImageQueryLevels {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
            },
            107u16 => Self::ImageQuerySamples {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
            },
            109u16 => Self::ConvertFToU {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                float_value: Id(reader.next_u32()?),
            },
            110u16 => Self::ConvertFToS {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                float_value: Id(reader.next_u32()?),
            },
            111u16 => Self::ConvertSToF {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                signed_value: Id(reader.next_u32()?),
            },
            112u16 => Self::ConvertUToF {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                unsigned_value: Id(reader.next_u32()?),
            },
            113u16 => Self::UConvert {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                unsigned_value: Id(reader.next_u32()?),
            },
            114u16 => Self::SConvert {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                signed_value: Id(reader.next_u32()?),
            },
            115u16 => Self::FConvert {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                float_value: Id(reader.next_u32()?),
            },
            116u16 => Self::QuantizeToF16 {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            117u16 => Self::ConvertPtrToU {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
            },
            118u16 => Self::SatConvertSToU {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                signed_value: Id(reader.next_u32()?),
            },
            119u16 => Self::SatConvertUToS {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                unsigned_value: Id(reader.next_u32()?),
            },
            120u16 => Self::ConvertUToPtr {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                integer_value: Id(reader.next_u32()?),
            },
            121u16 => Self::PtrCastToGeneric {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
            },
            122u16 => Self::GenericCastToPtr {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
            },
            123u16 => Self::GenericCastToPtrExplicit {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                storage: StorageClass::parse(reader)?,
            },
            124u16 => Self::Bitcast {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            126u16 => Self::SNegate {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            127u16 => Self::FNegate {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            128u16 => Self::IAdd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            129u16 => Self::FAdd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            130u16 => Self::ISub {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            131u16 => Self::FSub {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            132u16 => Self::IMul {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            133u16 => Self::FMul {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            134u16 => Self::UDiv {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            135u16 => Self::SDiv {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            136u16 => Self::FDiv {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            137u16 => Self::UMod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            138u16 => Self::SRem {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            139u16 => Self::SMod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            140u16 => Self::FRem {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            141u16 => Self::FMod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            142u16 => Self::VectorTimesScalar {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector: Id(reader.next_u32()?),
                scalar: Id(reader.next_u32()?),
            },
            143u16 => Self::MatrixTimesScalar {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                matrix: Id(reader.next_u32()?),
                scalar: Id(reader.next_u32()?),
            },
            144u16 => Self::VectorTimesMatrix {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector: Id(reader.next_u32()?),
                matrix: Id(reader.next_u32()?),
            },
            145u16 => Self::MatrixTimesVector {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                matrix: Id(reader.next_u32()?),
                vector: Id(reader.next_u32()?),
            },
            146u16 => Self::MatrixTimesMatrix {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                left_matrix: Id(reader.next_u32()?),
                right_matrix: Id(reader.next_u32()?),
            },
            147u16 => Self::OuterProduct {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
            },
            148u16 => Self::Dot {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
            },
            149u16 => Self::IAddCarry {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            150u16 => Self::ISubBorrow {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            151u16 => Self::UMulExtended {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            152u16 => Self::SMulExtended {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            154u16 => Self::Any {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector: Id(reader.next_u32()?),
            },
            155u16 => Self::All {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector: Id(reader.next_u32()?),
            },
            156u16 => Self::IsNan {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                x: Id(reader.next_u32()?),
            },
            157u16 => Self::IsInf {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                x: Id(reader.next_u32()?),
            },
            158u16 => Self::IsFinite {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                x: Id(reader.next_u32()?),
            },
            159u16 => Self::IsNormal {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                x: Id(reader.next_u32()?),
            },
            160u16 => Self::SignBitSet {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                x: Id(reader.next_u32()?),
            },
            161u16 => Self::LessOrGreater {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                x: Id(reader.next_u32()?),
                y: Id(reader.next_u32()?),
            },
            162u16 => Self::Ordered {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                x: Id(reader.next_u32()?),
                y: Id(reader.next_u32()?),
            },
            163u16 => Self::Unordered {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                x: Id(reader.next_u32()?),
                y: Id(reader.next_u32()?),
            },
            164u16 => Self::LogicalEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            165u16 => Self::LogicalNotEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            166u16 => Self::LogicalOr {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            167u16 => Self::LogicalAnd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            168u16 => Self::LogicalNot {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            169u16 => Self::Select {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                condition: Id(reader.next_u32()?),
                object_1: Id(reader.next_u32()?),
                object_2: Id(reader.next_u32()?),
            },
            170u16 => Self::IEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            171u16 => Self::INotEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            172u16 => Self::UGreaterThan {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            173u16 => Self::SGreaterThan {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            174u16 => Self::UGreaterThanEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            175u16 => Self::SGreaterThanEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            176u16 => Self::ULessThan {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            177u16 => Self::SLessThan {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            178u16 => Self::ULessThanEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            179u16 => Self::SLessThanEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            180u16 => Self::FOrdEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            181u16 => Self::FUnordEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            182u16 => Self::FOrdNotEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            183u16 => Self::FUnordNotEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            184u16 => Self::FOrdLessThan {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            185u16 => Self::FUnordLessThan {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            186u16 => Self::FOrdGreaterThan {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            187u16 => Self::FUnordGreaterThan {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            188u16 => Self::FOrdLessThanEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            189u16 => Self::FUnordLessThanEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            190u16 => Self::FOrdGreaterThanEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            191u16 => Self::FUnordGreaterThanEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            194u16 => Self::ShiftRightLogical {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                shift: Id(reader.next_u32()?),
            },
            195u16 => Self::ShiftRightArithmetic {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                shift: Id(reader.next_u32()?),
            },
            196u16 => Self::ShiftLeftLogical {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                shift: Id(reader.next_u32()?),
            },
            197u16 => Self::BitwiseOr {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            198u16 => Self::BitwiseXor {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            199u16 => Self::BitwiseAnd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            200u16 => Self::Not {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            201u16 => Self::BitFieldInsert {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                insert: Id(reader.next_u32()?),
                offset: Id(reader.next_u32()?),
                count: Id(reader.next_u32()?),
            },
            202u16 => Self::BitFieldSExtract {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                offset: Id(reader.next_u32()?),
                count: Id(reader.next_u32()?),
            },
            203u16 => Self::BitFieldUExtract {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
                offset: Id(reader.next_u32()?),
                count: Id(reader.next_u32()?),
            },
            204u16 => Self::BitReverse {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
            },
            205u16 => Self::BitCount {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                base: Id(reader.next_u32()?),
            },
            207u16 => Self::DPdx {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                p: Id(reader.next_u32()?),
            },
            208u16 => Self::DPdy {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                p: Id(reader.next_u32()?),
            },
            209u16 => Self::Fwidth {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                p: Id(reader.next_u32()?),
            },
            210u16 => Self::DPdxFine {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                p: Id(reader.next_u32()?),
            },
            211u16 => Self::DPdyFine {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                p: Id(reader.next_u32()?),
            },
            212u16 => Self::FwidthFine {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                p: Id(reader.next_u32()?),
            },
            213u16 => Self::DPdxCoarse {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                p: Id(reader.next_u32()?),
            },
            214u16 => Self::DPdyCoarse {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                p: Id(reader.next_u32()?),
            },
            215u16 => Self::FwidthCoarse {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                p: Id(reader.next_u32()?),
            },
            218u16 => Self::EmitVertex,
            219u16 => Self::EndPrimitive,
            220u16 => Self::EmitStreamVertex {
                stream: Id(reader.next_u32()?),
            },
            221u16 => Self::EndStreamPrimitive {
                stream: Id(reader.next_u32()?),
            },
            224u16 => Self::ControlBarrier {
                execution: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
            },
            225u16 => Self::MemoryBarrier {
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
            },
            227u16 => Self::AtomicLoad {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
            },
            228u16 => Self::AtomicStore {
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            229u16 => Self::AtomicExchange {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            230u16 => Self::AtomicCompareExchange {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                equal: Id(reader.next_u32()?),
                unequal: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                comparator: Id(reader.next_u32()?),
            },
            231u16 => Self::AtomicCompareExchangeWeak {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                equal: Id(reader.next_u32()?),
                unequal: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                comparator: Id(reader.next_u32()?),
            },
            232u16 => Self::AtomicIIncrement {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
            },
            233u16 => Self::AtomicIDecrement {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
            },
            234u16 => Self::AtomicIAdd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            235u16 => Self::AtomicISub {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            236u16 => Self::AtomicSMin {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            237u16 => Self::AtomicUMin {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            238u16 => Self::AtomicSMax {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            239u16 => Self::AtomicUMax {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            240u16 => Self::AtomicAnd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            241u16 => Self::AtomicOr {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            242u16 => Self::AtomicXor {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            245u16 => Self::Phi {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                variable_parent: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push((Id(reader.next_u32()?), Id(reader.next_u32()?)));
                    }
                    vec
                },
            },
            246u16 => Self::LoopMerge {
                merge_block: Id(reader.next_u32()?),
                continue_target: Id(reader.next_u32()?),
                loop_control: LoopControl::parse(reader)?,
            },
            247u16 => Self::SelectionMerge {
                merge_block: Id(reader.next_u32()?),
                selection_control: SelectionControl::parse(reader)?,
            },
            248u16 => Self::Label {
                result_id: Id(reader.next_u32()?),
            },
            249u16 => Self::Branch {
                target_label: Id(reader.next_u32()?),
            },
            250u16 => Self::BranchConditional {
                condition: Id(reader.next_u32()?),
                true_label: Id(reader.next_u32()?),
                false_label: Id(reader.next_u32()?),
                branch_weights: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(reader.next_u32()?);
                    }
                    vec
                },
            },
            251u16 => Self::Switch {
                selector: Id(reader.next_u32()?),
                default: Id(reader.next_u32()?),
                target: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push((reader.next_u32()?, Id(reader.next_u32()?)));
                    }
                    vec
                },
            },
            252u16 => Self::Kill,
            253u16 => Self::Return,
            254u16 => Self::ReturnValue {
                value: Id(reader.next_u32()?),
            },
            255u16 => Self::Unreachable,
            256u16 => Self::LifetimeStart {
                pointer: Id(reader.next_u32()?),
                size: reader.next_u32()?,
            },
            257u16 => Self::LifetimeStop {
                pointer: Id(reader.next_u32()?),
                size: reader.next_u32()?,
            },
            259u16 => Self::GroupAsyncCopy {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                destination: Id(reader.next_u32()?),
                source: Id(reader.next_u32()?),
                num_elements: Id(reader.next_u32()?),
                stride: Id(reader.next_u32()?),
                event: Id(reader.next_u32()?),
            },
            260u16 => Self::GroupWaitEvents {
                execution: Id(reader.next_u32()?),
                num_events: Id(reader.next_u32()?),
                events_list: Id(reader.next_u32()?),
            },
            261u16 => Self::GroupAll {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                predicate: Id(reader.next_u32()?),
            },
            262u16 => Self::GroupAny {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                predicate: Id(reader.next_u32()?),
            },
            263u16 => Self::GroupBroadcast {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                local_id: Id(reader.next_u32()?),
            },
            264u16 => Self::GroupIAdd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            265u16 => Self::GroupFAdd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            266u16 => Self::GroupFMin {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            267u16 => Self::GroupUMin {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            268u16 => Self::GroupSMin {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            269u16 => Self::GroupFMax {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            270u16 => Self::GroupUMax {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            271u16 => Self::GroupSMax {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            274u16 => Self::ReadPipe {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            275u16 => Self::WritePipe {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            276u16 => Self::ReservedReadPipe {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                reserve_id: Id(reader.next_u32()?),
                index: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            277u16 => Self::ReservedWritePipe {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                reserve_id: Id(reader.next_u32()?),
                index: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            278u16 => Self::ReserveReadPipePackets {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                num_packets: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            279u16 => Self::ReserveWritePipePackets {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                num_packets: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            280u16 => Self::CommitReadPipe {
                pipe: Id(reader.next_u32()?),
                reserve_id: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            281u16 => Self::CommitWritePipe {
                pipe: Id(reader.next_u32()?),
                reserve_id: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            282u16 => Self::IsValidReserveId {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                reserve_id: Id(reader.next_u32()?),
            },
            283u16 => Self::GetNumPipePackets {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            284u16 => Self::GetMaxPipePackets {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            285u16 => Self::GroupReserveReadPipePackets {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                num_packets: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            286u16 => Self::GroupReserveWritePipePackets {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                num_packets: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            287u16 => Self::GroupCommitReadPipe {
                execution: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                reserve_id: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            288u16 => Self::GroupCommitWritePipe {
                execution: Id(reader.next_u32()?),
                pipe: Id(reader.next_u32()?),
                reserve_id: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            291u16 => Self::EnqueueMarker {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                queue: Id(reader.next_u32()?),
                num_events: Id(reader.next_u32()?),
                wait_events: Id(reader.next_u32()?),
                ret_event: Id(reader.next_u32()?),
            },
            292u16 => Self::EnqueueKernel {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                queue: Id(reader.next_u32()?),
                flags: Id(reader.next_u32()?),
                nd_range: Id(reader.next_u32()?),
                num_events: Id(reader.next_u32()?),
                wait_events: Id(reader.next_u32()?),
                ret_event: Id(reader.next_u32()?),
                invoke: Id(reader.next_u32()?),
                param: Id(reader.next_u32()?),
                param_size: Id(reader.next_u32()?),
                param_align: Id(reader.next_u32()?),
                local_size: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            293u16 => Self::GetKernelNDrangeSubGroupCount {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                nd_range: Id(reader.next_u32()?),
                invoke: Id(reader.next_u32()?),
                param: Id(reader.next_u32()?),
                param_size: Id(reader.next_u32()?),
                param_align: Id(reader.next_u32()?),
            },
            294u16 => Self::GetKernelNDrangeMaxSubGroupSize {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                nd_range: Id(reader.next_u32()?),
                invoke: Id(reader.next_u32()?),
                param: Id(reader.next_u32()?),
                param_size: Id(reader.next_u32()?),
                param_align: Id(reader.next_u32()?),
            },
            295u16 => Self::GetKernelWorkGroupSize {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                invoke: Id(reader.next_u32()?),
                param: Id(reader.next_u32()?),
                param_size: Id(reader.next_u32()?),
                param_align: Id(reader.next_u32()?),
            },
            296u16 => Self::GetKernelPreferredWorkGroupSizeMultiple {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                invoke: Id(reader.next_u32()?),
                param: Id(reader.next_u32()?),
                param_size: Id(reader.next_u32()?),
                param_align: Id(reader.next_u32()?),
            },
            297u16 => Self::RetainEvent {
                event: Id(reader.next_u32()?),
            },
            298u16 => Self::ReleaseEvent {
                event: Id(reader.next_u32()?),
            },
            299u16 => Self::CreateUserEvent {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            300u16 => Self::IsValidEvent {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                event: Id(reader.next_u32()?),
            },
            301u16 => Self::SetUserEventStatus {
                event: Id(reader.next_u32()?),
                status: Id(reader.next_u32()?),
            },
            302u16 => Self::CaptureEventProfilingInfo {
                event: Id(reader.next_u32()?),
                profiling_info: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            303u16 => Self::GetDefaultQueue {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            304u16 => Self::BuildNDRange {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                global_work_size: Id(reader.next_u32()?),
                local_work_size: Id(reader.next_u32()?),
                global_work_offset: Id(reader.next_u32()?),
            },
            305u16 => Self::ImageSparseSampleImplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            306u16 => Self::ImageSparseSampleExplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: ImageOperands::parse(reader)?,
            },
            307u16 => Self::ImageSparseSampleDrefImplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            308u16 => Self::ImageSparseSampleDrefExplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: ImageOperands::parse(reader)?,
            },
            309u16 => Self::ImageSparseSampleProjImplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            310u16 => Self::ImageSparseSampleProjExplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: ImageOperands::parse(reader)?,
            },
            311u16 => Self::ImageSparseSampleProjDrefImplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            312u16 => Self::ImageSparseSampleProjDrefExplicitLod {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: ImageOperands::parse(reader)?,
            },
            313u16 => Self::ImageSparseFetch {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            314u16 => Self::ImageSparseGather {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                component: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            315u16 => Self::ImageSparseDrefGather {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                dref: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            316u16 => Self::ImageSparseTexelsResident {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                resident_code: Id(reader.next_u32()?),
            },
            317u16 => Self::NoLine,
            318u16 => Self::AtomicFlagTestAndSet {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
            },
            319u16 => Self::AtomicFlagClear {
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
            },
            320u16 => Self::ImageSparseRead {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            321u16 => Self::SizeOf {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
            },
            322u16 => Self::TypePipeStorage {
                result_id: Id(reader.next_u32()?),
            },
            323u16 => Self::ConstantPipeStorage {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                packet_size: reader.next_u32()?,
                packet_alignment: reader.next_u32()?,
                capacity: reader.next_u32()?,
            },
            324u16 => Self::CreatePipeFromPipeStorage {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pipe_storage: Id(reader.next_u32()?),
            },
            325u16 => Self::GetKernelLocalSizeForSubgroupCount {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                subgroup_count: Id(reader.next_u32()?),
                invoke: Id(reader.next_u32()?),
                param: Id(reader.next_u32()?),
                param_size: Id(reader.next_u32()?),
                param_align: Id(reader.next_u32()?),
            },
            326u16 => Self::GetKernelMaxNumSubgroups {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                invoke: Id(reader.next_u32()?),
                param: Id(reader.next_u32()?),
                param_size: Id(reader.next_u32()?),
                param_align: Id(reader.next_u32()?),
            },
            327u16 => Self::TypeNamedBarrier {
                result_id: Id(reader.next_u32()?),
            },
            328u16 => Self::NamedBarrierInitialize {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                subgroup_count: Id(reader.next_u32()?),
            },
            329u16 => Self::MemoryNamedBarrier {
                named_barrier: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
            },
            330u16 => Self::ModuleProcessed {
                process: reader.next_string()?,
            },
            331u16 => Self::ExecutionModeId {
                entry_point: Id(reader.next_u32()?),
                mode: ExecutionMode::parse(reader)?,
            },
            332u16 => Self::DecorateId {
                target: Id(reader.next_u32()?),
                decoration: Decoration::parse(reader)?,
            },
            333u16 => Self::GroupNonUniformElect {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
            },
            334u16 => Self::GroupNonUniformAll {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                predicate: Id(reader.next_u32()?),
            },
            335u16 => Self::GroupNonUniformAny {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                predicate: Id(reader.next_u32()?),
            },
            336u16 => Self::GroupNonUniformAllEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            337u16 => Self::GroupNonUniformBroadcast {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                id: Id(reader.next_u32()?),
            },
            338u16 => Self::GroupNonUniformBroadcastFirst {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            339u16 => Self::GroupNonUniformBallot {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                predicate: Id(reader.next_u32()?),
            },
            340u16 => Self::GroupNonUniformInverseBallot {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            341u16 => Self::GroupNonUniformBallotBitExtract {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                index: Id(reader.next_u32()?),
            },
            342u16 => Self::GroupNonUniformBallotBitCount {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
            },
            343u16 => Self::GroupNonUniformBallotFindLSB {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            344u16 => Self::GroupNonUniformBallotFindMSB {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            345u16 => Self::GroupNonUniformShuffle {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                id: Id(reader.next_u32()?),
            },
            346u16 => Self::GroupNonUniformShuffleXor {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                mask: Id(reader.next_u32()?),
            },
            347u16 => Self::GroupNonUniformShuffleUp {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                delta: Id(reader.next_u32()?),
            },
            348u16 => Self::GroupNonUniformShuffleDown {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                delta: Id(reader.next_u32()?),
            },
            349u16 => Self::GroupNonUniformIAdd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            350u16 => Self::GroupNonUniformFAdd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            351u16 => Self::GroupNonUniformIMul {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            352u16 => Self::GroupNonUniformFMul {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            353u16 => Self::GroupNonUniformSMin {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            354u16 => Self::GroupNonUniformUMin {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            355u16 => Self::GroupNonUniformFMin {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            356u16 => Self::GroupNonUniformSMax {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            357u16 => Self::GroupNonUniformUMax {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            358u16 => Self::GroupNonUniformFMax {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            359u16 => Self::GroupNonUniformBitwiseAnd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            360u16 => Self::GroupNonUniformBitwiseOr {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            361u16 => Self::GroupNonUniformBitwiseXor {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            362u16 => Self::GroupNonUniformLogicalAnd {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            363u16 => Self::GroupNonUniformLogicalOr {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            364u16 => Self::GroupNonUniformLogicalXor {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                value: Id(reader.next_u32()?),
                cluster_size: if !reader.is_empty() {
                    Some(Id(reader.next_u32()?))
                } else {
                    None
                },
            },
            365u16 => Self::GroupNonUniformQuadBroadcast {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                index: Id(reader.next_u32()?),
            },
            366u16 => Self::GroupNonUniformQuadSwap {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                direction: Id(reader.next_u32()?),
            },
            400u16 => Self::CopyLogical {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            401u16 => Self::PtrEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            402u16 => Self::PtrNotEqual {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            403u16 => Self::PtrDiff {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            4416u16 => Self::TerminateInvocation,
            4421u16 => Self::SubgroupBallotKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                predicate: Id(reader.next_u32()?),
            },
            4422u16 => Self::SubgroupFirstInvocationKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            4428u16 => Self::SubgroupAllKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                predicate: Id(reader.next_u32()?),
            },
            4429u16 => Self::SubgroupAnyKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                predicate: Id(reader.next_u32()?),
            },
            4430u16 => Self::SubgroupAllEqualKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                predicate: Id(reader.next_u32()?),
            },
            4432u16 => Self::SubgroupReadInvocationKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                index: Id(reader.next_u32()?),
            },
            4445u16 => Self::TraceRayKHR {
                accel: Id(reader.next_u32()?),
                ray_flags: Id(reader.next_u32()?),
                cull_mask: Id(reader.next_u32()?),
                sbt_offset: Id(reader.next_u32()?),
                sbt_stride: Id(reader.next_u32()?),
                miss_index: Id(reader.next_u32()?),
                ray_origin: Id(reader.next_u32()?),
                ray_tmin: Id(reader.next_u32()?),
                ray_direction: Id(reader.next_u32()?),
                ray_tmax: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            4446u16 => Self::ExecuteCallableKHR {
                sbt_index: Id(reader.next_u32()?),
                callable_data: Id(reader.next_u32()?),
            },
            4447u16 => Self::ConvertUToAccelerationStructureKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                accel: Id(reader.next_u32()?),
            },
            4448u16 => Self::IgnoreIntersectionKHR,
            4449u16 => Self::TerminateRayKHR,
            4450u16 => Self::SDotKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
                packed_vector_format: if !reader.is_empty() {
                    Some(PackedVectorFormat::parse(reader)?)
                } else {
                    None
                },
            },
            4451u16 => Self::UDotKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
                packed_vector_format: if !reader.is_empty() {
                    Some(PackedVectorFormat::parse(reader)?)
                } else {
                    None
                },
            },
            4452u16 => Self::SUDotKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
                packed_vector_format: if !reader.is_empty() {
                    Some(PackedVectorFormat::parse(reader)?)
                } else {
                    None
                },
            },
            4453u16 => Self::SDotAccSatKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
                accumulator: Id(reader.next_u32()?),
                packed_vector_format: if !reader.is_empty() {
                    Some(PackedVectorFormat::parse(reader)?)
                } else {
                    None
                },
            },
            4454u16 => Self::UDotAccSatKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
                accumulator: Id(reader.next_u32()?),
                packed_vector_format: if !reader.is_empty() {
                    Some(PackedVectorFormat::parse(reader)?)
                } else {
                    None
                },
            },
            4455u16 => Self::SUDotAccSatKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
                accumulator: Id(reader.next_u32()?),
                packed_vector_format: if !reader.is_empty() {
                    Some(PackedVectorFormat::parse(reader)?)
                } else {
                    None
                },
            },
            4472u16 => Self::TypeRayQueryKHR {
                result_id: Id(reader.next_u32()?),
            },
            4473u16 => Self::RayQueryInitializeKHR {
                ray_query: Id(reader.next_u32()?),
                accel: Id(reader.next_u32()?),
                ray_flags: Id(reader.next_u32()?),
                cull_mask: Id(reader.next_u32()?),
                ray_origin: Id(reader.next_u32()?),
                ray_t_min: Id(reader.next_u32()?),
                ray_direction: Id(reader.next_u32()?),
                ray_t_max: Id(reader.next_u32()?),
            },
            4474u16 => Self::RayQueryTerminateKHR {
                ray_query: Id(reader.next_u32()?),
            },
            4475u16 => Self::RayQueryGenerateIntersectionKHR {
                ray_query: Id(reader.next_u32()?),
                hit_t: Id(reader.next_u32()?),
            },
            4476u16 => Self::RayQueryConfirmIntersectionKHR {
                ray_query: Id(reader.next_u32()?),
            },
            4477u16 => Self::RayQueryProceedKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
            },
            4479u16 => Self::RayQueryGetIntersectionTypeKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            5000u16 => Self::GroupIAddNonUniformAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            5001u16 => Self::GroupFAddNonUniformAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            5002u16 => Self::GroupFMinNonUniformAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            5003u16 => Self::GroupUMinNonUniformAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            5004u16 => Self::GroupSMinNonUniformAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            5005u16 => Self::GroupFMaxNonUniformAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            5006u16 => Self::GroupUMaxNonUniformAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            5007u16 => Self::GroupSMaxNonUniformAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                operation: GroupOperation::parse(reader)?,
                x: Id(reader.next_u32()?),
            },
            5011u16 => Self::FragmentMaskFetchAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
            },
            5012u16 => Self::FragmentFetchAMD {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                fragment_index: Id(reader.next_u32()?),
            },
            5056u16 => Self::ReadClockKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                scope: Id(reader.next_u32()?),
            },
            5283u16 => Self::ImageSampleFootprintNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                sampled_image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                granularity: Id(reader.next_u32()?),
                coarse: Id(reader.next_u32()?),
                image_operands: if !reader.is_empty() {
                    Some(ImageOperands::parse(reader)?)
                } else {
                    None
                },
            },
            5296u16 => Self::GroupNonUniformPartitionNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            5299u16 => Self::WritePackedPrimitiveIndices4x8NV {
                index_offset: Id(reader.next_u32()?),
                packed_indices: Id(reader.next_u32()?),
            },
            5334u16 => Self::ReportIntersectionKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                hit: Id(reader.next_u32()?),
                hit_kind: Id(reader.next_u32()?),
            },
            5335u16 => Self::IgnoreIntersectionNV,
            5336u16 => Self::TerminateRayNV,
            5337u16 => Self::TraceNV {
                accel: Id(reader.next_u32()?),
                ray_flags: Id(reader.next_u32()?),
                cull_mask: Id(reader.next_u32()?),
                sbt_offset: Id(reader.next_u32()?),
                sbt_stride: Id(reader.next_u32()?),
                miss_index: Id(reader.next_u32()?),
                ray_origin: Id(reader.next_u32()?),
                ray_tmin: Id(reader.next_u32()?),
                ray_direction: Id(reader.next_u32()?),
                ray_tmax: Id(reader.next_u32()?),
                payload_id: Id(reader.next_u32()?),
            },
            5338u16 => Self::TraceMotionNV {
                accel: Id(reader.next_u32()?),
                ray_flags: Id(reader.next_u32()?),
                cull_mask: Id(reader.next_u32()?),
                sbt_offset: Id(reader.next_u32()?),
                sbt_stride: Id(reader.next_u32()?),
                miss_index: Id(reader.next_u32()?),
                ray_origin: Id(reader.next_u32()?),
                ray_tmin: Id(reader.next_u32()?),
                ray_direction: Id(reader.next_u32()?),
                ray_tmax: Id(reader.next_u32()?),
                time: Id(reader.next_u32()?),
                payload_id: Id(reader.next_u32()?),
            },
            5339u16 => Self::TraceRayMotionNV {
                accel: Id(reader.next_u32()?),
                ray_flags: Id(reader.next_u32()?),
                cull_mask: Id(reader.next_u32()?),
                sbt_offset: Id(reader.next_u32()?),
                sbt_stride: Id(reader.next_u32()?),
                miss_index: Id(reader.next_u32()?),
                ray_origin: Id(reader.next_u32()?),
                ray_tmin: Id(reader.next_u32()?),
                ray_direction: Id(reader.next_u32()?),
                ray_tmax: Id(reader.next_u32()?),
                time: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5341u16 => Self::TypeAccelerationStructureKHR {
                result_id: Id(reader.next_u32()?),
            },
            5344u16 => Self::ExecuteCallableNV {
                sbt_index: Id(reader.next_u32()?),
                callable_data_id: Id(reader.next_u32()?),
            },
            5358u16 => Self::TypeCooperativeMatrixNV {
                result_id: Id(reader.next_u32()?),
                component_type: Id(reader.next_u32()?),
                execution: Id(reader.next_u32()?),
                rows: Id(reader.next_u32()?),
                columns: Id(reader.next_u32()?),
            },
            5359u16 => Self::CooperativeMatrixLoadNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                stride: Id(reader.next_u32()?),
                column_major: Id(reader.next_u32()?),
                memory_access: if !reader.is_empty() {
                    Some(MemoryAccess::parse(reader)?)
                } else {
                    None
                },
            },
            5360u16 => Self::CooperativeMatrixStoreNV {
                pointer: Id(reader.next_u32()?),
                object: Id(reader.next_u32()?),
                stride: Id(reader.next_u32()?),
                column_major: Id(reader.next_u32()?),
                memory_access: if !reader.is_empty() {
                    Some(MemoryAccess::parse(reader)?)
                } else {
                    None
                },
            },
            5361u16 => Self::CooperativeMatrixMulAddNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                b: Id(reader.next_u32()?),
                c: Id(reader.next_u32()?),
            },
            5362u16 => Self::CooperativeMatrixLengthNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ty: Id(reader.next_u32()?),
            },
            5364u16 => Self::BeginInvocationInterlockEXT,
            5365u16 => Self::EndInvocationInterlockEXT,
            5380u16 => Self::DemoteToHelperInvocationEXT,
            5381u16 => Self::IsHelperInvocationEXT {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            5391u16 => Self::ConvertUToImageNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            5392u16 => Self::ConvertUToSamplerNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            5393u16 => Self::ConvertImageToUNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            5394u16 => Self::ConvertSamplerToUNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            5395u16 => Self::ConvertUToSampledImageNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            5396u16 => Self::ConvertSampledImageToUNV {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            5397u16 => Self::SamplerImageAddressingModeNV {
                bit_width: reader.next_u32()?,
            },
            5571u16 => Self::SubgroupShuffleINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                data: Id(reader.next_u32()?),
                invocation_id: Id(reader.next_u32()?),
            },
            5572u16 => Self::SubgroupShuffleDownINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                current: Id(reader.next_u32()?),
                next: Id(reader.next_u32()?),
                delta: Id(reader.next_u32()?),
            },
            5573u16 => Self::SubgroupShuffleUpINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                previous: Id(reader.next_u32()?),
                current: Id(reader.next_u32()?),
                delta: Id(reader.next_u32()?),
            },
            5574u16 => Self::SubgroupShuffleXorINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                data: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            5575u16 => Self::SubgroupBlockReadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ptr: Id(reader.next_u32()?),
            },
            5576u16 => Self::SubgroupBlockWriteINTEL {
                ptr: Id(reader.next_u32()?),
                data: Id(reader.next_u32()?),
            },
            5577u16 => Self::SubgroupImageBlockReadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
            },
            5578u16 => Self::SubgroupImageBlockWriteINTEL {
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                data: Id(reader.next_u32()?),
            },
            5580u16 => Self::SubgroupImageMediaBlockReadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                width: Id(reader.next_u32()?),
                height: Id(reader.next_u32()?),
            },
            5581u16 => Self::SubgroupImageMediaBlockWriteINTEL {
                image: Id(reader.next_u32()?),
                coordinate: Id(reader.next_u32()?),
                width: Id(reader.next_u32()?),
                height: Id(reader.next_u32()?),
                data: Id(reader.next_u32()?),
            },
            5585u16 => Self::UCountLeadingZerosINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            5586u16 => Self::UCountTrailingZerosINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand: Id(reader.next_u32()?),
            },
            5587u16 => Self::AbsISubINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5588u16 => Self::AbsUSubINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5589u16 => Self::IAddSatINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5590u16 => Self::UAddSatINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5591u16 => Self::IAverageINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5592u16 => Self::UAverageINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5593u16 => Self::IAverageRoundedINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5594u16 => Self::UAverageRoundedINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5595u16 => Self::ISubSatINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5596u16 => Self::USubSatINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5597u16 => Self::IMul32x16INTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5598u16 => Self::UMul32x16INTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            5600u16 => Self::ConstFunctionPointerINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                function: Id(reader.next_u32()?),
            },
            5601u16 => Self::FunctionPointerCallINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                operand1: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            5609u16 => Self::AsmTargetINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                asm_target: reader.next_string()?,
            },
            5610u16 => Self::AsmINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                asm_type: Id(reader.next_u32()?),
                target: Id(reader.next_u32()?),
                asm_instructions: reader.next_string()?,
                constraints: reader.next_string()?,
            },
            5611u16 => Self::AsmCallINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                asm: Id(reader.next_u32()?),
                argument_0: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            5614u16 => Self::AtomicFMinEXT {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            5615u16 => Self::AtomicFMaxEXT {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            5630u16 => Self::AssumeTrueKHR {
                condition: Id(reader.next_u32()?),
            },
            5631u16 => Self::ExpectKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
                expected_value: Id(reader.next_u32()?),
            },
            5632u16 => Self::DecorateString {
                target: Id(reader.next_u32()?),
                decoration: Decoration::parse(reader)?,
            },
            5633u16 => Self::MemberDecorateString {
                struct_type: Id(reader.next_u32()?),
                member: reader.next_u32()?,
                decoration: Decoration::parse(reader)?,
            },
            5699u16 => Self::VmeImageINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image_type: Id(reader.next_u32()?),
                sampler: Id(reader.next_u32()?),
            },
            5700u16 => Self::TypeVmeImageINTEL {
                result_id: Id(reader.next_u32()?),
                image_type: Id(reader.next_u32()?),
            },
            5701u16 => Self::TypeAvcImePayloadINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5702u16 => Self::TypeAvcRefPayloadINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5703u16 => Self::TypeAvcSicPayloadINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5704u16 => Self::TypeAvcMcePayloadINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5705u16 => Self::TypeAvcMceResultINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5706u16 => Self::TypeAvcImeResultINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5707u16 => Self::TypeAvcImeResultSingleReferenceStreamoutINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5708u16 => Self::TypeAvcImeResultDualReferenceStreamoutINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5709u16 => Self::TypeAvcImeSingleReferenceStreaminINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5710u16 => Self::TypeAvcImeDualReferenceStreaminINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5711u16 => Self::TypeAvcRefResultINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5712u16 => Self::TypeAvcSicResultINTEL {
                result_id: Id(reader.next_u32()?),
            },
            5713u16 => Self::SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                slice_type: Id(reader.next_u32()?),
                qp: Id(reader.next_u32()?),
            },
            5714u16 => Self::SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                reference_base_penalty: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5715u16 => Self::SubgroupAvcMceGetDefaultInterShapePenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                slice_type: Id(reader.next_u32()?),
                qp: Id(reader.next_u32()?),
            },
            5716u16 => Self::SubgroupAvcMceSetInterShapePenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                packed_shape_penalty: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5717u16 => Self::SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                slice_type: Id(reader.next_u32()?),
                qp: Id(reader.next_u32()?),
            },
            5718u16 => Self::SubgroupAvcMceSetInterDirectionPenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                direction_cost: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5719u16 => Self::SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                slice_type: Id(reader.next_u32()?),
                qp: Id(reader.next_u32()?),
            },
            5720u16 => Self::SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                slice_type: Id(reader.next_u32()?),
                qp: Id(reader.next_u32()?),
            },
            5721u16 => Self::SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            5722u16 => Self::SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            5723u16 => Self::SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            5724u16 => Self::SubgroupAvcMceSetMotionVectorCostFunctionINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                packed_cost_center_delta: Id(reader.next_u32()?),
                packed_cost_table: Id(reader.next_u32()?),
                cost_precision: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5725u16 => Self::SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                slice_type: Id(reader.next_u32()?),
                qp: Id(reader.next_u32()?),
            },
            5726u16 => Self::SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            5727u16 => Self::SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            5728u16 => Self::SubgroupAvcMceSetAcOnlyHaarINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5729u16 => Self::SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                source_field_polarity: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5730u16 => Self::SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                reference_field_polarity: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5731u16 => Self::SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                forward_reference_field_polarity: Id(reader.next_u32()?),
                backward_reference_field_polarity: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5732u16 => Self::SubgroupAvcMceConvertToImePayloadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5733u16 => Self::SubgroupAvcMceConvertToImeResultINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5734u16 => Self::SubgroupAvcMceConvertToRefPayloadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5735u16 => Self::SubgroupAvcMceConvertToRefResultINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5736u16 => Self::SubgroupAvcMceConvertToSicPayloadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5737u16 => Self::SubgroupAvcMceConvertToSicResultINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5738u16 => Self::SubgroupAvcMceGetMotionVectorsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5739u16 => Self::SubgroupAvcMceGetInterDistortionsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5740u16 => Self::SubgroupAvcMceGetBestInterDistortionsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5741u16 => Self::SubgroupAvcMceGetInterMajorShapeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5742u16 => Self::SubgroupAvcMceGetInterMinorShapeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5743u16 => Self::SubgroupAvcMceGetInterDirectionsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5744u16 => Self::SubgroupAvcMceGetInterMotionVectorCountINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5745u16 => Self::SubgroupAvcMceGetInterReferenceIdsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5746u16 => Self::SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                packed_reference_ids: Id(reader.next_u32()?),
                packed_reference_parameter_field_polarities: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5747u16 => Self::SubgroupAvcImeInitializeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_coord: Id(reader.next_u32()?),
                partition_mask: Id(reader.next_u32()?),
                sad_adjustment: Id(reader.next_u32()?),
            },
            5748u16 => Self::SubgroupAvcImeSetSingleReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ref_offset: Id(reader.next_u32()?),
                search_window_config: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5749u16 => Self::SubgroupAvcImeSetDualReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                fwd_ref_offset: Id(reader.next_u32()?),
                bwd_ref_offset: Id(reader.next_u32()?),
                id_search_window_config: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5750u16 => Self::SubgroupAvcImeRefWindowSizeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                search_window_config: Id(reader.next_u32()?),
                dual_ref: Id(reader.next_u32()?),
            },
            5751u16 => Self::SubgroupAvcImeAdjustRefOffsetINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ref_offset: Id(reader.next_u32()?),
                src_coord: Id(reader.next_u32()?),
                ref_window_size: Id(reader.next_u32()?),
                image_size: Id(reader.next_u32()?),
            },
            5752u16 => Self::SubgroupAvcImeConvertToMcePayloadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5753u16 => Self::SubgroupAvcImeSetMaxMotionVectorCountINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                max_motion_vector_count: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5754u16 => Self::SubgroupAvcImeSetUnidirectionalMixDisableINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5755u16 => Self::SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                threshold: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5756u16 => Self::SubgroupAvcImeSetWeightedSadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                packed_sad_weights: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5757u16 => Self::SubgroupAvcImeEvaluateWithSingleReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5758u16 => Self::SubgroupAvcImeEvaluateWithDualReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                fwd_ref_image: Id(reader.next_u32()?),
                bwd_ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5759u16 => Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
                streamin_components: Id(reader.next_u32()?),
            },
            5760u16 => Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                fwd_ref_image: Id(reader.next_u32()?),
                bwd_ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
                streamin_components: Id(reader.next_u32()?),
            },
            5761u16 => Self::SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5762u16 => Self::SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                fwd_ref_image: Id(reader.next_u32()?),
                bwd_ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5763u16 => Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
                streamin_components: Id(reader.next_u32()?),
            },
            5764u16 => Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                fwd_ref_image: Id(reader.next_u32()?),
                bwd_ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
                streamin_components: Id(reader.next_u32()?),
            },
            5765u16 => Self::SubgroupAvcImeConvertToMceResultINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5766u16 => Self::SubgroupAvcImeGetSingleReferenceStreaminINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5767u16 => Self::SubgroupAvcImeGetDualReferenceStreaminINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5768u16 => Self::SubgroupAvcImeStripSingleReferenceStreamoutINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5769u16 => Self::SubgroupAvcImeStripDualReferenceStreamoutINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5770u16 => {
                Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL {
                    result_type_id: Id(reader.next_u32()?),
                    result_id: Id(reader.next_u32()?),
                    payload: Id(reader.next_u32()?),
                    major_shape: Id(reader.next_u32()?),
                }
            }
            5771u16 => Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
                major_shape: Id(reader.next_u32()?),
            },
            5772u16 => Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
                major_shape: Id(reader.next_u32()?),
            },
            5773u16 => Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
                major_shape: Id(reader.next_u32()?),
                direction: Id(reader.next_u32()?),
            },
            5774u16 => Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
                major_shape: Id(reader.next_u32()?),
                direction: Id(reader.next_u32()?),
            },
            5775u16 => Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
                major_shape: Id(reader.next_u32()?),
                direction: Id(reader.next_u32()?),
            },
            5776u16 => Self::SubgroupAvcImeGetBorderReachedINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                image_select: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5777u16 => Self::SubgroupAvcImeGetTruncatedSearchIndicationINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5778u16 => Self::SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5779u16 => Self::SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5780u16 => Self::SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5781u16 => Self::SubgroupAvcFmeInitializeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_coord: Id(reader.next_u32()?),
                motion_vectors: Id(reader.next_u32()?),
                major_shapes: Id(reader.next_u32()?),
                minor_shapes: Id(reader.next_u32()?),
                direction: Id(reader.next_u32()?),
                pixel_resolution: Id(reader.next_u32()?),
                sad_adjustment: Id(reader.next_u32()?),
            },
            5782u16 => Self::SubgroupAvcBmeInitializeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_coord: Id(reader.next_u32()?),
                motion_vectors: Id(reader.next_u32()?),
                major_shapes: Id(reader.next_u32()?),
                minor_shapes: Id(reader.next_u32()?),
                direction: Id(reader.next_u32()?),
                pixel_resolution: Id(reader.next_u32()?),
                bidirectional_weight: Id(reader.next_u32()?),
                sad_adjustment: Id(reader.next_u32()?),
            },
            5783u16 => Self::SubgroupAvcRefConvertToMcePayloadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5784u16 => Self::SubgroupAvcRefSetBidirectionalMixDisableINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5785u16 => Self::SubgroupAvcRefSetBilinearFilterEnableINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5786u16 => Self::SubgroupAvcRefEvaluateWithSingleReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5787u16 => Self::SubgroupAvcRefEvaluateWithDualReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                fwd_ref_image: Id(reader.next_u32()?),
                bwd_ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5788u16 => Self::SubgroupAvcRefEvaluateWithMultiReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                packed_reference_ids: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5789u16 => Self::SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                packed_reference_ids: Id(reader.next_u32()?),
                packed_reference_field_polarities: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5790u16 => Self::SubgroupAvcRefConvertToMceResultINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5791u16 => Self::SubgroupAvcSicInitializeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_coord: Id(reader.next_u32()?),
            },
            5792u16 => Self::SubgroupAvcSicConfigureSkcINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                skip_block_partition_type: Id(reader.next_u32()?),
                skip_motion_vector_mask: Id(reader.next_u32()?),
                motion_vectors: Id(reader.next_u32()?),
                bidirectional_weight: Id(reader.next_u32()?),
                sad_adjustment: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5793u16 => Self::SubgroupAvcSicConfigureIpeLumaINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                luma_intra_partition_mask: Id(reader.next_u32()?),
                intra_neighbour_availabilty: Id(reader.next_u32()?),
                left_edge_luma_pixels: Id(reader.next_u32()?),
                upper_left_corner_luma_pixel: Id(reader.next_u32()?),
                upper_edge_luma_pixels: Id(reader.next_u32()?),
                upper_right_edge_luma_pixels: Id(reader.next_u32()?),
                sad_adjustment: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5794u16 => Self::SubgroupAvcSicConfigureIpeLumaChromaINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                luma_intra_partition_mask: Id(reader.next_u32()?),
                intra_neighbour_availabilty: Id(reader.next_u32()?),
                left_edge_luma_pixels: Id(reader.next_u32()?),
                upper_left_corner_luma_pixel: Id(reader.next_u32()?),
                upper_edge_luma_pixels: Id(reader.next_u32()?),
                upper_right_edge_luma_pixels: Id(reader.next_u32()?),
                left_edge_chroma_pixels: Id(reader.next_u32()?),
                upper_left_corner_chroma_pixel: Id(reader.next_u32()?),
                upper_edge_chroma_pixels: Id(reader.next_u32()?),
                sad_adjustment: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5795u16 => Self::SubgroupAvcSicGetMotionVectorMaskINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                skip_block_partition_type: Id(reader.next_u32()?),
                direction: Id(reader.next_u32()?),
            },
            5796u16 => Self::SubgroupAvcSicConvertToMcePayloadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5797u16 => Self::SubgroupAvcSicSetIntraLumaShapePenaltyINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                packed_shape_penalty: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5798u16 => Self::SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                luma_mode_penalty: Id(reader.next_u32()?),
                luma_packed_neighbor_modes: Id(reader.next_u32()?),
                luma_packed_non_dc_penalty: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5799u16 => Self::SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                chroma_mode_base_penalty: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5800u16 => Self::SubgroupAvcSicSetBilinearFilterEnableINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5801u16 => Self::SubgroupAvcSicSetSkcForwardTransformEnableINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                packed_sad_coefficients: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5802u16 => Self::SubgroupAvcSicSetBlockBasedRawSkipSadINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                block_based_skip_type: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5803u16 => Self::SubgroupAvcSicEvaluateIpeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5804u16 => Self::SubgroupAvcSicEvaluateWithSingleReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5805u16 => Self::SubgroupAvcSicEvaluateWithDualReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                fwd_ref_image: Id(reader.next_u32()?),
                bwd_ref_image: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5806u16 => Self::SubgroupAvcSicEvaluateWithMultiReferenceINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                packed_reference_ids: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5807u16 => Self::SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                src_image: Id(reader.next_u32()?),
                packed_reference_ids: Id(reader.next_u32()?),
                packed_reference_field_polarities: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5808u16 => Self::SubgroupAvcSicConvertToMceResultINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5809u16 => Self::SubgroupAvcSicGetIpeLumaShapeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5810u16 => Self::SubgroupAvcSicGetBestIpeLumaDistortionINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5811u16 => Self::SubgroupAvcSicGetBestIpeChromaDistortionINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5812u16 => Self::SubgroupAvcSicGetPackedIpeLumaModesINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5813u16 => Self::SubgroupAvcSicGetIpeChromaModeINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5814u16 => Self::SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5815u16 => Self::SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5816u16 => Self::SubgroupAvcSicGetInterRawSadsINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                payload: Id(reader.next_u32()?),
            },
            5818u16 => Self::VariableLengthArrayINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                lenght: Id(reader.next_u32()?),
            },
            5819u16 => Self::SaveMemoryINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
            },
            5820u16 => Self::RestoreMemoryINTEL {
                ptr: Id(reader.next_u32()?),
            },
            5840u16 => Self::ArbitraryFloatSinCosPiINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                from_sign: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5841u16 => Self::ArbitraryFloatCastINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5842u16 => Self::ArbitraryFloatCastFromIntINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                mout: reader.next_u32()?,
                from_sign: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5843u16 => Self::ArbitraryFloatCastToIntINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5846u16 => Self::ArbitraryFloatAddINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5847u16 => Self::ArbitraryFloatSubINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5848u16 => Self::ArbitraryFloatMulINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5849u16 => Self::ArbitraryFloatDivINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5850u16 => Self::ArbitraryFloatGTINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
            },
            5851u16 => Self::ArbitraryFloatGEINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
            },
            5852u16 => Self::ArbitraryFloatLTINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
            },
            5853u16 => Self::ArbitraryFloatLEINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
            },
            5854u16 => Self::ArbitraryFloatEQINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
            },
            5855u16 => Self::ArbitraryFloatRecipINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5856u16 => Self::ArbitraryFloatRSqrtINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5857u16 => Self::ArbitraryFloatCbrtINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5858u16 => Self::ArbitraryFloatHypotINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5859u16 => Self::ArbitraryFloatSqrtINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5860u16 => Self::ArbitraryFloatLogINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5861u16 => Self::ArbitraryFloatLog2INTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5862u16 => Self::ArbitraryFloatLog10INTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5863u16 => Self::ArbitraryFloatLog1pINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5864u16 => Self::ArbitraryFloatExpINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5865u16 => Self::ArbitraryFloatExp2INTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5866u16 => Self::ArbitraryFloatExp10INTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5867u16 => Self::ArbitraryFloatExpm1INTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5868u16 => Self::ArbitraryFloatSinINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5869u16 => Self::ArbitraryFloatCosINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5870u16 => Self::ArbitraryFloatSinCosINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5871u16 => Self::ArbitraryFloatSinPiINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5872u16 => Self::ArbitraryFloatCosPiINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5873u16 => Self::ArbitraryFloatASinINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5874u16 => Self::ArbitraryFloatASinPiINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5875u16 => Self::ArbitraryFloatACosINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5876u16 => Self::ArbitraryFloatACosPiINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5877u16 => Self::ArbitraryFloatATanINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5878u16 => Self::ArbitraryFloatATanPiINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5879u16 => Self::ArbitraryFloatATan2INTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5880u16 => Self::ArbitraryFloatPowINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5881u16 => Self::ArbitraryFloatPowRINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                m2: reader.next_u32()?,
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5882u16 => Self::ArbitraryFloatPowNINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                a: Id(reader.next_u32()?),
                m1: reader.next_u32()?,
                b: Id(reader.next_u32()?),
                mout: reader.next_u32()?,
                enable_subnormals: reader.next_u32()?,
                rounding_mode: reader.next_u32()?,
                rounding_accuracy: reader.next_u32()?,
            },
            5887u16 => Self::LoopControlINTEL {
                loop_control_parameters: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(reader.next_u32()?);
                    }
                    vec
                },
            },
            5923u16 => Self::FixedSqrtINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5924u16 => Self::FixedRecipINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5925u16 => Self::FixedRsqrtINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5926u16 => Self::FixedSinINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5927u16 => Self::FixedCosINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5928u16 => Self::FixedSinCosINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5929u16 => Self::FixedSinPiINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5930u16 => Self::FixedCosPiINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5931u16 => Self::FixedSinCosPiINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5932u16 => Self::FixedLogINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5933u16 => Self::FixedExpINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                input_type: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
                s: reader.next_u32()?,
                i: reader.next_u32()?,
                r_i: reader.next_u32()?,
                q: reader.next_u32()?,
                o: reader.next_u32()?,
            },
            5934u16 => Self::PtrCastToCrossWorkgroupINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
            },
            5938u16 => Self::CrossWorkgroupCastToPtrINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
            },
            5946u16 => Self::ReadPipeBlockingINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            5947u16 => Self::WritePipeBlockingINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                packet_size: Id(reader.next_u32()?),
                packet_alignment: Id(reader.next_u32()?),
            },
            5949u16 => Self::FPGARegINTEL {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                result: Id(reader.next_u32()?),
                input: Id(reader.next_u32()?),
            },
            6016u16 => Self::RayQueryGetRayTMinKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
            },
            6017u16 => Self::RayQueryGetRayFlagsKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
            },
            6018u16 => Self::RayQueryGetIntersectionTKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6019u16 => Self::RayQueryGetIntersectionInstanceCustomIndexKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6020u16 => Self::RayQueryGetIntersectionInstanceIdKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6021u16 => Self::RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6022u16 => Self::RayQueryGetIntersectionGeometryIndexKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6023u16 => Self::RayQueryGetIntersectionPrimitiveIndexKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6024u16 => Self::RayQueryGetIntersectionBarycentricsKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6025u16 => Self::RayQueryGetIntersectionFrontFaceKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6026u16 => Self::RayQueryGetIntersectionCandidateAABBOpaqueKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
            },
            6027u16 => Self::RayQueryGetIntersectionObjectRayDirectionKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6028u16 => Self::RayQueryGetIntersectionObjectRayOriginKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6029u16 => Self::RayQueryGetWorldRayDirectionKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
            },
            6030u16 => Self::RayQueryGetWorldRayOriginKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
            },
            6031u16 => Self::RayQueryGetIntersectionObjectToWorldKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6032u16 => Self::RayQueryGetIntersectionWorldToObjectKHR {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                ray_query: Id(reader.next_u32()?),
                intersection: Id(reader.next_u32()?),
            },
            6035u16 => Self::AtomicFAddEXT {
                result_type_id: Id(reader.next_u32()?),
                result_id: Id(reader.next_u32()?),
                pointer: Id(reader.next_u32()?),
                memory: Id(reader.next_u32()?),
                semantics: Id(reader.next_u32()?),
                value: Id(reader.next_u32()?),
            },
            6086u16 => Self::TypeBufferSurfaceINTEL {
                result_id: Id(reader.next_u32()?),
                access_qualifier: AccessQualifier::parse(reader)?,
            },
            6090u16 => Self::TypeStructContinuedINTEL {
                member_types: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            6091u16 => Self::ConstantCompositeContinuedINTEL {
                constituents: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            6092u16 => Self::SpecConstantCompositeContinuedINTEL {
                constituents: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            opcode => return Err(reader.map_err(ParseErrors::UnknownOpcode(opcode))),
        })
    }
    #[doc = r" Returns the `Id` that is assigned by this instruction, if any."]
    pub fn result_id(&self) -> Option<Id> {
        match self {
            Self::Undef { result_id, .. }
            | Self::String { result_id, .. }
            | Self::ExtInstImport { result_id, .. }
            | Self::ExtInst { result_id, .. }
            | Self::TypeVoid { result_id, .. }
            | Self::TypeBool { result_id, .. }
            | Self::TypeInt { result_id, .. }
            | Self::TypeFloat { result_id, .. }
            | Self::TypeVector { result_id, .. }
            | Self::TypeMatrix { result_id, .. }
            | Self::TypeImage { result_id, .. }
            | Self::TypeSampler { result_id, .. }
            | Self::TypeSampledImage { result_id, .. }
            | Self::TypeArray { result_id, .. }
            | Self::TypeRuntimeArray { result_id, .. }
            | Self::TypeStruct { result_id, .. }
            | Self::TypeOpaque { result_id, .. }
            | Self::TypePointer { result_id, .. }
            | Self::TypeFunction { result_id, .. }
            | Self::TypeEvent { result_id, .. }
            | Self::TypeDeviceEvent { result_id, .. }
            | Self::TypeReserveId { result_id, .. }
            | Self::TypeQueue { result_id, .. }
            | Self::TypePipe { result_id, .. }
            | Self::ConstantTrue { result_id, .. }
            | Self::ConstantFalse { result_id, .. }
            | Self::Constant { result_id, .. }
            | Self::ConstantComposite { result_id, .. }
            | Self::ConstantSampler { result_id, .. }
            | Self::ConstantNull { result_id, .. }
            | Self::SpecConstantTrue { result_id, .. }
            | Self::SpecConstantFalse { result_id, .. }
            | Self::SpecConstant { result_id, .. }
            | Self::SpecConstantComposite { result_id, .. }
            | Self::SpecConstantOp { result_id, .. }
            | Self::Function { result_id, .. }
            | Self::FunctionParameter { result_id, .. }
            | Self::FunctionCall { result_id, .. }
            | Self::Variable { result_id, .. }
            | Self::ImageTexelPointer { result_id, .. }
            | Self::Load { result_id, .. }
            | Self::AccessChain { result_id, .. }
            | Self::InBoundsAccessChain { result_id, .. }
            | Self::PtrAccessChain { result_id, .. }
            | Self::ArrayLength { result_id, .. }
            | Self::GenericPtrMemSemantics { result_id, .. }
            | Self::InBoundsPtrAccessChain { result_id, .. }
            | Self::DecorationGroup { result_id, .. }
            | Self::VectorExtractDynamic { result_id, .. }
            | Self::VectorInsertDynamic { result_id, .. }
            | Self::VectorShuffle { result_id, .. }
            | Self::CompositeConstruct { result_id, .. }
            | Self::CompositeExtract { result_id, .. }
            | Self::CompositeInsert { result_id, .. }
            | Self::CopyObject { result_id, .. }
            | Self::Transpose { result_id, .. }
            | Self::SampledImage { result_id, .. }
            | Self::ImageSampleImplicitLod { result_id, .. }
            | Self::ImageSampleExplicitLod { result_id, .. }
            | Self::ImageSampleDrefImplicitLod { result_id, .. }
            | Self::ImageSampleDrefExplicitLod { result_id, .. }
            | Self::ImageSampleProjImplicitLod { result_id, .. }
            | Self::ImageSampleProjExplicitLod { result_id, .. }
            | Self::ImageSampleProjDrefImplicitLod { result_id, .. }
            | Self::ImageSampleProjDrefExplicitLod { result_id, .. }
            | Self::ImageFetch { result_id, .. }
            | Self::ImageGather { result_id, .. }
            | Self::ImageDrefGather { result_id, .. }
            | Self::ImageRead { result_id, .. }
            | Self::Image { result_id, .. }
            | Self::ImageQueryFormat { result_id, .. }
            | Self::ImageQueryOrder { result_id, .. }
            | Self::ImageQuerySizeLod { result_id, .. }
            | Self::ImageQuerySize { result_id, .. }
            | Self::ImageQueryLod { result_id, .. }
            | Self::ImageQueryLevels { result_id, .. }
            | Self::ImageQuerySamples { result_id, .. }
            | Self::ConvertFToU { result_id, .. }
            | Self::ConvertFToS { result_id, .. }
            | Self::ConvertSToF { result_id, .. }
            | Self::ConvertUToF { result_id, .. }
            | Self::UConvert { result_id, .. }
            | Self::SConvert { result_id, .. }
            | Self::FConvert { result_id, .. }
            | Self::QuantizeToF16 { result_id, .. }
            | Self::ConvertPtrToU { result_id, .. }
            | Self::SatConvertSToU { result_id, .. }
            | Self::SatConvertUToS { result_id, .. }
            | Self::ConvertUToPtr { result_id, .. }
            | Self::PtrCastToGeneric { result_id, .. }
            | Self::GenericCastToPtr { result_id, .. }
            | Self::GenericCastToPtrExplicit { result_id, .. }
            | Self::Bitcast { result_id, .. }
            | Self::SNegate { result_id, .. }
            | Self::FNegate { result_id, .. }
            | Self::IAdd { result_id, .. }
            | Self::FAdd { result_id, .. }
            | Self::ISub { result_id, .. }
            | Self::FSub { result_id, .. }
            | Self::IMul { result_id, .. }
            | Self::FMul { result_id, .. }
            | Self::UDiv { result_id, .. }
            | Self::SDiv { result_id, .. }
            | Self::FDiv { result_id, .. }
            | Self::UMod { result_id, .. }
            | Self::SRem { result_id, .. }
            | Self::SMod { result_id, .. }
            | Self::FRem { result_id, .. }
            | Self::FMod { result_id, .. }
            | Self::VectorTimesScalar { result_id, .. }
            | Self::MatrixTimesScalar { result_id, .. }
            | Self::VectorTimesMatrix { result_id, .. }
            | Self::MatrixTimesVector { result_id, .. }
            | Self::MatrixTimesMatrix { result_id, .. }
            | Self::OuterProduct { result_id, .. }
            | Self::Dot { result_id, .. }
            | Self::IAddCarry { result_id, .. }
            | Self::ISubBorrow { result_id, .. }
            | Self::UMulExtended { result_id, .. }
            | Self::SMulExtended { result_id, .. }
            | Self::Any { result_id, .. }
            | Self::All { result_id, .. }
            | Self::IsNan { result_id, .. }
            | Self::IsInf { result_id, .. }
            | Self::IsFinite { result_id, .. }
            | Self::IsNormal { result_id, .. }
            | Self::SignBitSet { result_id, .. }
            | Self::LessOrGreater { result_id, .. }
            | Self::Ordered { result_id, .. }
            | Self::Unordered { result_id, .. }
            | Self::LogicalEqual { result_id, .. }
            | Self::LogicalNotEqual { result_id, .. }
            | Self::LogicalOr { result_id, .. }
            | Self::LogicalAnd { result_id, .. }
            | Self::LogicalNot { result_id, .. }
            | Self::Select { result_id, .. }
            | Self::IEqual { result_id, .. }
            | Self::INotEqual { result_id, .. }
            | Self::UGreaterThan { result_id, .. }
            | Self::SGreaterThan { result_id, .. }
            | Self::UGreaterThanEqual { result_id, .. }
            | Self::SGreaterThanEqual { result_id, .. }
            | Self::ULessThan { result_id, .. }
            | Self::SLessThan { result_id, .. }
            | Self::ULessThanEqual { result_id, .. }
            | Self::SLessThanEqual { result_id, .. }
            | Self::FOrdEqual { result_id, .. }
            | Self::FUnordEqual { result_id, .. }
            | Self::FOrdNotEqual { result_id, .. }
            | Self::FUnordNotEqual { result_id, .. }
            | Self::FOrdLessThan { result_id, .. }
            | Self::FUnordLessThan { result_id, .. }
            | Self::FOrdGreaterThan { result_id, .. }
            | Self::FUnordGreaterThan { result_id, .. }
            | Self::FOrdLessThanEqual { result_id, .. }
            | Self::FUnordLessThanEqual { result_id, .. }
            | Self::FOrdGreaterThanEqual { result_id, .. }
            | Self::FUnordGreaterThanEqual { result_id, .. }
            | Self::ShiftRightLogical { result_id, .. }
            | Self::ShiftRightArithmetic { result_id, .. }
            | Self::ShiftLeftLogical { result_id, .. }
            | Self::BitwiseOr { result_id, .. }
            | Self::BitwiseXor { result_id, .. }
            | Self::BitwiseAnd { result_id, .. }
            | Self::Not { result_id, .. }
            | Self::BitFieldInsert { result_id, .. }
            | Self::BitFieldSExtract { result_id, .. }
            | Self::BitFieldUExtract { result_id, .. }
            | Self::BitReverse { result_id, .. }
            | Self::BitCount { result_id, .. }
            | Self::DPdx { result_id, .. }
            | Self::DPdy { result_id, .. }
            | Self::Fwidth { result_id, .. }
            | Self::DPdxFine { result_id, .. }
            | Self::DPdyFine { result_id, .. }
            | Self::FwidthFine { result_id, .. }
            | Self::DPdxCoarse { result_id, .. }
            | Self::DPdyCoarse { result_id, .. }
            | Self::FwidthCoarse { result_id, .. }
            | Self::AtomicLoad { result_id, .. }
            | Self::AtomicExchange { result_id, .. }
            | Self::AtomicCompareExchange { result_id, .. }
            | Self::AtomicCompareExchangeWeak { result_id, .. }
            | Self::AtomicIIncrement { result_id, .. }
            | Self::AtomicIDecrement { result_id, .. }
            | Self::AtomicIAdd { result_id, .. }
            | Self::AtomicISub { result_id, .. }
            | Self::AtomicSMin { result_id, .. }
            | Self::AtomicUMin { result_id, .. }
            | Self::AtomicSMax { result_id, .. }
            | Self::AtomicUMax { result_id, .. }
            | Self::AtomicAnd { result_id, .. }
            | Self::AtomicOr { result_id, .. }
            | Self::AtomicXor { result_id, .. }
            | Self::Phi { result_id, .. }
            | Self::Label { result_id, .. }
            | Self::GroupAsyncCopy { result_id, .. }
            | Self::GroupAll { result_id, .. }
            | Self::GroupAny { result_id, .. }
            | Self::GroupBroadcast { result_id, .. }
            | Self::GroupIAdd { result_id, .. }
            | Self::GroupFAdd { result_id, .. }
            | Self::GroupFMin { result_id, .. }
            | Self::GroupUMin { result_id, .. }
            | Self::GroupSMin { result_id, .. }
            | Self::GroupFMax { result_id, .. }
            | Self::GroupUMax { result_id, .. }
            | Self::GroupSMax { result_id, .. }
            | Self::ReadPipe { result_id, .. }
            | Self::WritePipe { result_id, .. }
            | Self::ReservedReadPipe { result_id, .. }
            | Self::ReservedWritePipe { result_id, .. }
            | Self::ReserveReadPipePackets { result_id, .. }
            | Self::ReserveWritePipePackets { result_id, .. }
            | Self::IsValidReserveId { result_id, .. }
            | Self::GetNumPipePackets { result_id, .. }
            | Self::GetMaxPipePackets { result_id, .. }
            | Self::GroupReserveReadPipePackets { result_id, .. }
            | Self::GroupReserveWritePipePackets { result_id, .. }
            | Self::EnqueueMarker { result_id, .. }
            | Self::EnqueueKernel { result_id, .. }
            | Self::GetKernelNDrangeSubGroupCount { result_id, .. }
            | Self::GetKernelNDrangeMaxSubGroupSize { result_id, .. }
            | Self::GetKernelWorkGroupSize { result_id, .. }
            | Self::GetKernelPreferredWorkGroupSizeMultiple { result_id, .. }
            | Self::CreateUserEvent { result_id, .. }
            | Self::IsValidEvent { result_id, .. }
            | Self::GetDefaultQueue { result_id, .. }
            | Self::BuildNDRange { result_id, .. }
            | Self::ImageSparseSampleImplicitLod { result_id, .. }
            | Self::ImageSparseSampleExplicitLod { result_id, .. }
            | Self::ImageSparseSampleDrefImplicitLod { result_id, .. }
            | Self::ImageSparseSampleDrefExplicitLod { result_id, .. }
            | Self::ImageSparseSampleProjImplicitLod { result_id, .. }
            | Self::ImageSparseSampleProjExplicitLod { result_id, .. }
            | Self::ImageSparseSampleProjDrefImplicitLod { result_id, .. }
            | Self::ImageSparseSampleProjDrefExplicitLod { result_id, .. }
            | Self::ImageSparseFetch { result_id, .. }
            | Self::ImageSparseGather { result_id, .. }
            | Self::ImageSparseDrefGather { result_id, .. }
            | Self::ImageSparseTexelsResident { result_id, .. }
            | Self::AtomicFlagTestAndSet { result_id, .. }
            | Self::ImageSparseRead { result_id, .. }
            | Self::SizeOf { result_id, .. }
            | Self::TypePipeStorage { result_id, .. }
            | Self::ConstantPipeStorage { result_id, .. }
            | Self::CreatePipeFromPipeStorage { result_id, .. }
            | Self::GetKernelLocalSizeForSubgroupCount { result_id, .. }
            | Self::GetKernelMaxNumSubgroups { result_id, .. }
            | Self::TypeNamedBarrier { result_id, .. }
            | Self::NamedBarrierInitialize { result_id, .. }
            | Self::GroupNonUniformElect { result_id, .. }
            | Self::GroupNonUniformAll { result_id, .. }
            | Self::GroupNonUniformAny { result_id, .. }
            | Self::GroupNonUniformAllEqual { result_id, .. }
            | Self::GroupNonUniformBroadcast { result_id, .. }
            | Self::GroupNonUniformBroadcastFirst { result_id, .. }
            | Self::GroupNonUniformBallot { result_id, .. }
            | Self::GroupNonUniformInverseBallot { result_id, .. }
            | Self::GroupNonUniformBallotBitExtract { result_id, .. }
            | Self::GroupNonUniformBallotBitCount { result_id, .. }
            | Self::GroupNonUniformBallotFindLSB { result_id, .. }
            | Self::GroupNonUniformBallotFindMSB { result_id, .. }
            | Self::GroupNonUniformShuffle { result_id, .. }
            | Self::GroupNonUniformShuffleXor { result_id, .. }
            | Self::GroupNonUniformShuffleUp { result_id, .. }
            | Self::GroupNonUniformShuffleDown { result_id, .. }
            | Self::GroupNonUniformIAdd { result_id, .. }
            | Self::GroupNonUniformFAdd { result_id, .. }
            | Self::GroupNonUniformIMul { result_id, .. }
            | Self::GroupNonUniformFMul { result_id, .. }
            | Self::GroupNonUniformSMin { result_id, .. }
            | Self::GroupNonUniformUMin { result_id, .. }
            | Self::GroupNonUniformFMin { result_id, .. }
            | Self::GroupNonUniformSMax { result_id, .. }
            | Self::GroupNonUniformUMax { result_id, .. }
            | Self::GroupNonUniformFMax { result_id, .. }
            | Self::GroupNonUniformBitwiseAnd { result_id, .. }
            | Self::GroupNonUniformBitwiseOr { result_id, .. }
            | Self::GroupNonUniformBitwiseXor { result_id, .. }
            | Self::GroupNonUniformLogicalAnd { result_id, .. }
            | Self::GroupNonUniformLogicalOr { result_id, .. }
            | Self::GroupNonUniformLogicalXor { result_id, .. }
            | Self::GroupNonUniformQuadBroadcast { result_id, .. }
            | Self::GroupNonUniformQuadSwap { result_id, .. }
            | Self::CopyLogical { result_id, .. }
            | Self::PtrEqual { result_id, .. }
            | Self::PtrNotEqual { result_id, .. }
            | Self::PtrDiff { result_id, .. }
            | Self::SubgroupBallotKHR { result_id, .. }
            | Self::SubgroupFirstInvocationKHR { result_id, .. }
            | Self::SubgroupAllKHR { result_id, .. }
            | Self::SubgroupAnyKHR { result_id, .. }
            | Self::SubgroupAllEqualKHR { result_id, .. }
            | Self::SubgroupReadInvocationKHR { result_id, .. }
            | Self::ConvertUToAccelerationStructureKHR { result_id, .. }
            | Self::SDotKHR { result_id, .. }
            | Self::UDotKHR { result_id, .. }
            | Self::SUDotKHR { result_id, .. }
            | Self::SDotAccSatKHR { result_id, .. }
            | Self::UDotAccSatKHR { result_id, .. }
            | Self::SUDotAccSatKHR { result_id, .. }
            | Self::TypeRayQueryKHR { result_id, .. }
            | Self::RayQueryProceedKHR { result_id, .. }
            | Self::RayQueryGetIntersectionTypeKHR { result_id, .. }
            | Self::GroupIAddNonUniformAMD { result_id, .. }
            | Self::GroupFAddNonUniformAMD { result_id, .. }
            | Self::GroupFMinNonUniformAMD { result_id, .. }
            | Self::GroupUMinNonUniformAMD { result_id, .. }
            | Self::GroupSMinNonUniformAMD { result_id, .. }
            | Self::GroupFMaxNonUniformAMD { result_id, .. }
            | Self::GroupUMaxNonUniformAMD { result_id, .. }
            | Self::GroupSMaxNonUniformAMD { result_id, .. }
            | Self::FragmentMaskFetchAMD { result_id, .. }
            | Self::FragmentFetchAMD { result_id, .. }
            | Self::ReadClockKHR { result_id, .. }
            | Self::ImageSampleFootprintNV { result_id, .. }
            | Self::GroupNonUniformPartitionNV { result_id, .. }
            | Self::ReportIntersectionKHR { result_id, .. }
            | Self::TypeAccelerationStructureKHR { result_id, .. }
            | Self::TypeCooperativeMatrixNV { result_id, .. }
            | Self::CooperativeMatrixLoadNV { result_id, .. }
            | Self::CooperativeMatrixMulAddNV { result_id, .. }
            | Self::CooperativeMatrixLengthNV { result_id, .. }
            | Self::IsHelperInvocationEXT { result_id, .. }
            | Self::ConvertUToImageNV { result_id, .. }
            | Self::ConvertUToSamplerNV { result_id, .. }
            | Self::ConvertImageToUNV { result_id, .. }
            | Self::ConvertSamplerToUNV { result_id, .. }
            | Self::ConvertUToSampledImageNV { result_id, .. }
            | Self::ConvertSampledImageToUNV { result_id, .. }
            | Self::SubgroupShuffleINTEL { result_id, .. }
            | Self::SubgroupShuffleDownINTEL { result_id, .. }
            | Self::SubgroupShuffleUpINTEL { result_id, .. }
            | Self::SubgroupShuffleXorINTEL { result_id, .. }
            | Self::SubgroupBlockReadINTEL { result_id, .. }
            | Self::SubgroupImageBlockReadINTEL { result_id, .. }
            | Self::SubgroupImageMediaBlockReadINTEL { result_id, .. }
            | Self::UCountLeadingZerosINTEL { result_id, .. }
            | Self::UCountTrailingZerosINTEL { result_id, .. }
            | Self::AbsISubINTEL { result_id, .. }
            | Self::AbsUSubINTEL { result_id, .. }
            | Self::IAddSatINTEL { result_id, .. }
            | Self::UAddSatINTEL { result_id, .. }
            | Self::IAverageINTEL { result_id, .. }
            | Self::UAverageINTEL { result_id, .. }
            | Self::IAverageRoundedINTEL { result_id, .. }
            | Self::UAverageRoundedINTEL { result_id, .. }
            | Self::ISubSatINTEL { result_id, .. }
            | Self::USubSatINTEL { result_id, .. }
            | Self::IMul32x16INTEL { result_id, .. }
            | Self::UMul32x16INTEL { result_id, .. }
            | Self::ConstFunctionPointerINTEL { result_id, .. }
            | Self::FunctionPointerCallINTEL { result_id, .. }
            | Self::AsmTargetINTEL { result_id, .. }
            | Self::AsmINTEL { result_id, .. }
            | Self::AsmCallINTEL { result_id, .. }
            | Self::AtomicFMinEXT { result_id, .. }
            | Self::AtomicFMaxEXT { result_id, .. }
            | Self::ExpectKHR { result_id, .. }
            | Self::VmeImageINTEL { result_id, .. }
            | Self::TypeVmeImageINTEL { result_id, .. }
            | Self::TypeAvcImePayloadINTEL { result_id, .. }
            | Self::TypeAvcRefPayloadINTEL { result_id, .. }
            | Self::TypeAvcSicPayloadINTEL { result_id, .. }
            | Self::TypeAvcMcePayloadINTEL { result_id, .. }
            | Self::TypeAvcMceResultINTEL { result_id, .. }
            | Self::TypeAvcImeResultINTEL { result_id, .. }
            | Self::TypeAvcImeResultSingleReferenceStreamoutINTEL { result_id, .. }
            | Self::TypeAvcImeResultDualReferenceStreamoutINTEL { result_id, .. }
            | Self::TypeAvcImeSingleReferenceStreaminINTEL { result_id, .. }
            | Self::TypeAvcImeDualReferenceStreaminINTEL { result_id, .. }
            | Self::TypeAvcRefResultINTEL { result_id, .. }
            | Self::TypeAvcSicResultINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultInterBaseMultiReferencePenaltyINTEL {
                result_id, ..
            }
            | Self::SubgroupAvcMceSetInterBaseMultiReferencePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultInterShapePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetInterShapePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultInterDirectionPenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetInterDirectionPenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultIntraLumaShapePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultInterMotionVectorCostTableINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultHighPenaltyCostTableINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultMediumPenaltyCostTableINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultLowPenaltyCostTableINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetMotionVectorCostFunctionINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultIntraLumaModePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultNonDcLumaIntraPenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetDefaultIntraChromaModeBasePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetAcOnlyHaarINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetSourceInterlacedFieldPolarityINTEL { result_id, .. }
            | Self::SubgroupAvcMceSetSingleReferenceInterlacedFieldPolarityINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcMceSetDualReferenceInterlacedFieldPolaritiesINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcMceConvertToImePayloadINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToImeResultINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToRefPayloadINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToRefResultINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToSicPayloadINTEL { result_id, .. }
            | Self::SubgroupAvcMceConvertToSicResultINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetMotionVectorsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterDistortionsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetBestInterDistortionsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterMajorShapeINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterMinorShapeINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterDirectionsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterMotionVectorCountINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterReferenceIdsINTEL { result_id, .. }
            | Self::SubgroupAvcMceGetInterReferenceInterlacedFieldPolaritiesINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeInitializeINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetSingleReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetDualReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcImeRefWindowSizeINTEL { result_id, .. }
            | Self::SubgroupAvcImeAdjustRefOffsetINTEL { result_id, .. }
            | Self::SubgroupAvcImeConvertToMcePayloadINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetMaxMotionVectorCountINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetUnidirectionalMixDisableINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetEarlySearchTerminationThresholdINTEL { result_id, .. }
            | Self::SubgroupAvcImeSetWeightedSadINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceStreamoutINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceStreamoutINTEL { result_id, .. }
            | Self::SubgroupAvcImeEvaluateWithSingleReferenceStreaminoutINTEL {
                result_id, ..
            }
            | Self::SubgroupAvcImeEvaluateWithDualReferenceStreaminoutINTEL { result_id, .. }
            | Self::SubgroupAvcImeConvertToMceResultINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetSingleReferenceStreaminINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetDualReferenceStreaminINTEL { result_id, .. }
            | Self::SubgroupAvcImeStripSingleReferenceStreamoutINTEL { result_id, .. }
            | Self::SubgroupAvcImeStripDualReferenceStreamoutINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeMotionVectorsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeDistortionsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutSingleReferenceMajorShapeReferenceIdsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeMotionVectorsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeDistortionsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetStreamoutDualReferenceMajorShapeReferenceIdsINTEL {
                result_id,
                ..
            }
            | Self::SubgroupAvcImeGetBorderReachedINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetTruncatedSearchIndicationINTEL { result_id, .. }
            | Self::SubgroupAvcImeGetUnidirectionalEarlySearchTerminationINTEL {
                result_id, ..
            }
            | Self::SubgroupAvcImeGetWeightingPatternMinimumMotionVectorINTEL {
                result_id, ..
            }
            | Self::SubgroupAvcImeGetWeightingPatternMinimumDistortionINTEL { result_id, .. }
            | Self::SubgroupAvcFmeInitializeINTEL { result_id, .. }
            | Self::SubgroupAvcBmeInitializeINTEL { result_id, .. }
            | Self::SubgroupAvcRefConvertToMcePayloadINTEL { result_id, .. }
            | Self::SubgroupAvcRefSetBidirectionalMixDisableINTEL { result_id, .. }
            | Self::SubgroupAvcRefSetBilinearFilterEnableINTEL { result_id, .. }
            | Self::SubgroupAvcRefEvaluateWithSingleReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcRefEvaluateWithDualReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcRefEvaluateWithMultiReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcRefEvaluateWithMultiReferenceInterlacedINTEL { result_id, .. }
            | Self::SubgroupAvcRefConvertToMceResultINTEL { result_id, .. }
            | Self::SubgroupAvcSicInitializeINTEL { result_id, .. }
            | Self::SubgroupAvcSicConfigureSkcINTEL { result_id, .. }
            | Self::SubgroupAvcSicConfigureIpeLumaINTEL { result_id, .. }
            | Self::SubgroupAvcSicConfigureIpeLumaChromaINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetMotionVectorMaskINTEL { result_id, .. }
            | Self::SubgroupAvcSicConvertToMcePayloadINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetIntraLumaShapePenaltyINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetIntraLumaModeCostFunctionINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetIntraChromaModeCostFunctionINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetBilinearFilterEnableINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetSkcForwardTransformEnableINTEL { result_id, .. }
            | Self::SubgroupAvcSicSetBlockBasedRawSkipSadINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateIpeINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateWithSingleReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateWithDualReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateWithMultiReferenceINTEL { result_id, .. }
            | Self::SubgroupAvcSicEvaluateWithMultiReferenceInterlacedINTEL { result_id, .. }
            | Self::SubgroupAvcSicConvertToMceResultINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetIpeLumaShapeINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetBestIpeLumaDistortionINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetBestIpeChromaDistortionINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetPackedIpeLumaModesINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetIpeChromaModeINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetPackedSkcLumaCountThresholdINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetPackedSkcLumaSumThresholdINTEL { result_id, .. }
            | Self::SubgroupAvcSicGetInterRawSadsINTEL { result_id, .. }
            | Self::VariableLengthArrayINTEL { result_id, .. }
            | Self::SaveMemoryINTEL { result_id, .. }
            | Self::ArbitraryFloatSinCosPiINTEL { result_id, .. }
            | Self::ArbitraryFloatCastINTEL { result_id, .. }
            | Self::ArbitraryFloatCastFromIntINTEL { result_id, .. }
            | Self::ArbitraryFloatCastToIntINTEL { result_id, .. }
            | Self::ArbitraryFloatAddINTEL { result_id, .. }
            | Self::ArbitraryFloatSubINTEL { result_id, .. }
            | Self::ArbitraryFloatMulINTEL { result_id, .. }
            | Self::ArbitraryFloatDivINTEL { result_id, .. }
            | Self::ArbitraryFloatGTINTEL { result_id, .. }
            | Self::ArbitraryFloatGEINTEL { result_id, .. }
            | Self::ArbitraryFloatLTINTEL { result_id, .. }
            | Self::ArbitraryFloatLEINTEL { result_id, .. }
            | Self::ArbitraryFloatEQINTEL { result_id, .. }
            | Self::ArbitraryFloatRecipINTEL { result_id, .. }
            | Self::ArbitraryFloatRSqrtINTEL { result_id, .. }
            | Self::ArbitraryFloatCbrtINTEL { result_id, .. }
            | Self::ArbitraryFloatHypotINTEL { result_id, .. }
            | Self::ArbitraryFloatSqrtINTEL { result_id, .. }
            | Self::ArbitraryFloatLogINTEL { result_id, .. }
            | Self::ArbitraryFloatLog2INTEL { result_id, .. }
            | Self::ArbitraryFloatLog10INTEL { result_id, .. }
            | Self::ArbitraryFloatLog1pINTEL { result_id, .. }
            | Self::ArbitraryFloatExpINTEL { result_id, .. }
            | Self::ArbitraryFloatExp2INTEL { result_id, .. }
            | Self::ArbitraryFloatExp10INTEL { result_id, .. }
            | Self::ArbitraryFloatExpm1INTEL { result_id, .. }
            | Self::ArbitraryFloatSinINTEL { result_id, .. }
            | Self::ArbitraryFloatCosINTEL { result_id, .. }
            | Self::ArbitraryFloatSinCosINTEL { result_id, .. }
            | Self::ArbitraryFloatSinPiINTEL { result_id, .. }
            | Self::ArbitraryFloatCosPiINTEL { result_id, .. }
            | Self::ArbitraryFloatASinINTEL { result_id, .. }
            | Self::ArbitraryFloatASinPiINTEL { result_id, .. }
            | Self::ArbitraryFloatACosINTEL { result_id, .. }
            | Self::ArbitraryFloatACosPiINTEL { result_id, .. }
            | Self::ArbitraryFloatATanINTEL { result_id, .. }
            | Self::ArbitraryFloatATanPiINTEL { result_id, .. }
            | Self::ArbitraryFloatATan2INTEL { result_id, .. }
            | Self::ArbitraryFloatPowINTEL { result_id, .. }
            | Self::ArbitraryFloatPowRINTEL { result_id, .. }
            | Self::ArbitraryFloatPowNINTEL { result_id, .. }
            | Self::FixedSqrtINTEL { result_id, .. }
            | Self::FixedRecipINTEL { result_id, .. }
            | Self::FixedRsqrtINTEL { result_id, .. }
            | Self::FixedSinINTEL { result_id, .. }
            | Self::FixedCosINTEL { result_id, .. }
            | Self::FixedSinCosINTEL { result_id, .. }
            | Self::FixedSinPiINTEL { result_id, .. }
            | Self::FixedCosPiINTEL { result_id, .. }
            | Self::FixedSinCosPiINTEL { result_id, .. }
            | Self::FixedLogINTEL { result_id, .. }
            | Self::FixedExpINTEL { result_id, .. }
            | Self::PtrCastToCrossWorkgroupINTEL { result_id, .. }
            | Self::CrossWorkgroupCastToPtrINTEL { result_id, .. }
            | Self::ReadPipeBlockingINTEL { result_id, .. }
            | Self::WritePipeBlockingINTEL { result_id, .. }
            | Self::FPGARegINTEL { result_id, .. }
            | Self::RayQueryGetRayTMinKHR { result_id, .. }
            | Self::RayQueryGetRayFlagsKHR { result_id, .. }
            | Self::RayQueryGetIntersectionTKHR { result_id, .. }
            | Self::RayQueryGetIntersectionInstanceCustomIndexKHR { result_id, .. }
            | Self::RayQueryGetIntersectionInstanceIdKHR { result_id, .. }
            | Self::RayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR {
                result_id,
                ..
            }
            | Self::RayQueryGetIntersectionGeometryIndexKHR { result_id, .. }
            | Self::RayQueryGetIntersectionPrimitiveIndexKHR { result_id, .. }
            | Self::RayQueryGetIntersectionBarycentricsKHR { result_id, .. }
            | Self::RayQueryGetIntersectionFrontFaceKHR { result_id, .. }
            | Self::RayQueryGetIntersectionCandidateAABBOpaqueKHR { result_id, .. }
            | Self::RayQueryGetIntersectionObjectRayDirectionKHR { result_id, .. }
            | Self::RayQueryGetIntersectionObjectRayOriginKHR { result_id, .. }
            | Self::RayQueryGetWorldRayDirectionKHR { result_id, .. }
            | Self::RayQueryGetWorldRayOriginKHR { result_id, .. }
            | Self::RayQueryGetIntersectionObjectToWorldKHR { result_id, .. }
            | Self::RayQueryGetIntersectionWorldToObjectKHR { result_id, .. }
            | Self::AtomicFAddEXT { result_id, .. }
            | Self::TypeBufferSurfaceINTEL { result_id, .. } => Some(*result_id),
            _ => None,
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[doc = "An instruction that is used as the operand of the `SpecConstantOp` instruction."]
pub enum SpecConstantInstruction {
    AccessChain {
        base: Id,
        indexes: Vec<Id>,
    },
    InBoundsAccessChain {
        base: Id,
        indexes: Vec<Id>,
    },
    PtrAccessChain {
        base: Id,
        element: Id,
        indexes: Vec<Id>,
    },
    InBoundsPtrAccessChain {
        base: Id,
        element: Id,
        indexes: Vec<Id>,
    },
    VectorShuffle {
        vector_1: Id,
        vector_2: Id,
        components: Vec<u32>,
    },
    CompositeExtract {
        composite: Id,
        indexes: Vec<u32>,
    },
    CompositeInsert {
        object: Id,
        composite: Id,
        indexes: Vec<u32>,
    },
    ConvertFToU {
        float_value: Id,
    },
    ConvertFToS {
        float_value: Id,
    },
    ConvertSToF {
        signed_value: Id,
    },
    ConvertUToF {
        unsigned_value: Id,
    },
    UConvert {
        unsigned_value: Id,
    },
    SConvert {
        signed_value: Id,
    },
    FConvert {
        float_value: Id,
    },
    QuantizeToF16 {
        value: Id,
    },
    ConvertPtrToU {
        pointer: Id,
    },
    ConvertUToPtr {
        integer_value: Id,
    },
    PtrCastToGeneric {
        pointer: Id,
    },
    GenericCastToPtr {
        pointer: Id,
    },
    Bitcast {
        operand: Id,
    },
    SNegate {
        operand: Id,
    },
    FNegate {
        operand: Id,
    },
    IAdd {
        operand1: Id,
        operand2: Id,
    },
    FAdd {
        operand1: Id,
        operand2: Id,
    },
    ISub {
        operand1: Id,
        operand2: Id,
    },
    FSub {
        operand1: Id,
        operand2: Id,
    },
    IMul {
        operand1: Id,
        operand2: Id,
    },
    FMul {
        operand1: Id,
        operand2: Id,
    },
    UDiv {
        operand1: Id,
        operand2: Id,
    },
    SDiv {
        operand1: Id,
        operand2: Id,
    },
    FDiv {
        operand1: Id,
        operand2: Id,
    },
    UMod {
        operand1: Id,
        operand2: Id,
    },
    SRem {
        operand1: Id,
        operand2: Id,
    },
    SMod {
        operand1: Id,
        operand2: Id,
    },
    FRem {
        operand1: Id,
        operand2: Id,
    },
    FMod {
        operand1: Id,
        operand2: Id,
    },
    LogicalEqual {
        operand1: Id,
        operand2: Id,
    },
    LogicalNotEqual {
        operand1: Id,
        operand2: Id,
    },
    LogicalOr {
        operand1: Id,
        operand2: Id,
    },
    LogicalAnd {
        operand1: Id,
        operand2: Id,
    },
    LogicalNot {
        operand: Id,
    },
    Select {
        condition: Id,
        object_1: Id,
        object_2: Id,
    },
    IEqual {
        operand1: Id,
        operand2: Id,
    },
    INotEqual {
        operand1: Id,
        operand2: Id,
    },
    UGreaterThan {
        operand1: Id,
        operand2: Id,
    },
    SGreaterThan {
        operand1: Id,
        operand2: Id,
    },
    UGreaterThanEqual {
        operand1: Id,
        operand2: Id,
    },
    SGreaterThanEqual {
        operand1: Id,
        operand2: Id,
    },
    ULessThan {
        operand1: Id,
        operand2: Id,
    },
    SLessThan {
        operand1: Id,
        operand2: Id,
    },
    ULessThanEqual {
        operand1: Id,
        operand2: Id,
    },
    SLessThanEqual {
        operand1: Id,
        operand2: Id,
    },
    ShiftRightLogical {
        base: Id,
        shift: Id,
    },
    ShiftRightArithmetic {
        base: Id,
        shift: Id,
    },
    ShiftLeftLogical {
        base: Id,
        shift: Id,
    },
    BitwiseOr {
        operand1: Id,
        operand2: Id,
    },
    BitwiseXor {
        operand1: Id,
        operand2: Id,
    },
    BitwiseAnd {
        operand1: Id,
        operand2: Id,
    },
    Not {
        operand: Id,
    },
}
impl SpecConstantInstruction {
    fn parse(reader: &mut InstructionReader) -> Result<Self, ParseError> {
        let opcode = (reader.next_u32()? & 0xffff) as u16;
        Ok(match opcode {
            65u16 => Self::AccessChain {
                base: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            66u16 => Self::InBoundsAccessChain {
                base: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            67u16 => Self::PtrAccessChain {
                base: Id(reader.next_u32()?),
                element: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            70u16 => Self::InBoundsPtrAccessChain {
                base: Id(reader.next_u32()?),
                element: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(Id(reader.next_u32()?));
                    }
                    vec
                },
            },
            79u16 => Self::VectorShuffle {
                vector_1: Id(reader.next_u32()?),
                vector_2: Id(reader.next_u32()?),
                components: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(reader.next_u32()?);
                    }
                    vec
                },
            },
            81u16 => Self::CompositeExtract {
                composite: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(reader.next_u32()?);
                    }
                    vec
                },
            },
            82u16 => Self::CompositeInsert {
                object: Id(reader.next_u32()?),
                composite: Id(reader.next_u32()?),
                indexes: {
                    let mut vec = Vec::new();
                    while !reader.is_empty() {
                        vec.push(reader.next_u32()?);
                    }
                    vec
                },
            },
            109u16 => Self::ConvertFToU {
                float_value: Id(reader.next_u32()?),
            },
            110u16 => Self::ConvertFToS {
                float_value: Id(reader.next_u32()?),
            },
            111u16 => Self::ConvertSToF {
                signed_value: Id(reader.next_u32()?),
            },
            112u16 => Self::ConvertUToF {
                unsigned_value: Id(reader.next_u32()?),
            },
            113u16 => Self::UConvert {
                unsigned_value: Id(reader.next_u32()?),
            },
            114u16 => Self::SConvert {
                signed_value: Id(reader.next_u32()?),
            },
            115u16 => Self::FConvert {
                float_value: Id(reader.next_u32()?),
            },
            116u16 => Self::QuantizeToF16 {
                value: Id(reader.next_u32()?),
            },
            117u16 => Self::ConvertPtrToU {
                pointer: Id(reader.next_u32()?),
            },
            120u16 => Self::ConvertUToPtr {
                integer_value: Id(reader.next_u32()?),
            },
            121u16 => Self::PtrCastToGeneric {
                pointer: Id(reader.next_u32()?),
            },
            122u16 => Self::GenericCastToPtr {
                pointer: Id(reader.next_u32()?),
            },
            124u16 => Self::Bitcast {
                operand: Id(reader.next_u32()?),
            },
            126u16 => Self::SNegate {
                operand: Id(reader.next_u32()?),
            },
            127u16 => Self::FNegate {
                operand: Id(reader.next_u32()?),
            },
            128u16 => Self::IAdd {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            129u16 => Self::FAdd {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            130u16 => Self::ISub {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            131u16 => Self::FSub {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            132u16 => Self::IMul {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            133u16 => Self::FMul {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            134u16 => Self::UDiv {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            135u16 => Self::SDiv {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            136u16 => Self::FDiv {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            137u16 => Self::UMod {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            138u16 => Self::SRem {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            139u16 => Self::SMod {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            140u16 => Self::FRem {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            141u16 => Self::FMod {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            164u16 => Self::LogicalEqual {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            165u16 => Self::LogicalNotEqual {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            166u16 => Self::LogicalOr {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            167u16 => Self::LogicalAnd {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            168u16 => Self::LogicalNot {
                operand: Id(reader.next_u32()?),
            },
            169u16 => Self::Select {
                condition: Id(reader.next_u32()?),
                object_1: Id(reader.next_u32()?),
                object_2: Id(reader.next_u32()?),
            },
            170u16 => Self::IEqual {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            171u16 => Self::INotEqual {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            172u16 => Self::UGreaterThan {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            173u16 => Self::SGreaterThan {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            174u16 => Self::UGreaterThanEqual {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            175u16 => Self::SGreaterThanEqual {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            176u16 => Self::ULessThan {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            177u16 => Self::SLessThan {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            178u16 => Self::ULessThanEqual {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            179u16 => Self::SLessThanEqual {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            194u16 => Self::ShiftRightLogical {
                base: Id(reader.next_u32()?),
                shift: Id(reader.next_u32()?),
            },
            195u16 => Self::ShiftRightArithmetic {
                base: Id(reader.next_u32()?),
                shift: Id(reader.next_u32()?),
            },
            196u16 => Self::ShiftLeftLogical {
                base: Id(reader.next_u32()?),
                shift: Id(reader.next_u32()?),
            },
            197u16 => Self::BitwiseOr {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            198u16 => Self::BitwiseXor {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            199u16 => Self::BitwiseAnd {
                operand1: Id(reader.next_u32()?),
                operand2: Id(reader.next_u32()?),
            },
            200u16 => Self::Not {
                operand: Id(reader.next_u32()?),
            },
            opcode => return Err(reader.map_err(ParseErrors::UnknownSpecConstantOpcode(opcode))),
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct ImageOperands {
    pub bias: Option<Id>,
    pub lod: Option<Id>,
    pub grad: Option<(Id, Id)>,
    pub const_offset: Option<Id>,
    pub offset: Option<Id>,
    pub const_offsets: Option<Id>,
    pub sample: Option<Id>,
    pub min_lod: Option<Id>,
    pub make_texel_available: Option<Id>,
    pub make_texel_visible: Option<Id>,
    pub non_private_texel: bool,
    pub volatile_texel: bool,
    pub sign_extend: bool,
    pub zero_extend: bool,
    pub offsets: Option<Id>,
}
impl ImageOperands {
    fn parse(reader: &mut InstructionReader) -> Result<ImageOperands, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            bias: if value & 1u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            lod: if value & 2u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            grad: if value & 4u32 != 0 {
                Some((Id(reader.next_u32()?), Id(reader.next_u32()?)))
            } else {
                None
            },
            const_offset: if value & 8u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            offset: if value & 16u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            const_offsets: if value & 32u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            sample: if value & 64u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            min_lod: if value & 128u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            make_texel_available: if value & 256u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            make_texel_visible: if value & 512u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            non_private_texel: value & 1024u32 != 0,
            volatile_texel: value & 2048u32 != 0,
            sign_extend: value & 4096u32 != 0,
            zero_extend: value & 8192u32 != 0,
            offsets: if value & 65536u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct FPFastMathMode {
    pub not_nan: bool,
    pub not_inf: bool,
    pub nsz: bool,
    pub allow_recip: bool,
    pub fast: bool,
    pub allow_contract_fast_intel: bool,
    pub allow_reassoc_intel: bool,
}
impl FPFastMathMode {
    fn parse(reader: &mut InstructionReader) -> Result<FPFastMathMode, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            not_nan: value & 1u32 != 0,
            not_inf: value & 2u32 != 0,
            nsz: value & 4u32 != 0,
            allow_recip: value & 8u32 != 0,
            fast: value & 16u32 != 0,
            allow_contract_fast_intel: value & 65536u32 != 0,
            allow_reassoc_intel: value & 131072u32 != 0,
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct SelectionControl {
    pub flatten: bool,
    pub dont_flatten: bool,
}
impl SelectionControl {
    fn parse(reader: &mut InstructionReader) -> Result<SelectionControl, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            flatten: value & 1u32 != 0,
            dont_flatten: value & 2u32 != 0,
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct LoopControl {
    pub unroll: bool,
    pub dont_unroll: bool,
    pub dependency_infinite: bool,
    pub dependency_length: Option<u32>,
    pub min_iterations: Option<u32>,
    pub max_iterations: Option<u32>,
    pub iteration_multiple: Option<u32>,
    pub peel_count: Option<u32>,
    pub partial_count: Option<u32>,
    pub initiation_interval_intel: Option<u32>,
    pub max_concurrency_intel: Option<u32>,
    pub dependency_array_intel: Option<u32>,
    pub pipeline_enable_intel: Option<u32>,
    pub loop_coalesce_intel: Option<u32>,
    pub max_interleaving_intel: Option<u32>,
    pub speculated_iterations_intel: Option<u32>,
    pub no_fusion_intel: Option<u32>,
}
impl LoopControl {
    fn parse(reader: &mut InstructionReader) -> Result<LoopControl, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            unroll: value & 1u32 != 0,
            dont_unroll: value & 2u32 != 0,
            dependency_infinite: value & 4u32 != 0,
            dependency_length: if value & 8u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            min_iterations: if value & 16u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            max_iterations: if value & 32u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            iteration_multiple: if value & 64u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            peel_count: if value & 128u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            partial_count: if value & 256u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            initiation_interval_intel: if value & 65536u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            max_concurrency_intel: if value & 131072u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            dependency_array_intel: if value & 262144u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            pipeline_enable_intel: if value & 524288u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            loop_coalesce_intel: if value & 1048576u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            max_interleaving_intel: if value & 2097152u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            speculated_iterations_intel: if value & 4194304u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            no_fusion_intel: if value & 8388608u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct FunctionControl {
    pub inline: bool,
    pub dont_inline: bool,
    pub pure: bool,
    pub constant: bool,
    pub opt_none_intel: bool,
}
impl FunctionControl {
    fn parse(reader: &mut InstructionReader) -> Result<FunctionControl, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            inline: value & 1u32 != 0,
            dont_inline: value & 2u32 != 0,
            pure: value & 4u32 != 0,
            constant: value & 8u32 != 0,
            opt_none_intel: value & 65536u32 != 0,
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct MemorySemantics {
    pub acquire: bool,
    pub release: bool,
    pub acquire_release: bool,
    pub sequentially_consistent: bool,
    pub uniform_memory: bool,
    pub subgroup_memory: bool,
    pub workgroup_memory: bool,
    pub cross_workgroup_memory: bool,
    pub atomic_counter_memory: bool,
    pub image_memory: bool,
    pub output_memory: bool,
    pub make_available: bool,
    pub make_visible: bool,
    pub volatile: bool,
}
impl MemorySemantics {
    fn parse(reader: &mut InstructionReader) -> Result<MemorySemantics, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            acquire: value & 2u32 != 0,
            release: value & 4u32 != 0,
            acquire_release: value & 8u32 != 0,
            sequentially_consistent: value & 16u32 != 0,
            uniform_memory: value & 64u32 != 0,
            subgroup_memory: value & 128u32 != 0,
            workgroup_memory: value & 256u32 != 0,
            cross_workgroup_memory: value & 512u32 != 0,
            atomic_counter_memory: value & 1024u32 != 0,
            image_memory: value & 2048u32 != 0,
            output_memory: value & 4096u32 != 0,
            make_available: value & 8192u32 != 0,
            make_visible: value & 16384u32 != 0,
            volatile: value & 32768u32 != 0,
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct MemoryAccess {
    pub volatile: bool,
    pub aligned: Option<u32>,
    pub nontemporal: bool,
    pub make_pointer_available: Option<Id>,
    pub make_pointer_visible: Option<Id>,
    pub non_private_pointer: bool,
}
impl MemoryAccess {
    fn parse(reader: &mut InstructionReader) -> Result<MemoryAccess, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            volatile: value & 1u32 != 0,
            aligned: if value & 2u32 != 0 {
                Some(reader.next_u32()?)
            } else {
                None
            },
            nontemporal: value & 4u32 != 0,
            make_pointer_available: if value & 8u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            make_pointer_visible: if value & 16u32 != 0 {
                Some(Id(reader.next_u32()?))
            } else {
                None
            },
            non_private_pointer: value & 32u32 != 0,
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct KernelProfilingInfo {
    pub cmd_exec_time: bool,
}
impl KernelProfilingInfo {
    fn parse(reader: &mut InstructionReader) -> Result<KernelProfilingInfo, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            cmd_exec_time: value & 1u32 != 0,
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct RayFlags {
    pub opaque_khr: bool,
    pub no_opaque_khr: bool,
    pub terminate_on_first_hit_khr: bool,
    pub skip_closest_hit_shader_khr: bool,
    pub cull_back_facing_triangles_khr: bool,
    pub cull_front_facing_triangles_khr: bool,
    pub cull_opaque_khr: bool,
    pub cull_no_opaque_khr: bool,
    pub skip_triangles_khr: bool,
    pub skip_aab_bs_khr: bool,
}
impl RayFlags {
    fn parse(reader: &mut InstructionReader) -> Result<RayFlags, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            opaque_khr: value & 1u32 != 0,
            no_opaque_khr: value & 2u32 != 0,
            terminate_on_first_hit_khr: value & 4u32 != 0,
            skip_closest_hit_shader_khr: value & 8u32 != 0,
            cull_back_facing_triangles_khr: value & 16u32 != 0,
            cull_front_facing_triangles_khr: value & 32u32 != 0,
            cull_opaque_khr: value & 64u32 != 0,
            cull_no_opaque_khr: value & 128u32 != 0,
            skip_triangles_khr: value & 256u32 != 0,
            skip_aab_bs_khr: value & 512u32 != 0,
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub struct FragmentShadingRate {
    pub vertical2_pixels: bool,
    pub vertical4_pixels: bool,
    pub horizontal2_pixels: bool,
    pub horizontal4_pixels: bool,
}
impl FragmentShadingRate {
    fn parse(reader: &mut InstructionReader) -> Result<FragmentShadingRate, ParseError> {
        let value = reader.next_u32()?;
        Ok(Self {
            vertical2_pixels: value & 1u32 != 0,
            vertical4_pixels: value & 2u32 != 0,
            horizontal2_pixels: value & 4u32 != 0,
            horizontal4_pixels: value & 8u32 != 0,
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum SourceLanguage {
    Unknown,
    ESSL,
    GLSL,
    OpenCL_C,
    OpenCL_CPP,
    HLSL,
    CPP_for_OpenCL,
}
impl SourceLanguage {
    fn parse(reader: &mut InstructionReader) -> Result<SourceLanguage, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Unknown,
            1u32 => Self::ESSL,
            2u32 => Self::GLSL,
            3u32 => Self::OpenCL_C,
            4u32 => Self::OpenCL_CPP,
            5u32 => Self::HLSL,
            6u32 => Self::CPP_for_OpenCL,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("SourceLanguage", value)))
            }
        })
    }
}
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq)]
#[allow(non_camel_case_types)]
pub enum ExecutionModel {
    Vertex,
    TessellationControl,
    TessellationEvaluation,
    Geometry,
    Fragment,
    GLCompute,
    Kernel,
    TaskNV,
    MeshNV,
    RayGenerationKHR,
    IntersectionKHR,
    AnyHitKHR,
    ClosestHitKHR,
    MissKHR,
    CallableKHR,
}
impl ExecutionModel {
    fn parse(reader: &mut InstructionReader) -> Result<ExecutionModel, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Vertex,
            1u32 => Self::TessellationControl,
            2u32 => Self::TessellationEvaluation,
            3u32 => Self::Geometry,
            4u32 => Self::Fragment,
            5u32 => Self::GLCompute,
            6u32 => Self::Kernel,
            5267u32 => Self::TaskNV,
            5268u32 => Self::MeshNV,
            5313u32 => Self::RayGenerationKHR,
            5314u32 => Self::IntersectionKHR,
            5315u32 => Self::AnyHitKHR,
            5316u32 => Self::ClosestHitKHR,
            5317u32 => Self::MissKHR,
            5318u32 => Self::CallableKHR,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("ExecutionModel", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum AddressingModel {
    Logical,
    Physical32,
    Physical64,
    PhysicalStorageBuffer64,
}
impl AddressingModel {
    fn parse(reader: &mut InstructionReader) -> Result<AddressingModel, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Logical,
            1u32 => Self::Physical32,
            2u32 => Self::Physical64,
            5348u32 => Self::PhysicalStorageBuffer64,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("AddressingModel", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum MemoryModel {
    Simple,
    GLSL450,
    OpenCL,
    Vulkan,
}
impl MemoryModel {
    fn parse(reader: &mut InstructionReader) -> Result<MemoryModel, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Simple,
            1u32 => Self::GLSL450,
            2u32 => Self::OpenCL,
            3u32 => Self::Vulkan,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("MemoryModel", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum ExecutionMode {
    Invocations {
        number_of_invocation_invocations: u32,
    },
    SpacingEqual,
    SpacingFractionalEven,
    SpacingFractionalOdd,
    VertexOrderCw,
    VertexOrderCcw,
    PixelCenterInteger,
    OriginUpperLeft,
    OriginLowerLeft,
    EarlyFragmentTests,
    PointMode,
    Xfb,
    DepthReplacing,
    DepthGreater,
    DepthLess,
    DepthUnchanged,
    LocalSize {
        x_size: u32,
        y_size: u32,
        z_size: u32,
    },
    LocalSizeHint {
        x_size: u32,
        y_size: u32,
        z_size: u32,
    },
    InputPoints,
    InputLines,
    InputLinesAdjacency,
    Triangles,
    InputTrianglesAdjacency,
    Quads,
    Isolines,
    OutputVertices {
        vertex_count: u32,
    },
    OutputPoints,
    OutputLineStrip,
    OutputTriangleStrip,
    VecTypeHint {
        vector_type: u32,
    },
    ContractionOff,
    Initializer,
    Finalizer,
    SubgroupSize {
        subgroup_size: u32,
    },
    SubgroupsPerWorkgroup {
        subgroups_per_workgroup: u32,
    },
    SubgroupsPerWorkgroupId {
        subgroups_per_workgroup: Id,
    },
    LocalSizeId {
        x_size: Id,
        y_size: Id,
        z_size: Id,
    },
    LocalSizeHintId {
        x_size_hint: Id,
        y_size_hint: Id,
        z_size_hint: Id,
    },
    SubgroupUniformControlFlowKHR,
    PostDepthCoverage,
    DenormPreserve {
        target_width: u32,
    },
    DenormFlushToZero {
        target_width: u32,
    },
    SignedZeroInfNanPreserve {
        target_width: u32,
    },
    RoundingModeRTE {
        target_width: u32,
    },
    RoundingModeRTZ {
        target_width: u32,
    },
    StencilRefReplacingEXT,
    OutputLinesNV,
    OutputPrimitivesNV {
        primitive_count: u32,
    },
    DerivativeGroupQuadsNV,
    DerivativeGroupLinearNV,
    OutputTrianglesNV,
    PixelInterlockOrderedEXT,
    PixelInterlockUnorderedEXT,
    SampleInterlockOrderedEXT,
    SampleInterlockUnorderedEXT,
    ShadingRateInterlockOrderedEXT,
    ShadingRateInterlockUnorderedEXT,
    SharedLocalMemorySizeINTEL {
        size: u32,
    },
    RoundingModeRTPINTEL {
        target_width: u32,
    },
    RoundingModeRTNINTEL {
        target_width: u32,
    },
    FloatingPointModeALTINTEL {
        target_width: u32,
    },
    FloatingPointModeIEEEINTEL {
        target_width: u32,
    },
    MaxWorkgroupSizeINTEL {
        max_x_size: u32,
        max_y_size: u32,
        max_z_size: u32,
    },
    MaxWorkDimINTEL {
        max_dimensions: u32,
    },
    NoGlobalOffsetINTEL,
    NumSIMDWorkitemsINTEL {
        vector_width: u32,
    },
    SchedulerTargetFmaxMhzINTEL {
        target_fmax: u32,
    },
}
impl ExecutionMode {
    fn parse(reader: &mut InstructionReader) -> Result<ExecutionMode, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Invocations {
                number_of_invocation_invocations: reader.next_u32()?,
            },
            1u32 => Self::SpacingEqual,
            2u32 => Self::SpacingFractionalEven,
            3u32 => Self::SpacingFractionalOdd,
            4u32 => Self::VertexOrderCw,
            5u32 => Self::VertexOrderCcw,
            6u32 => Self::PixelCenterInteger,
            7u32 => Self::OriginUpperLeft,
            8u32 => Self::OriginLowerLeft,
            9u32 => Self::EarlyFragmentTests,
            10u32 => Self::PointMode,
            11u32 => Self::Xfb,
            12u32 => Self::DepthReplacing,
            14u32 => Self::DepthGreater,
            15u32 => Self::DepthLess,
            16u32 => Self::DepthUnchanged,
            17u32 => Self::LocalSize {
                x_size: reader.next_u32()?,
                y_size: reader.next_u32()?,
                z_size: reader.next_u32()?,
            },
            18u32 => Self::LocalSizeHint {
                x_size: reader.next_u32()?,
                y_size: reader.next_u32()?,
                z_size: reader.next_u32()?,
            },
            19u32 => Self::InputPoints,
            20u32 => Self::InputLines,
            21u32 => Self::InputLinesAdjacency,
            22u32 => Self::Triangles,
            23u32 => Self::InputTrianglesAdjacency,
            24u32 => Self::Quads,
            25u32 => Self::Isolines,
            26u32 => Self::OutputVertices {
                vertex_count: reader.next_u32()?,
            },
            27u32 => Self::OutputPoints,
            28u32 => Self::OutputLineStrip,
            29u32 => Self::OutputTriangleStrip,
            30u32 => Self::VecTypeHint {
                vector_type: reader.next_u32()?,
            },
            31u32 => Self::ContractionOff,
            33u32 => Self::Initializer,
            34u32 => Self::Finalizer,
            35u32 => Self::SubgroupSize {
                subgroup_size: reader.next_u32()?,
            },
            36u32 => Self::SubgroupsPerWorkgroup {
                subgroups_per_workgroup: reader.next_u32()?,
            },
            37u32 => Self::SubgroupsPerWorkgroupId {
                subgroups_per_workgroup: Id(reader.next_u32()?),
            },
            38u32 => Self::LocalSizeId {
                x_size: Id(reader.next_u32()?),
                y_size: Id(reader.next_u32()?),
                z_size: Id(reader.next_u32()?),
            },
            39u32 => Self::LocalSizeHintId {
                x_size_hint: Id(reader.next_u32()?),
                y_size_hint: Id(reader.next_u32()?),
                z_size_hint: Id(reader.next_u32()?),
            },
            4421u32 => Self::SubgroupUniformControlFlowKHR,
            4446u32 => Self::PostDepthCoverage,
            4459u32 => Self::DenormPreserve {
                target_width: reader.next_u32()?,
            },
            4460u32 => Self::DenormFlushToZero {
                target_width: reader.next_u32()?,
            },
            4461u32 => Self::SignedZeroInfNanPreserve {
                target_width: reader.next_u32()?,
            },
            4462u32 => Self::RoundingModeRTE {
                target_width: reader.next_u32()?,
            },
            4463u32 => Self::RoundingModeRTZ {
                target_width: reader.next_u32()?,
            },
            5027u32 => Self::StencilRefReplacingEXT,
            5269u32 => Self::OutputLinesNV,
            5270u32 => Self::OutputPrimitivesNV {
                primitive_count: reader.next_u32()?,
            },
            5289u32 => Self::DerivativeGroupQuadsNV,
            5290u32 => Self::DerivativeGroupLinearNV,
            5298u32 => Self::OutputTrianglesNV,
            5366u32 => Self::PixelInterlockOrderedEXT,
            5367u32 => Self::PixelInterlockUnorderedEXT,
            5368u32 => Self::SampleInterlockOrderedEXT,
            5369u32 => Self::SampleInterlockUnorderedEXT,
            5370u32 => Self::ShadingRateInterlockOrderedEXT,
            5371u32 => Self::ShadingRateInterlockUnorderedEXT,
            5618u32 => Self::SharedLocalMemorySizeINTEL {
                size: reader.next_u32()?,
            },
            5620u32 => Self::RoundingModeRTPINTEL {
                target_width: reader.next_u32()?,
            },
            5621u32 => Self::RoundingModeRTNINTEL {
                target_width: reader.next_u32()?,
            },
            5622u32 => Self::FloatingPointModeALTINTEL {
                target_width: reader.next_u32()?,
            },
            5623u32 => Self::FloatingPointModeIEEEINTEL {
                target_width: reader.next_u32()?,
            },
            5893u32 => Self::MaxWorkgroupSizeINTEL {
                max_x_size: reader.next_u32()?,
                max_y_size: reader.next_u32()?,
                max_z_size: reader.next_u32()?,
            },
            5894u32 => Self::MaxWorkDimINTEL {
                max_dimensions: reader.next_u32()?,
            },
            5895u32 => Self::NoGlobalOffsetINTEL,
            5896u32 => Self::NumSIMDWorkitemsINTEL {
                vector_width: reader.next_u32()?,
            },
            5903u32 => Self::SchedulerTargetFmaxMhzINTEL {
                target_fmax: reader.next_u32()?,
            },
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("ExecutionMode", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum StorageClass {
    UniformConstant,
    Input,
    Uniform,
    Output,
    Workgroup,
    CrossWorkgroup,
    Private,
    Function,
    Generic,
    PushConstant,
    AtomicCounter,
    Image,
    StorageBuffer,
    CallableDataKHR,
    IncomingCallableDataKHR,
    RayPayloadKHR,
    HitAttributeKHR,
    IncomingRayPayloadKHR,
    ShaderRecordBufferKHR,
    PhysicalStorageBuffer,
    CodeSectionINTEL,
    DeviceOnlyINTEL,
    HostOnlyINTEL,
}
impl StorageClass {
    fn parse(reader: &mut InstructionReader) -> Result<StorageClass, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::UniformConstant,
            1u32 => Self::Input,
            2u32 => Self::Uniform,
            3u32 => Self::Output,
            4u32 => Self::Workgroup,
            5u32 => Self::CrossWorkgroup,
            6u32 => Self::Private,
            7u32 => Self::Function,
            8u32 => Self::Generic,
            9u32 => Self::PushConstant,
            10u32 => Self::AtomicCounter,
            11u32 => Self::Image,
            12u32 => Self::StorageBuffer,
            5328u32 => Self::CallableDataKHR,
            5329u32 => Self::IncomingCallableDataKHR,
            5338u32 => Self::RayPayloadKHR,
            5339u32 => Self::HitAttributeKHR,
            5342u32 => Self::IncomingRayPayloadKHR,
            5343u32 => Self::ShaderRecordBufferKHR,
            5349u32 => Self::PhysicalStorageBuffer,
            5605u32 => Self::CodeSectionINTEL,
            5936u32 => Self::DeviceOnlyINTEL,
            5937u32 => Self::HostOnlyINTEL,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("StorageClass", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum Dim {
    Dim1D,
    Dim2D,
    Dim3D,
    Cube,
    Rect,
    Buffer,
    SubpassData,
}
impl Dim {
    fn parse(reader: &mut InstructionReader) -> Result<Dim, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Dim1D,
            1u32 => Self::Dim2D,
            2u32 => Self::Dim3D,
            3u32 => Self::Cube,
            4u32 => Self::Rect,
            5u32 => Self::Buffer,
            6u32 => Self::SubpassData,
            value => return Err(reader.map_err(ParseErrors::UnknownEnumerant("Dim", value))),
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum SamplerAddressingMode {
    None,
    ClampToEdge,
    Clamp,
    Repeat,
    RepeatMirrored,
}
impl SamplerAddressingMode {
    fn parse(reader: &mut InstructionReader) -> Result<SamplerAddressingMode, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::None,
            1u32 => Self::ClampToEdge,
            2u32 => Self::Clamp,
            3u32 => Self::Repeat,
            4u32 => Self::RepeatMirrored,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant(
                    "SamplerAddressingMode",
                    value,
                )))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum SamplerFilterMode {
    Nearest,
    Linear,
}
impl SamplerFilterMode {
    fn parse(reader: &mut InstructionReader) -> Result<SamplerFilterMode, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Nearest,
            1u32 => Self::Linear,
            value => {
                return Err(
                    reader.map_err(ParseErrors::UnknownEnumerant("SamplerFilterMode", value))
                )
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum ImageFormat {
    Unknown,
    Rgba32f,
    Rgba16f,
    R32f,
    Rgba8,
    Rgba8Snorm,
    Rg32f,
    Rg16f,
    R11fG11fB10f,
    R16f,
    Rgba16,
    Rgb10A2,
    Rg16,
    Rg8,
    R16,
    R8,
    Rgba16Snorm,
    Rg16Snorm,
    Rg8Snorm,
    R16Snorm,
    R8Snorm,
    Rgba32i,
    Rgba16i,
    Rgba8i,
    R32i,
    Rg32i,
    Rg16i,
    Rg8i,
    R16i,
    R8i,
    Rgba32ui,
    Rgba16ui,
    Rgba8ui,
    R32ui,
    Rgb10a2ui,
    Rg32ui,
    Rg16ui,
    Rg8ui,
    R16ui,
    R8ui,
    R64ui,
    R64i,
}
impl ImageFormat {
    fn parse(reader: &mut InstructionReader) -> Result<ImageFormat, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Unknown,
            1u32 => Self::Rgba32f,
            2u32 => Self::Rgba16f,
            3u32 => Self::R32f,
            4u32 => Self::Rgba8,
            5u32 => Self::Rgba8Snorm,
            6u32 => Self::Rg32f,
            7u32 => Self::Rg16f,
            8u32 => Self::R11fG11fB10f,
            9u32 => Self::R16f,
            10u32 => Self::Rgba16,
            11u32 => Self::Rgb10A2,
            12u32 => Self::Rg16,
            13u32 => Self::Rg8,
            14u32 => Self::R16,
            15u32 => Self::R8,
            16u32 => Self::Rgba16Snorm,
            17u32 => Self::Rg16Snorm,
            18u32 => Self::Rg8Snorm,
            19u32 => Self::R16Snorm,
            20u32 => Self::R8Snorm,
            21u32 => Self::Rgba32i,
            22u32 => Self::Rgba16i,
            23u32 => Self::Rgba8i,
            24u32 => Self::R32i,
            25u32 => Self::Rg32i,
            26u32 => Self::Rg16i,
            27u32 => Self::Rg8i,
            28u32 => Self::R16i,
            29u32 => Self::R8i,
            30u32 => Self::Rgba32ui,
            31u32 => Self::Rgba16ui,
            32u32 => Self::Rgba8ui,
            33u32 => Self::R32ui,
            34u32 => Self::Rgb10a2ui,
            35u32 => Self::Rg32ui,
            36u32 => Self::Rg16ui,
            37u32 => Self::Rg8ui,
            38u32 => Self::R16ui,
            39u32 => Self::R8ui,
            40u32 => Self::R64ui,
            41u32 => Self::R64i,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("ImageFormat", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum ImageChannelOrder {
    R,
    A,
    RG,
    RA,
    RGB,
    RGBA,
    BGRA,
    ARGB,
    Intensity,
    Luminance,
    Rx,
    RGx,
    RGBx,
    Depth,
    DepthStencil,
    sRGB,
    sRGBx,
    sRGBA,
    sBGRA,
    ABGR,
}
impl ImageChannelOrder {
    fn parse(reader: &mut InstructionReader) -> Result<ImageChannelOrder, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::R,
            1u32 => Self::A,
            2u32 => Self::RG,
            3u32 => Self::RA,
            4u32 => Self::RGB,
            5u32 => Self::RGBA,
            6u32 => Self::BGRA,
            7u32 => Self::ARGB,
            8u32 => Self::Intensity,
            9u32 => Self::Luminance,
            10u32 => Self::Rx,
            11u32 => Self::RGx,
            12u32 => Self::RGBx,
            13u32 => Self::Depth,
            14u32 => Self::DepthStencil,
            15u32 => Self::sRGB,
            16u32 => Self::sRGBx,
            17u32 => Self::sRGBA,
            18u32 => Self::sBGRA,
            19u32 => Self::ABGR,
            value => {
                return Err(
                    reader.map_err(ParseErrors::UnknownEnumerant("ImageChannelOrder", value))
                )
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum ImageChannelDataType {
    SnormInt8,
    SnormInt16,
    UnormInt8,
    UnormInt16,
    UnormShort565,
    UnormShort555,
    UnormInt101010,
    SignedInt8,
    SignedInt16,
    SignedInt32,
    UnsignedInt8,
    UnsignedInt16,
    UnsignedInt32,
    HalfFloat,
    Float,
    UnormInt24,
    UnormInt101010_2,
}
impl ImageChannelDataType {
    fn parse(reader: &mut InstructionReader) -> Result<ImageChannelDataType, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::SnormInt8,
            1u32 => Self::SnormInt16,
            2u32 => Self::UnormInt8,
            3u32 => Self::UnormInt16,
            4u32 => Self::UnormShort565,
            5u32 => Self::UnormShort555,
            6u32 => Self::UnormInt101010,
            7u32 => Self::SignedInt8,
            8u32 => Self::SignedInt16,
            9u32 => Self::SignedInt32,
            10u32 => Self::UnsignedInt8,
            11u32 => Self::UnsignedInt16,
            12u32 => Self::UnsignedInt32,
            13u32 => Self::HalfFloat,
            14u32 => Self::Float,
            15u32 => Self::UnormInt24,
            16u32 => Self::UnormInt101010_2,
            value => {
                return Err(
                    reader.map_err(ParseErrors::UnknownEnumerant("ImageChannelDataType", value))
                )
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum FPRoundingMode {
    RTE,
    RTZ,
    RTP,
    RTN,
}
impl FPRoundingMode {
    fn parse(reader: &mut InstructionReader) -> Result<FPRoundingMode, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::RTE,
            1u32 => Self::RTZ,
            2u32 => Self::RTP,
            3u32 => Self::RTN,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("FPRoundingMode", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum FPDenormMode {
    Preserve,
    FlushToZero,
}
impl FPDenormMode {
    fn parse(reader: &mut InstructionReader) -> Result<FPDenormMode, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Preserve,
            1u32 => Self::FlushToZero,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("FPDenormMode", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum QuantizationModes {
    TRN,
    TRN_ZERO,
    RND,
    RND_ZERO,
    RND_INF,
    RND_MIN_INF,
    RND_CONV,
    RND_CONV_ODD,
}
impl QuantizationModes {
    fn parse(reader: &mut InstructionReader) -> Result<QuantizationModes, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::TRN,
            1u32 => Self::TRN_ZERO,
            2u32 => Self::RND,
            3u32 => Self::RND_ZERO,
            4u32 => Self::RND_INF,
            5u32 => Self::RND_MIN_INF,
            6u32 => Self::RND_CONV,
            7u32 => Self::RND_CONV_ODD,
            value => {
                return Err(
                    reader.map_err(ParseErrors::UnknownEnumerant("QuantizationModes", value))
                )
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum FPOperationMode {
    IEEE,
    ALT,
}
impl FPOperationMode {
    fn parse(reader: &mut InstructionReader) -> Result<FPOperationMode, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::IEEE,
            1u32 => Self::ALT,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("FPOperationMode", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum OverflowModes {
    WRAP,
    SAT,
    SAT_ZERO,
    SAT_SYM,
}
impl OverflowModes {
    fn parse(reader: &mut InstructionReader) -> Result<OverflowModes, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::WRAP,
            1u32 => Self::SAT,
            2u32 => Self::SAT_ZERO,
            3u32 => Self::SAT_SYM,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("OverflowModes", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum LinkageType {
    Export,
    Import,
    LinkOnceODR,
}
impl LinkageType {
    fn parse(reader: &mut InstructionReader) -> Result<LinkageType, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Export,
            1u32 => Self::Import,
            2u32 => Self::LinkOnceODR,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("LinkageType", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum AccessQualifier {
    ReadOnly,
    WriteOnly,
    ReadWrite,
}
impl AccessQualifier {
    fn parse(reader: &mut InstructionReader) -> Result<AccessQualifier, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::ReadOnly,
            1u32 => Self::WriteOnly,
            2u32 => Self::ReadWrite,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("AccessQualifier", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum FunctionParameterAttribute {
    Zext,
    Sext,
    ByVal,
    Sret,
    NoAlias,
    NoCapture,
    NoWrite,
    NoReadWrite,
}
impl FunctionParameterAttribute {
    fn parse(reader: &mut InstructionReader) -> Result<FunctionParameterAttribute, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Zext,
            1u32 => Self::Sext,
            2u32 => Self::ByVal,
            3u32 => Self::Sret,
            4u32 => Self::NoAlias,
            5u32 => Self::NoCapture,
            6u32 => Self::NoWrite,
            7u32 => Self::NoReadWrite,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant(
                    "FunctionParameterAttribute",
                    value,
                )))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum Decoration {
    RelaxedPrecision,
    SpecId {
        specialization_constant_id: u32,
    },
    Block,
    BufferBlock,
    RowMajor,
    ColMajor,
    ArrayStride {
        array_stride: u32,
    },
    MatrixStride {
        matrix_stride: u32,
    },
    GLSLShared,
    GLSLPacked,
    CPacked,
    BuiltIn {
        built_in: BuiltIn,
    },
    NoPerspective,
    Flat,
    Patch,
    Centroid,
    Sample,
    Invariant,
    Restrict,
    Aliased,
    Volatile,
    Constant,
    Coherent,
    NonWritable,
    NonReadable,
    Uniform,
    UniformId {
        execution: Id,
    },
    SaturatedConversion,
    Stream {
        stream_number: u32,
    },
    Location {
        location: u32,
    },
    Component {
        component: u32,
    },
    Index {
        index: u32,
    },
    Binding {
        binding_point: u32,
    },
    DescriptorSet {
        descriptor_set: u32,
    },
    Offset {
        byte_offset: u32,
    },
    XfbBuffer {
        xfb_buffer_number: u32,
    },
    XfbStride {
        xfb_stride: u32,
    },
    FuncParamAttr {
        function_parameter_attribute: FunctionParameterAttribute,
    },
    FPRoundingMode {
        floating_point_rounding_mode: FPRoundingMode,
    },
    FPFastMathMode {
        fast_math_mode: FPFastMathMode,
    },
    LinkageAttributes {
        name: String,
        linkage_type: LinkageType,
    },
    NoContraction,
    InputAttachmentIndex {
        attachment_index: u32,
    },
    Alignment {
        alignment: u32,
    },
    MaxByteOffset {
        max_byte_offset: u32,
    },
    AlignmentId {
        alignment: Id,
    },
    MaxByteOffsetId {
        max_byte_offset: Id,
    },
    NoSignedWrap,
    NoUnsignedWrap,
    ExplicitInterpAMD,
    OverrideCoverageNV,
    PassthroughNV,
    ViewportRelativeNV,
    SecondaryViewportRelativeNV {
        offset: u32,
    },
    PerPrimitiveNV,
    PerViewNV,
    PerTaskNV,
    PerVertexNV,
    NonUniform,
    RestrictPointer,
    AliasedPointer,
    BindlessSamplerNV,
    BindlessImageNV,
    BoundSamplerNV,
    BoundImageNV,
    SIMTCallINTEL {
        n: u32,
    },
    ReferencedIndirectlyINTEL,
    ClobberINTEL {
        register: String,
    },
    SideEffectsINTEL,
    VectorComputeVariableINTEL,
    FuncParamIOKindINTEL {
        kind: u32,
    },
    VectorComputeFunctionINTEL,
    StackCallINTEL,
    GlobalVariableOffsetINTEL {
        offset: u32,
    },
    CounterBuffer {
        counter_buffer: Id,
    },
    UserSemantic {
        semantic: String,
    },
    UserTypeGOOGLE {
        user_type: String,
    },
    FunctionRoundingModeINTEL {
        target_width: u32,
        fp_rounding_mode: FPRoundingMode,
    },
    FunctionDenormModeINTEL {
        target_width: u32,
        fp_denorm_mode: FPDenormMode,
    },
    RegisterINTEL,
    MemoryINTEL {
        memory_type: String,
    },
    NumbanksINTEL {
        banks: u32,
    },
    BankwidthINTEL {
        bank_width: u32,
    },
    MaxPrivateCopiesINTEL {
        maximum_copies: u32,
    },
    SinglepumpINTEL,
    DoublepumpINTEL,
    MaxReplicatesINTEL {
        maximum_replicates: u32,
    },
    SimpleDualPortINTEL,
    MergeINTEL {
        merge_key: String,
        merge_type: String,
    },
    BankBitsINTEL {
        bank_bits: u32,
    },
    ForcePow2DepthINTEL {
        force_key: u32,
    },
    BurstCoalesceINTEL,
    CacheSizeINTEL {
        cache_size_in_bytes: u32,
    },
    DontStaticallyCoalesceINTEL,
    PrefetchINTEL {
        prefetcher_size_in_bytes: u32,
    },
    StallEnableINTEL,
    FuseLoopsInFunctionINTEL,
    BufferLocationINTEL {
        buffer_location_id: u32,
    },
    IOPipeStorageINTEL {
        io_pipe_id: u32,
    },
    FunctionFloatingPointModeINTEL {
        target_width: u32,
        fp_operation_mode: FPOperationMode,
    },
    SingleElementVectorINTEL,
    VectorComputeCallableFunctionINTEL,
}
impl Decoration {
    fn parse(reader: &mut InstructionReader) -> Result<Decoration, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::RelaxedPrecision,
            1u32 => Self::SpecId {
                specialization_constant_id: reader.next_u32()?,
            },
            2u32 => Self::Block,
            3u32 => Self::BufferBlock,
            4u32 => Self::RowMajor,
            5u32 => Self::ColMajor,
            6u32 => Self::ArrayStride {
                array_stride: reader.next_u32()?,
            },
            7u32 => Self::MatrixStride {
                matrix_stride: reader.next_u32()?,
            },
            8u32 => Self::GLSLShared,
            9u32 => Self::GLSLPacked,
            10u32 => Self::CPacked,
            11u32 => Self::BuiltIn {
                built_in: BuiltIn::parse(reader)?,
            },
            13u32 => Self::NoPerspective,
            14u32 => Self::Flat,
            15u32 => Self::Patch,
            16u32 => Self::Centroid,
            17u32 => Self::Sample,
            18u32 => Self::Invariant,
            19u32 => Self::Restrict,
            20u32 => Self::Aliased,
            21u32 => Self::Volatile,
            22u32 => Self::Constant,
            23u32 => Self::Coherent,
            24u32 => Self::NonWritable,
            25u32 => Self::NonReadable,
            26u32 => Self::Uniform,
            27u32 => Self::UniformId {
                execution: Id(reader.next_u32()?),
            },
            28u32 => Self::SaturatedConversion,
            29u32 => Self::Stream {
                stream_number: reader.next_u32()?,
            },
            30u32 => Self::Location {
                location: reader.next_u32()?,
            },
            31u32 => Self::Component {
                component: reader.next_u32()?,
            },
            32u32 => Self::Index {
                index: reader.next_u32()?,
            },
            33u32 => Self::Binding {
                binding_point: reader.next_u32()?,
            },
            34u32 => Self::DescriptorSet {
                descriptor_set: reader.next_u32()?,
            },
            35u32 => Self::Offset {
                byte_offset: reader.next_u32()?,
            },
            36u32 => Self::XfbBuffer {
                xfb_buffer_number: reader.next_u32()?,
            },
            37u32 => Self::XfbStride {
                xfb_stride: reader.next_u32()?,
            },
            38u32 => Self::FuncParamAttr {
                function_parameter_attribute: FunctionParameterAttribute::parse(reader)?,
            },
            39u32 => Self::FPRoundingMode {
                floating_point_rounding_mode: FPRoundingMode::parse(reader)?,
            },
            40u32 => Self::FPFastMathMode {
                fast_math_mode: FPFastMathMode::parse(reader)?,
            },
            41u32 => Self::LinkageAttributes {
                name: reader.next_string()?,
                linkage_type: LinkageType::parse(reader)?,
            },
            42u32 => Self::NoContraction,
            43u32 => Self::InputAttachmentIndex {
                attachment_index: reader.next_u32()?,
            },
            44u32 => Self::Alignment {
                alignment: reader.next_u32()?,
            },
            45u32 => Self::MaxByteOffset {
                max_byte_offset: reader.next_u32()?,
            },
            46u32 => Self::AlignmentId {
                alignment: Id(reader.next_u32()?),
            },
            47u32 => Self::MaxByteOffsetId {
                max_byte_offset: Id(reader.next_u32()?),
            },
            4469u32 => Self::NoSignedWrap,
            4470u32 => Self::NoUnsignedWrap,
            4999u32 => Self::ExplicitInterpAMD,
            5248u32 => Self::OverrideCoverageNV,
            5250u32 => Self::PassthroughNV,
            5252u32 => Self::ViewportRelativeNV,
            5256u32 => Self::SecondaryViewportRelativeNV {
                offset: reader.next_u32()?,
            },
            5271u32 => Self::PerPrimitiveNV,
            5272u32 => Self::PerViewNV,
            5273u32 => Self::PerTaskNV,
            5285u32 => Self::PerVertexNV,
            5300u32 => Self::NonUniform,
            5355u32 => Self::RestrictPointer,
            5356u32 => Self::AliasedPointer,
            5398u32 => Self::BindlessSamplerNV,
            5399u32 => Self::BindlessImageNV,
            5400u32 => Self::BoundSamplerNV,
            5401u32 => Self::BoundImageNV,
            5599u32 => Self::SIMTCallINTEL {
                n: reader.next_u32()?,
            },
            5602u32 => Self::ReferencedIndirectlyINTEL,
            5607u32 => Self::ClobberINTEL {
                register: reader.next_string()?,
            },
            5608u32 => Self::SideEffectsINTEL,
            5624u32 => Self::VectorComputeVariableINTEL,
            5625u32 => Self::FuncParamIOKindINTEL {
                kind: reader.next_u32()?,
            },
            5626u32 => Self::VectorComputeFunctionINTEL,
            5627u32 => Self::StackCallINTEL,
            5628u32 => Self::GlobalVariableOffsetINTEL {
                offset: reader.next_u32()?,
            },
            5634u32 => Self::CounterBuffer {
                counter_buffer: Id(reader.next_u32()?),
            },
            5635u32 => Self::UserSemantic {
                semantic: reader.next_string()?,
            },
            5636u32 => Self::UserTypeGOOGLE {
                user_type: reader.next_string()?,
            },
            5822u32 => Self::FunctionRoundingModeINTEL {
                target_width: reader.next_u32()?,
                fp_rounding_mode: FPRoundingMode::parse(reader)?,
            },
            5823u32 => Self::FunctionDenormModeINTEL {
                target_width: reader.next_u32()?,
                fp_denorm_mode: FPDenormMode::parse(reader)?,
            },
            5825u32 => Self::RegisterINTEL,
            5826u32 => Self::MemoryINTEL {
                memory_type: reader.next_string()?,
            },
            5827u32 => Self::NumbanksINTEL {
                banks: reader.next_u32()?,
            },
            5828u32 => Self::BankwidthINTEL {
                bank_width: reader.next_u32()?,
            },
            5829u32 => Self::MaxPrivateCopiesINTEL {
                maximum_copies: reader.next_u32()?,
            },
            5830u32 => Self::SinglepumpINTEL,
            5831u32 => Self::DoublepumpINTEL,
            5832u32 => Self::MaxReplicatesINTEL {
                maximum_replicates: reader.next_u32()?,
            },
            5833u32 => Self::SimpleDualPortINTEL,
            5834u32 => Self::MergeINTEL {
                merge_key: reader.next_string()?,
                merge_type: reader.next_string()?,
            },
            5835u32 => Self::BankBitsINTEL {
                bank_bits: reader.next_u32()?,
            },
            5836u32 => Self::ForcePow2DepthINTEL {
                force_key: reader.next_u32()?,
            },
            5899u32 => Self::BurstCoalesceINTEL,
            5900u32 => Self::CacheSizeINTEL {
                cache_size_in_bytes: reader.next_u32()?,
            },
            5901u32 => Self::DontStaticallyCoalesceINTEL,
            5902u32 => Self::PrefetchINTEL {
                prefetcher_size_in_bytes: reader.next_u32()?,
            },
            5905u32 => Self::StallEnableINTEL,
            5907u32 => Self::FuseLoopsInFunctionINTEL,
            5921u32 => Self::BufferLocationINTEL {
                buffer_location_id: reader.next_u32()?,
            },
            5944u32 => Self::IOPipeStorageINTEL {
                io_pipe_id: reader.next_u32()?,
            },
            6080u32 => Self::FunctionFloatingPointModeINTEL {
                target_width: reader.next_u32()?,
                fp_operation_mode: FPOperationMode::parse(reader)?,
            },
            6085u32 => Self::SingleElementVectorINTEL,
            6087u32 => Self::VectorComputeCallableFunctionINTEL,
            value => return Err(reader.map_err(ParseErrors::UnknownEnumerant("Decoration", value))),
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum BuiltIn {
    Position,
    PointSize,
    ClipDistance,
    CullDistance,
    VertexId,
    InstanceId,
    PrimitiveId,
    InvocationId,
    Layer,
    ViewportIndex,
    TessLevelOuter,
    TessLevelInner,
    TessCoord,
    PatchVertices,
    FragCoord,
    PointCoord,
    FrontFacing,
    SampleId,
    SamplePosition,
    SampleMask,
    FragDepth,
    HelperInvocation,
    NumWorkgroups,
    WorkgroupSize,
    WorkgroupId,
    LocalInvocationId,
    GlobalInvocationId,
    LocalInvocationIndex,
    WorkDim,
    GlobalSize,
    EnqueuedWorkgroupSize,
    GlobalOffset,
    GlobalLinearId,
    SubgroupSize,
    SubgroupMaxSize,
    NumSubgroups,
    NumEnqueuedSubgroups,
    SubgroupId,
    SubgroupLocalInvocationId,
    VertexIndex,
    InstanceIndex,
    SubgroupEqMask,
    SubgroupGeMask,
    SubgroupGtMask,
    SubgroupLeMask,
    SubgroupLtMask,
    BaseVertex,
    BaseInstance,
    DrawIndex,
    PrimitiveShadingRateKHR,
    DeviceIndex,
    ViewIndex,
    ShadingRateKHR,
    BaryCoordNoPerspAMD,
    BaryCoordNoPerspCentroidAMD,
    BaryCoordNoPerspSampleAMD,
    BaryCoordSmoothAMD,
    BaryCoordSmoothCentroidAMD,
    BaryCoordSmoothSampleAMD,
    BaryCoordPullModelAMD,
    FragStencilRefEXT,
    ViewportMaskNV,
    SecondaryPositionNV,
    SecondaryViewportMaskNV,
    PositionPerViewNV,
    ViewportMaskPerViewNV,
    FullyCoveredEXT,
    TaskCountNV,
    PrimitiveCountNV,
    PrimitiveIndicesNV,
    ClipDistancePerViewNV,
    CullDistancePerViewNV,
    LayerPerViewNV,
    MeshViewCountNV,
    MeshViewIndicesNV,
    BaryCoordNV,
    BaryCoordNoPerspNV,
    FragSizeEXT,
    FragInvocationCountEXT,
    LaunchIdKHR,
    LaunchSizeKHR,
    WorldRayOriginKHR,
    WorldRayDirectionKHR,
    ObjectRayOriginKHR,
    ObjectRayDirectionKHR,
    RayTminKHR,
    RayTmaxKHR,
    InstanceCustomIndexKHR,
    ObjectToWorldKHR,
    WorldToObjectKHR,
    HitTNV,
    HitKindKHR,
    CurrentRayTimeNV,
    IncomingRayFlagsKHR,
    RayGeometryIndexKHR,
    WarpsPerSMNV,
    SMCountNV,
    WarpIDNV,
    SMIDNV,
}
impl BuiltIn {
    fn parse(reader: &mut InstructionReader) -> Result<BuiltIn, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Position,
            1u32 => Self::PointSize,
            3u32 => Self::ClipDistance,
            4u32 => Self::CullDistance,
            5u32 => Self::VertexId,
            6u32 => Self::InstanceId,
            7u32 => Self::PrimitiveId,
            8u32 => Self::InvocationId,
            9u32 => Self::Layer,
            10u32 => Self::ViewportIndex,
            11u32 => Self::TessLevelOuter,
            12u32 => Self::TessLevelInner,
            13u32 => Self::TessCoord,
            14u32 => Self::PatchVertices,
            15u32 => Self::FragCoord,
            16u32 => Self::PointCoord,
            17u32 => Self::FrontFacing,
            18u32 => Self::SampleId,
            19u32 => Self::SamplePosition,
            20u32 => Self::SampleMask,
            22u32 => Self::FragDepth,
            23u32 => Self::HelperInvocation,
            24u32 => Self::NumWorkgroups,
            25u32 => Self::WorkgroupSize,
            26u32 => Self::WorkgroupId,
            27u32 => Self::LocalInvocationId,
            28u32 => Self::GlobalInvocationId,
            29u32 => Self::LocalInvocationIndex,
            30u32 => Self::WorkDim,
            31u32 => Self::GlobalSize,
            32u32 => Self::EnqueuedWorkgroupSize,
            33u32 => Self::GlobalOffset,
            34u32 => Self::GlobalLinearId,
            36u32 => Self::SubgroupSize,
            37u32 => Self::SubgroupMaxSize,
            38u32 => Self::NumSubgroups,
            39u32 => Self::NumEnqueuedSubgroups,
            40u32 => Self::SubgroupId,
            41u32 => Self::SubgroupLocalInvocationId,
            42u32 => Self::VertexIndex,
            43u32 => Self::InstanceIndex,
            4416u32 => Self::SubgroupEqMask,
            4417u32 => Self::SubgroupGeMask,
            4418u32 => Self::SubgroupGtMask,
            4419u32 => Self::SubgroupLeMask,
            4420u32 => Self::SubgroupLtMask,
            4424u32 => Self::BaseVertex,
            4425u32 => Self::BaseInstance,
            4426u32 => Self::DrawIndex,
            4432u32 => Self::PrimitiveShadingRateKHR,
            4438u32 => Self::DeviceIndex,
            4440u32 => Self::ViewIndex,
            4444u32 => Self::ShadingRateKHR,
            4992u32 => Self::BaryCoordNoPerspAMD,
            4993u32 => Self::BaryCoordNoPerspCentroidAMD,
            4994u32 => Self::BaryCoordNoPerspSampleAMD,
            4995u32 => Self::BaryCoordSmoothAMD,
            4996u32 => Self::BaryCoordSmoothCentroidAMD,
            4997u32 => Self::BaryCoordSmoothSampleAMD,
            4998u32 => Self::BaryCoordPullModelAMD,
            5014u32 => Self::FragStencilRefEXT,
            5253u32 => Self::ViewportMaskNV,
            5257u32 => Self::SecondaryPositionNV,
            5258u32 => Self::SecondaryViewportMaskNV,
            5261u32 => Self::PositionPerViewNV,
            5262u32 => Self::ViewportMaskPerViewNV,
            5264u32 => Self::FullyCoveredEXT,
            5274u32 => Self::TaskCountNV,
            5275u32 => Self::PrimitiveCountNV,
            5276u32 => Self::PrimitiveIndicesNV,
            5277u32 => Self::ClipDistancePerViewNV,
            5278u32 => Self::CullDistancePerViewNV,
            5279u32 => Self::LayerPerViewNV,
            5280u32 => Self::MeshViewCountNV,
            5281u32 => Self::MeshViewIndicesNV,
            5286u32 => Self::BaryCoordNV,
            5287u32 => Self::BaryCoordNoPerspNV,
            5292u32 => Self::FragSizeEXT,
            5293u32 => Self::FragInvocationCountEXT,
            5319u32 => Self::LaunchIdKHR,
            5320u32 => Self::LaunchSizeKHR,
            5321u32 => Self::WorldRayOriginKHR,
            5322u32 => Self::WorldRayDirectionKHR,
            5323u32 => Self::ObjectRayOriginKHR,
            5324u32 => Self::ObjectRayDirectionKHR,
            5325u32 => Self::RayTminKHR,
            5326u32 => Self::RayTmaxKHR,
            5327u32 => Self::InstanceCustomIndexKHR,
            5330u32 => Self::ObjectToWorldKHR,
            5331u32 => Self::WorldToObjectKHR,
            5332u32 => Self::HitTNV,
            5333u32 => Self::HitKindKHR,
            5334u32 => Self::CurrentRayTimeNV,
            5351u32 => Self::IncomingRayFlagsKHR,
            5352u32 => Self::RayGeometryIndexKHR,
            5374u32 => Self::WarpsPerSMNV,
            5375u32 => Self::SMCountNV,
            5376u32 => Self::WarpIDNV,
            5377u32 => Self::SMIDNV,
            value => return Err(reader.map_err(ParseErrors::UnknownEnumerant("BuiltIn", value))),
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum Scope {
    CrossDevice,
    Device,
    Workgroup,
    Subgroup,
    Invocation,
    QueueFamily,
    ShaderCallKHR,
}
impl Scope {
    fn parse(reader: &mut InstructionReader) -> Result<Scope, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::CrossDevice,
            1u32 => Self::Device,
            2u32 => Self::Workgroup,
            3u32 => Self::Subgroup,
            4u32 => Self::Invocation,
            5u32 => Self::QueueFamily,
            6u32 => Self::ShaderCallKHR,
            value => return Err(reader.map_err(ParseErrors::UnknownEnumerant("Scope", value))),
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum GroupOperation {
    Reduce,
    InclusiveScan,
    ExclusiveScan,
    ClusteredReduce,
    PartitionedReduceNV,
    PartitionedInclusiveScanNV,
    PartitionedExclusiveScanNV,
}
impl GroupOperation {
    fn parse(reader: &mut InstructionReader) -> Result<GroupOperation, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Reduce,
            1u32 => Self::InclusiveScan,
            2u32 => Self::ExclusiveScan,
            3u32 => Self::ClusteredReduce,
            6u32 => Self::PartitionedReduceNV,
            7u32 => Self::PartitionedInclusiveScanNV,
            8u32 => Self::PartitionedExclusiveScanNV,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant("GroupOperation", value)))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum KernelEnqueueFlags {
    NoWait,
    WaitKernel,
    WaitWorkGroup,
}
impl KernelEnqueueFlags {
    fn parse(reader: &mut InstructionReader) -> Result<KernelEnqueueFlags, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::NoWait,
            1u32 => Self::WaitKernel,
            2u32 => Self::WaitWorkGroup,
            value => {
                return Err(
                    reader.map_err(ParseErrors::UnknownEnumerant("KernelEnqueueFlags", value))
                )
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum Capability {
    Matrix,
    Shader,
    Geometry,
    Tessellation,
    Addresses,
    Linkage,
    Kernel,
    Vector16,
    Float16Buffer,
    Float16,
    Float64,
    Int64,
    Int64Atomics,
    ImageBasic,
    ImageReadWrite,
    ImageMipmap,
    Pipes,
    Groups,
    DeviceEnqueue,
    LiteralSampler,
    AtomicStorage,
    Int16,
    TessellationPointSize,
    GeometryPointSize,
    ImageGatherExtended,
    StorageImageMultisample,
    UniformBufferArrayDynamicIndexing,
    SampledImageArrayDynamicIndexing,
    StorageBufferArrayDynamicIndexing,
    StorageImageArrayDynamicIndexing,
    ClipDistance,
    CullDistance,
    ImageCubeArray,
    SampleRateShading,
    ImageRect,
    SampledRect,
    GenericPointer,
    Int8,
    InputAttachment,
    SparseResidency,
    MinLod,
    Sampled1D,
    Image1D,
    SampledCubeArray,
    SampledBuffer,
    ImageBuffer,
    ImageMSArray,
    StorageImageExtendedFormats,
    ImageQuery,
    DerivativeControl,
    InterpolationFunction,
    TransformFeedback,
    GeometryStreams,
    StorageImageReadWithoutFormat,
    StorageImageWriteWithoutFormat,
    MultiViewport,
    SubgroupDispatch,
    NamedBarrier,
    PipeStorage,
    GroupNonUniform,
    GroupNonUniformVote,
    GroupNonUniformArithmetic,
    GroupNonUniformBallot,
    GroupNonUniformShuffle,
    GroupNonUniformShuffleRelative,
    GroupNonUniformClustered,
    GroupNonUniformQuad,
    ShaderLayer,
    ShaderViewportIndex,
    FragmentShadingRateKHR,
    SubgroupBallotKHR,
    DrawParameters,
    WorkgroupMemoryExplicitLayoutKHR,
    WorkgroupMemoryExplicitLayout8BitAccessKHR,
    WorkgroupMemoryExplicitLayout16BitAccessKHR,
    SubgroupVoteKHR,
    StorageBuffer16BitAccess,
    UniformAndStorageBuffer16BitAccess,
    StoragePushConstant16,
    StorageInputOutput16,
    DeviceGroup,
    MultiView,
    VariablePointersStorageBuffer,
    VariablePointers,
    AtomicStorageOps,
    SampleMaskPostDepthCoverage,
    StorageBuffer8BitAccess,
    UniformAndStorageBuffer8BitAccess,
    StoragePushConstant8,
    DenormPreserve,
    DenormFlushToZero,
    SignedZeroInfNanPreserve,
    RoundingModeRTE,
    RoundingModeRTZ,
    RayQueryProvisionalKHR,
    RayQueryKHR,
    RayTraversalPrimitiveCullingKHR,
    RayTracingKHR,
    Float16ImageAMD,
    ImageGatherBiasLodAMD,
    FragmentMaskAMD,
    StencilExportEXT,
    ImageReadWriteLodAMD,
    Int64ImageEXT,
    ShaderClockKHR,
    SampleMaskOverrideCoverageNV,
    GeometryShaderPassthroughNV,
    ShaderViewportIndexLayerEXT,
    ShaderViewportMaskNV,
    ShaderStereoViewNV,
    PerViewAttributesNV,
    FragmentFullyCoveredEXT,
    MeshShadingNV,
    ImageFootprintNV,
    FragmentBarycentricNV,
    ComputeDerivativeGroupQuadsNV,
    FragmentDensityEXT,
    GroupNonUniformPartitionedNV,
    ShaderNonUniform,
    RuntimeDescriptorArray,
    InputAttachmentArrayDynamicIndexing,
    UniformTexelBufferArrayDynamicIndexing,
    StorageTexelBufferArrayDynamicIndexing,
    UniformBufferArrayNonUniformIndexing,
    SampledImageArrayNonUniformIndexing,
    StorageBufferArrayNonUniformIndexing,
    StorageImageArrayNonUniformIndexing,
    InputAttachmentArrayNonUniformIndexing,
    UniformTexelBufferArrayNonUniformIndexing,
    StorageTexelBufferArrayNonUniformIndexing,
    RayTracingNV,
    RayTracingMotionBlurNV,
    VulkanMemoryModel,
    VulkanMemoryModelDeviceScope,
    PhysicalStorageBufferAddresses,
    ComputeDerivativeGroupLinearNV,
    RayTracingProvisionalKHR,
    CooperativeMatrixNV,
    FragmentShaderSampleInterlockEXT,
    FragmentShaderShadingRateInterlockEXT,
    ShaderSMBuiltinsNV,
    FragmentShaderPixelInterlockEXT,
    DemoteToHelperInvocationEXT,
    BindlessTextureNV,
    SubgroupShuffleINTEL,
    SubgroupBufferBlockIOINTEL,
    SubgroupImageBlockIOINTEL,
    SubgroupImageMediaBlockIOINTEL,
    RoundToInfinityINTEL,
    FloatingPointModeINTEL,
    IntegerFunctions2INTEL,
    FunctionPointersINTEL,
    IndirectReferencesINTEL,
    AsmINTEL,
    AtomicFloat32MinMaxEXT,
    AtomicFloat64MinMaxEXT,
    AtomicFloat16MinMaxEXT,
    VectorComputeINTEL,
    VectorAnyINTEL,
    ExpectAssumeKHR,
    SubgroupAvcMotionEstimationINTEL,
    SubgroupAvcMotionEstimationIntraINTEL,
    SubgroupAvcMotionEstimationChromaINTEL,
    VariableLengthArrayINTEL,
    FunctionFloatControlINTEL,
    FPGAMemoryAttributesINTEL,
    FPFastMathModeINTEL,
    ArbitraryPrecisionIntegersINTEL,
    ArbitraryPrecisionFloatingPointINTEL,
    UnstructuredLoopControlsINTEL,
    FPGALoopControlsINTEL,
    KernelAttributesINTEL,
    FPGAKernelAttributesINTEL,
    FPGAMemoryAccessesINTEL,
    FPGAClusterAttributesINTEL,
    LoopFuseINTEL,
    FPGABufferLocationINTEL,
    ArbitraryPrecisionFixedPointINTEL,
    USMStorageClassesINTEL,
    IOPipesINTEL,
    BlockingPipesINTEL,
    FPGARegINTEL,
    DotProductInputAllKHR,
    DotProductInput4x8BitKHR,
    DotProductInput4x8BitPackedKHR,
    DotProductKHR,
    BitInstructions,
    AtomicFloat32AddEXT,
    AtomicFloat64AddEXT,
    LongConstantCompositeINTEL,
    OptNoneINTEL,
    AtomicFloat16AddEXT,
    DebugInfoModuleINTEL,
}
impl Capability {
    fn parse(reader: &mut InstructionReader) -> Result<Capability, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::Matrix,
            1u32 => Self::Shader,
            2u32 => Self::Geometry,
            3u32 => Self::Tessellation,
            4u32 => Self::Addresses,
            5u32 => Self::Linkage,
            6u32 => Self::Kernel,
            7u32 => Self::Vector16,
            8u32 => Self::Float16Buffer,
            9u32 => Self::Float16,
            10u32 => Self::Float64,
            11u32 => Self::Int64,
            12u32 => Self::Int64Atomics,
            13u32 => Self::ImageBasic,
            14u32 => Self::ImageReadWrite,
            15u32 => Self::ImageMipmap,
            17u32 => Self::Pipes,
            18u32 => Self::Groups,
            19u32 => Self::DeviceEnqueue,
            20u32 => Self::LiteralSampler,
            21u32 => Self::AtomicStorage,
            22u32 => Self::Int16,
            23u32 => Self::TessellationPointSize,
            24u32 => Self::GeometryPointSize,
            25u32 => Self::ImageGatherExtended,
            27u32 => Self::StorageImageMultisample,
            28u32 => Self::UniformBufferArrayDynamicIndexing,
            29u32 => Self::SampledImageArrayDynamicIndexing,
            30u32 => Self::StorageBufferArrayDynamicIndexing,
            31u32 => Self::StorageImageArrayDynamicIndexing,
            32u32 => Self::ClipDistance,
            33u32 => Self::CullDistance,
            34u32 => Self::ImageCubeArray,
            35u32 => Self::SampleRateShading,
            36u32 => Self::ImageRect,
            37u32 => Self::SampledRect,
            38u32 => Self::GenericPointer,
            39u32 => Self::Int8,
            40u32 => Self::InputAttachment,
            41u32 => Self::SparseResidency,
            42u32 => Self::MinLod,
            43u32 => Self::Sampled1D,
            44u32 => Self::Image1D,
            45u32 => Self::SampledCubeArray,
            46u32 => Self::SampledBuffer,
            47u32 => Self::ImageBuffer,
            48u32 => Self::ImageMSArray,
            49u32 => Self::StorageImageExtendedFormats,
            50u32 => Self::ImageQuery,
            51u32 => Self::DerivativeControl,
            52u32 => Self::InterpolationFunction,
            53u32 => Self::TransformFeedback,
            54u32 => Self::GeometryStreams,
            55u32 => Self::StorageImageReadWithoutFormat,
            56u32 => Self::StorageImageWriteWithoutFormat,
            57u32 => Self::MultiViewport,
            58u32 => Self::SubgroupDispatch,
            59u32 => Self::NamedBarrier,
            60u32 => Self::PipeStorage,
            61u32 => Self::GroupNonUniform,
            62u32 => Self::GroupNonUniformVote,
            63u32 => Self::GroupNonUniformArithmetic,
            64u32 => Self::GroupNonUniformBallot,
            65u32 => Self::GroupNonUniformShuffle,
            66u32 => Self::GroupNonUniformShuffleRelative,
            67u32 => Self::GroupNonUniformClustered,
            68u32 => Self::GroupNonUniformQuad,
            69u32 => Self::ShaderLayer,
            70u32 => Self::ShaderViewportIndex,
            4422u32 => Self::FragmentShadingRateKHR,
            4423u32 => Self::SubgroupBallotKHR,
            4427u32 => Self::DrawParameters,
            4428u32 => Self::WorkgroupMemoryExplicitLayoutKHR,
            4429u32 => Self::WorkgroupMemoryExplicitLayout8BitAccessKHR,
            4430u32 => Self::WorkgroupMemoryExplicitLayout16BitAccessKHR,
            4431u32 => Self::SubgroupVoteKHR,
            4433u32 => Self::StorageBuffer16BitAccess,
            4434u32 => Self::UniformAndStorageBuffer16BitAccess,
            4435u32 => Self::StoragePushConstant16,
            4436u32 => Self::StorageInputOutput16,
            4437u32 => Self::DeviceGroup,
            4439u32 => Self::MultiView,
            4441u32 => Self::VariablePointersStorageBuffer,
            4442u32 => Self::VariablePointers,
            4445u32 => Self::AtomicStorageOps,
            4447u32 => Self::SampleMaskPostDepthCoverage,
            4448u32 => Self::StorageBuffer8BitAccess,
            4449u32 => Self::UniformAndStorageBuffer8BitAccess,
            4450u32 => Self::StoragePushConstant8,
            4464u32 => Self::DenormPreserve,
            4465u32 => Self::DenormFlushToZero,
            4466u32 => Self::SignedZeroInfNanPreserve,
            4467u32 => Self::RoundingModeRTE,
            4468u32 => Self::RoundingModeRTZ,
            4471u32 => Self::RayQueryProvisionalKHR,
            4472u32 => Self::RayQueryKHR,
            4478u32 => Self::RayTraversalPrimitiveCullingKHR,
            4479u32 => Self::RayTracingKHR,
            5008u32 => Self::Float16ImageAMD,
            5009u32 => Self::ImageGatherBiasLodAMD,
            5010u32 => Self::FragmentMaskAMD,
            5013u32 => Self::StencilExportEXT,
            5015u32 => Self::ImageReadWriteLodAMD,
            5016u32 => Self::Int64ImageEXT,
            5055u32 => Self::ShaderClockKHR,
            5249u32 => Self::SampleMaskOverrideCoverageNV,
            5251u32 => Self::GeometryShaderPassthroughNV,
            5254u32 => Self::ShaderViewportIndexLayerEXT,
            5255u32 => Self::ShaderViewportMaskNV,
            5259u32 => Self::ShaderStereoViewNV,
            5260u32 => Self::PerViewAttributesNV,
            5265u32 => Self::FragmentFullyCoveredEXT,
            5266u32 => Self::MeshShadingNV,
            5282u32 => Self::ImageFootprintNV,
            5284u32 => Self::FragmentBarycentricNV,
            5288u32 => Self::ComputeDerivativeGroupQuadsNV,
            5291u32 => Self::FragmentDensityEXT,
            5297u32 => Self::GroupNonUniformPartitionedNV,
            5301u32 => Self::ShaderNonUniform,
            5302u32 => Self::RuntimeDescriptorArray,
            5303u32 => Self::InputAttachmentArrayDynamicIndexing,
            5304u32 => Self::UniformTexelBufferArrayDynamicIndexing,
            5305u32 => Self::StorageTexelBufferArrayDynamicIndexing,
            5306u32 => Self::UniformBufferArrayNonUniformIndexing,
            5307u32 => Self::SampledImageArrayNonUniformIndexing,
            5308u32 => Self::StorageBufferArrayNonUniformIndexing,
            5309u32 => Self::StorageImageArrayNonUniformIndexing,
            5310u32 => Self::InputAttachmentArrayNonUniformIndexing,
            5311u32 => Self::UniformTexelBufferArrayNonUniformIndexing,
            5312u32 => Self::StorageTexelBufferArrayNonUniformIndexing,
            5340u32 => Self::RayTracingNV,
            5341u32 => Self::RayTracingMotionBlurNV,
            5345u32 => Self::VulkanMemoryModel,
            5346u32 => Self::VulkanMemoryModelDeviceScope,
            5347u32 => Self::PhysicalStorageBufferAddresses,
            5350u32 => Self::ComputeDerivativeGroupLinearNV,
            5353u32 => Self::RayTracingProvisionalKHR,
            5357u32 => Self::CooperativeMatrixNV,
            5363u32 => Self::FragmentShaderSampleInterlockEXT,
            5372u32 => Self::FragmentShaderShadingRateInterlockEXT,
            5373u32 => Self::ShaderSMBuiltinsNV,
            5378u32 => Self::FragmentShaderPixelInterlockEXT,
            5379u32 => Self::DemoteToHelperInvocationEXT,
            5390u32 => Self::BindlessTextureNV,
            5568u32 => Self::SubgroupShuffleINTEL,
            5569u32 => Self::SubgroupBufferBlockIOINTEL,
            5570u32 => Self::SubgroupImageBlockIOINTEL,
            5579u32 => Self::SubgroupImageMediaBlockIOINTEL,
            5582u32 => Self::RoundToInfinityINTEL,
            5583u32 => Self::FloatingPointModeINTEL,
            5584u32 => Self::IntegerFunctions2INTEL,
            5603u32 => Self::FunctionPointersINTEL,
            5604u32 => Self::IndirectReferencesINTEL,
            5606u32 => Self::AsmINTEL,
            5612u32 => Self::AtomicFloat32MinMaxEXT,
            5613u32 => Self::AtomicFloat64MinMaxEXT,
            5616u32 => Self::AtomicFloat16MinMaxEXT,
            5617u32 => Self::VectorComputeINTEL,
            5619u32 => Self::VectorAnyINTEL,
            5629u32 => Self::ExpectAssumeKHR,
            5696u32 => Self::SubgroupAvcMotionEstimationINTEL,
            5697u32 => Self::SubgroupAvcMotionEstimationIntraINTEL,
            5698u32 => Self::SubgroupAvcMotionEstimationChromaINTEL,
            5817u32 => Self::VariableLengthArrayINTEL,
            5821u32 => Self::FunctionFloatControlINTEL,
            5824u32 => Self::FPGAMemoryAttributesINTEL,
            5837u32 => Self::FPFastMathModeINTEL,
            5844u32 => Self::ArbitraryPrecisionIntegersINTEL,
            5845u32 => Self::ArbitraryPrecisionFloatingPointINTEL,
            5886u32 => Self::UnstructuredLoopControlsINTEL,
            5888u32 => Self::FPGALoopControlsINTEL,
            5892u32 => Self::KernelAttributesINTEL,
            5897u32 => Self::FPGAKernelAttributesINTEL,
            5898u32 => Self::FPGAMemoryAccessesINTEL,
            5904u32 => Self::FPGAClusterAttributesINTEL,
            5906u32 => Self::LoopFuseINTEL,
            5920u32 => Self::FPGABufferLocationINTEL,
            5922u32 => Self::ArbitraryPrecisionFixedPointINTEL,
            5935u32 => Self::USMStorageClassesINTEL,
            5943u32 => Self::IOPipesINTEL,
            5945u32 => Self::BlockingPipesINTEL,
            5948u32 => Self::FPGARegINTEL,
            6016u32 => Self::DotProductInputAllKHR,
            6017u32 => Self::DotProductInput4x8BitKHR,
            6018u32 => Self::DotProductInput4x8BitPackedKHR,
            6019u32 => Self::DotProductKHR,
            6025u32 => Self::BitInstructions,
            6033u32 => Self::AtomicFloat32AddEXT,
            6034u32 => Self::AtomicFloat64AddEXT,
            6089u32 => Self::LongConstantCompositeINTEL,
            6094u32 => Self::OptNoneINTEL,
            6095u32 => Self::AtomicFloat16AddEXT,
            6114u32 => Self::DebugInfoModuleINTEL,
            value => return Err(reader.map_err(ParseErrors::UnknownEnumerant("Capability", value))),
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum RayQueryIntersection {
    RayQueryCandidateIntersectionKHR,
    RayQueryCommittedIntersectionKHR,
}
impl RayQueryIntersection {
    fn parse(reader: &mut InstructionReader) -> Result<RayQueryIntersection, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::RayQueryCandidateIntersectionKHR,
            1u32 => Self::RayQueryCommittedIntersectionKHR,
            value => {
                return Err(
                    reader.map_err(ParseErrors::UnknownEnumerant("RayQueryIntersection", value))
                )
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum RayQueryCommittedIntersectionType {
    RayQueryCommittedIntersectionNoneKHR,
    RayQueryCommittedIntersectionTriangleKHR,
    RayQueryCommittedIntersectionGeneratedKHR,
}
impl RayQueryCommittedIntersectionType {
    fn parse(
        reader: &mut InstructionReader,
    ) -> Result<RayQueryCommittedIntersectionType, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::RayQueryCommittedIntersectionNoneKHR,
            1u32 => Self::RayQueryCommittedIntersectionTriangleKHR,
            2u32 => Self::RayQueryCommittedIntersectionGeneratedKHR,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant(
                    "RayQueryCommittedIntersectionType",
                    value,
                )))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum RayQueryCandidateIntersectionType {
    RayQueryCandidateIntersectionTriangleKHR,
    RayQueryCandidateIntersectionAABBKHR,
}
impl RayQueryCandidateIntersectionType {
    fn parse(
        reader: &mut InstructionReader,
    ) -> Result<RayQueryCandidateIntersectionType, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::RayQueryCandidateIntersectionTriangleKHR,
            1u32 => Self::RayQueryCandidateIntersectionAABBKHR,
            value => {
                return Err(reader.map_err(ParseErrors::UnknownEnumerant(
                    "RayQueryCandidateIntersectionType",
                    value,
                )))
            }
        })
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(non_camel_case_types)]
pub enum PackedVectorFormat {
    PackedVectorFormat4x8BitKHR,
}
impl PackedVectorFormat {
    fn parse(reader: &mut InstructionReader) -> Result<PackedVectorFormat, ParseError> {
        Ok(match reader.next_u32()? {
            0u32 => Self::PackedVectorFormat4x8BitKHR,
            value => {
                return Err(
                    reader.map_err(ParseErrors::UnknownEnumerant("PackedVectorFormat", value))
                )
            }
        })
    }
}
